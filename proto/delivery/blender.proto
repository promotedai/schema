syntax = "proto3";
package delivery;

option java_multiple_files = true;
option java_package = "ai.promoted.proto.delivery";
option java_outer_classname = "Blender";
option go_package = "github.com/promotedai/schema/generated/go/proto/delivery";

// `BlenderConfig` configures how a set of insertions is blended, i.e. in what
// order the insertions are shown to a user. Setting either of these fields
// will override the respective optimized and tuned promoted.ai blending
// behaviour.
//
// Blender rules act as filters that reject or select insertion subsets (in
// the case of negative, positive, and insert rules), or penalize/boost
// insertion scores (in the case of diversity rules).
//
// A quality score config is used to construct a relative rank between all insertions
// by being applied to each insertion and calculating a quality score. A non-positive
// score (i.e negative or zero) means that an insertion cannot be allocated.
message BlenderConfig {
  // A list of blender rules. See the `BlenderRule` documentation for more information.
  //
  // Default: empty (blender will use optimized promoted.ai blender rules).
  repeated BlenderRule blender_rule = 1;
  // A quality score config to rank insertions by calculating their individual
  // quality score.
  //
  // Default: empty (blender will use promoted.ai models to calculate scores)
  QualityScoreConfig quality_score_config = 2;
}


// `BlenderRule` defines a blender rule that is sent to blender.
//
// Rules act as filters and are used to a) select a subset of insertions that
// match a predicate, and b) to select the insertion with maximum score among that
// group to eventually allocate it to a positoin.
//
//  There are 4 different kinds of rules:
//
// + Positive rules are the standard filter/selection mechanism. They select a
//   subset of insertions according to some configurable filters. From that
//   subset blender then selects the insertion with the highest score to allocate
//   at a position.
// + Negative rules reject insertions that *must not be* selected. While
//   positive rule act as a positive filter, negative rules are a negative
//   filter. Negative rules are always run before positive rules and restrict
//   the pool of insertion that any positive rule can select from.
// + Insert rules look and function very similar to positive rules, but ignore
//   negative rules. They take precedence over positive rules, and always select
//   from the entire pool of not-yet-allocated insertions. Use these if you require
//   that insertions with certain properties must be with higher priority.
// + Diversity rules are not selection filters. Instead they are used to create more
//   diversity among allocated insertions by applying a penalty (or a boost) to all
//   future insertions depending on the insertion that was just allocated.
message BlenderRule {
  // The name of an insertion property that this rule applies to.
  //
  // Default: empty (if `attribute_name` is not set, then this rule can't be matched to
  // any property and will be discarded because the subset of insertions it selects will
  // always be empty)
  string attribute_name = 1;
  reserved 2 to 5; // Reserving fields for future common fields.
  // A type of this blender rule. See their respective entries for more information.
  //
  // DEFAULT: none (if `rule` is not set, then this blender rule will be discarded,
  // because blender will not know what kind of rule this is)
  oneof rule {
    PositiveRule positive_rule = 6;
    InsertRule insert_rule = 7;
    NegativeRule negative_rule = 8;
    DiversityRule diversity_rule = 9;
  }

  // How to evaluate an insertion to determine if this rule should select it.
  // If the result of an evaluation is `true`, the insertion will be selected under
  // this rule. If `false`, it will not be selected.
  //
  // If an insertion lacks a matching attribute, it will always evaluate to `false`.
  //
  // See the respective eval method entries for more information.
  //
  // Default: flag (if `eval_method` is not set, this rule will fall back to
  // boolean evaluation and check if a the property with key `attribute_name` is
  // `true`)
  oneof eval_method {
    Flag flag = 11;
    GreaterThan greater_than = 13;
    LessThan less_than = 14;
    Interval interval = 15;
    EqualV2 equal_v2 = 16;
  }
}

// Tests if an insertion has a property with key `attribute_name` and if its value is `true`.
message Flag {
  // Does nothing.  Exists purely because of parquet not allowing empty groups (messages).
  optional bool ignored = 1 [deprecated = true];
}

// Tests if an insertion's property with key `attribute_name` and value `x`
// is equal to some number or string.
message EqualV2 {
    // The type of this equality, i.e. if it should evaluate numbers or strings.
    // 
    // Default: none (if `equality_type` is not set, then this equality method can
    // not be applied and the rule containing it will be dropped)
    oneof equality_type {
        Equal number = 1;
        StringEquality string_equality = 2;
    }
}

// Tests if an insertion's property with key `attribute_name` and value `x`
// fulfills `x ∈ compared_to ± tolerance`.
message Equal {
    // The value to compare to.
    //
    // Default: 0.0
    float compared_to = 1;
    // The tolerance around this value that is acceptable.
    //
    // Default: 0.0
    float tolerance = 2;
}

// Tests if an insertion's property with key `attribute_name` and value `x`
// fulfills `x == raw`.
message StringEquality {
    // The value to compare the insertion's property against.
    //
    // Default: none (if no comparison string is set the containing rule will
    // be dropped)
    oneof value {
        string raw = 1;
    }
}

// Tests if an an insertion's attribute of name `attribute_name` and value `x`
// fulfills `x > compared_to` (if `or_equal = false`) or `x ≥ compared_to` (if
// `or_equal = true`).
message GreaterThan {
    // The value to compare to.
    //
    // Default: 0.0
    float compared_to = 1;
    // Whether equality can hold (in case of `true`) or if the propery has to
    // be stricter greater than `compared_to`.
    //
    // Default: false
    bool or_equal = 2;
}

// Tests if an an insertion's attribute of name `attribute_name` and value `x`
// fulfills `x < compared_to` (if `or_equal = false`) or `x ≤ compared_to` (if
// `or_equal = true`).
message LessThan {
    // The value to compare to.
    //
    // Default: 0.0
    float compared_to = 1;
    // Whether equality can hold (in case of `true`) or if the propery has to
    // be stricter less than `compared_to`.
    //
    // Default: false
    bool or_equal = 2;
}

// Tests if an an insertion's attribute of name `attribute_name` and value `x`
// fulfills `x ∈ (lower_bound, upper_bound)` (open interval). The interval can
// be closed or half-closed by setting either or both of `lower_inclusive` and
// `upper_inclusive` to `true`.
message Interval {
    // The upper bound of the interval
    //
    // Default: 0.0
    float upper_bound = 1;
    // The lower bound of the interval
    //
    // Default: 0.0
    float lower_bound = 2;
    // Whether the lower bound is considered closed (if the compared property can
    // be equal to the lower bound).
    //
    // Default: false
    bool lower_inclusive = 3;
    // Whether the upper bound is considered closed (if the compared property can
    // be equal to the upper bound).
    //
    // Default: false
    bool upper_inclusive = 4;
}


// A positive rule selects insertions by their score if they are associated with
// the same attribute that the rule is associated with. They always work in
// conjunction with negative rules and only select among those insertions that
// were not rejected by a negative rule.
// 
// If two or more positive rules are defined and if one seeks to fill a position
// `p`, then one positive rule is picked by random out of all positive rules. The
// process for picking a positive rule works in the following way:
// 
// 1. all positive rules are removed that won't ever apply to any still available
//    insertions (meaning insertions that evaluate to `true` under the evaluation
//    method of this rule and are not yet allocated); 
// 2. then from the remaining rules those are removed that don't fulfill the
//    condition `rule.min_pos <= p <= rule.max_pos`;
// 3. finally, one is picked by random based on their relative weights
//    `rule.select_pct` using a weighted index.
// 
// After a positive rule has been chosen, blender will then allocate at position
// `p` that insertion with maximum score from those insertions that are selected
// under this rule.
// 
// Note that there is a probability `prob = max(100 - total_sum, 0)` to not select
// any rule if the total sum of relative weights for the rules in 3. is less than
// `100.0`.
message PositiveRule {
  // Value between 0 and 100. The weight of this rule to be selected.
  //
  // If the sum `W` of all weights is less than 100, then the chance N of no
  // weight being chosen is assigned the weight `N = 100 - W`.
  //
  // Examples (given weights `{a, b, ..., z}`, each entry corresponds to a rule
  // with weight `a`, `b`, `c`, etc):
  //
  // + `{100, 100}`: 2 rules with equal weight: 50% chance of each being
  //   selected
  // + `{50, 50}`: as above
  // + `{25, 25}`: each rule has a 25% chance of being selected; there is a 50%
  //   chance of no rule being selected
  // + `{10, 10, 10, 10, 10`}: each of the 5 rules has a 5% chance of being
  //   selected; there is a is a 50% chance of no rule being selected.
  // + `{50, 100}`: 2/3 chance of selecting the rule with weight 100, 1/3
  //   chance to select that of weight 50.
  //
  // NOTE: a value of 0 means this rule will never be selected.
  //
  // Default: `100.0`
  optional double select_pct = 1;
  // The minimum position that this rule applies to. If one seeks to fill a
  // position `p < min_pos`, then this rule will not be considered for
  // selection. `min_pos <= max_pos` must hold.
  //
  // Default: `0`
  optional uint64 min_pos = 2;
  // The maximum position that this rule applies to. If one seeks to fill a
  // position `p > max_pos`, then this rule will not be considered for
  // selection. `max_pos >= min_pos` must hold.
  //
  // Default `uint64::MAX`
  optional uint64 max_pos = 3;
}

// How to rank insertions. This enum is used in `InsertRule`s to specify how
// insertions matched under that rule shall be selected. `QUALITY_SCORE` (the
// default) selects available insertions in order highest score, while
// `REQUEST_ORDER` selects availle insertions in the order they were received.
enum RankingMethod {
    QUALITY_SCORE = 0;
    REQUEST_ORDER = 1;
}

// An insert rule selects insertions by their score if they are associated with
// the same attribute that the rule is associated with.
// 
// If two or more insert rules are defined and if one seeks to fill a position
// `p`, then one insert rule is picked by random out of all insert rules. The
// process for piucking an insert rule works in the following way:
// 
// 1. all insert rules are removed that won't ever apply to any still available
//    insertions (meaning insertions that evaluate to `true` under the
//    evaluation method of this rule and are not yet allocated); 
// 2. then from the remaining rules those are removed that don't fulfill the
//    condition `rule.min_pos <= p <= rule.max_pos`;
// 3. finally, one is picked by random based on their relative weights
//    `rule.select_pct` using a weighted index.
// 
// After an insert rule has been chosen, blender will then allocate at position
// `p` that insertion with maximum score from those insertions that are
// selected under this rule.
// 
// Note that there is a probability `prob = max(100 - total_sum, 0)` to not
// select any rule if the total sum of relative weights for the rules in 3. is
// less than `100.0`.
message InsertRule {
  // Value between 0 and 100. The weight of this rule to be selected.
  //
  // If the sum `W` of all weights is less than 100, then the chance N of no
  // weight being chosen is assigned the weight `N = 100 - W`.
  //
  // Examples (given weights `{a, b, ..., z}`, each entry corresponds to a rule
  // with weight `a`, `b`, `c`, etc):
  //
  // + `{100, 100}`: 2 rules with equal weight: 50% chance of each being
  //   selected
  // + `{50, 50}`: as above
  // + `{25, 25}`: each rule has a 25% chance of being selected; there is a 50%
  //   chance of no rule being selected
  // + `{10, 10, 10, 10, 10`}: each of the 5 rules has a 5% chance of being
  //   selected; there is a is a 50% chance of no rule being selected.
  // + `{50, 100}`: 2/3 chance of selecting the rule with weight 100, 1/3
  //   chance to select that of weight 50.
  //
  // NOTE: a value of 0 means this rule will never be selected.
  //
  // Default: `100.0`
  optional double select_pct = 1;
  // The minimum position that this rule applies to. If one seeks to fill a
  // position `p < min_pos`, then this rule will not be considered for
  // selection. `min_pos <= max_pos` must hold.
  //
  // Default: `0`
  optional uint64 min_pos = 2;
  // The maximum position that this rule applies to. If one seeks to fill a
  // position `p > max_pos`, then this rule will not be considered for
  // selection. `max_pos >= min_pos` must hold.
  //
  // Default: `uint64::MAX` (the maximum possible value for an unsigned 64 bit integer)
  optional uint64 max_pos = 3;
 
  // Whether to ignore `attribute_name` (the field set in the `BlenderRule`
  // message that contains this `InsertRule`). This causes the present
  // `InsertRule` to apply to all insertions that are sent to blender,
  // irrespective of their properties.
  //
  // Default: `false`.
  bool applies_to_all_insertions = 5;

  // How this rule should select insertions for allocation (see `RankingMethod`
  // for more information).
  //
  // Default: RankingMethod::QUALITY_SCORE (sort by quality score by default)
  RankingMethod ranking_method = 6;
}

// A negative rule tests if an insertion must not be selected by positive
// rules.
// 
// A negative rule is associated with an attribute and applies to all those
// insertions that are associated with the same attribute. The applicable
// insertions are tested against the conditions laid out by the negative rule.
// If an insertion is flagged by even one negative rule, it cannot be selected
// by positive rules.they fail one of the conditions, then the item is precluded from being
// selected under the subsequent application of positive rules.
message NegativeRule {
  // Value between 0 and 100. The probability that an item will be failed
  // ("plucked) even if it passes all other conditions.
  //
  // NOTE: a value of 0 means that the item has to fail one of the other
  // conditions to be discarded. A value of 100 means that an item will always
  // be discarded, no matter the other conditions, as as long as it has an
  // attribute matching this rule's.
  //
  // Default: `100.0`
  optional double pluck_pct = 1;
  // The minimum position that items with matching associated attribute can be
  // placed in. Items with the same associated attribute as the negative rule
  // will not be considered for selection if one seeks to fill a position `p <
  // forbid_less_pos`.
  //
  // Default: `0`
  optional uint64 forbid_less_pos = 2;
  // The minimum number of positions between the current position and its
  // precursor. For example, if `min_spacing = 1` and one seeks to fill a
  // position `p`, then an item is discarded if the item at position `p-1` and
  // the item under consideration have the same associated attribute as the
  // current rule (note that attribute values do not have to match; only the
  // fact that they have the same associated attribute matters).
  //
  // Default: `uint64::MAX`
  optional uint64 min_spacing = 3;
  // The maximum position that items with matching associated attribute can be
  // placed in. Items with the same associated attribute as the negative rule
  // will not be considered for selection if one seeks to fill a position `p >
  // forbid_greater_pos`.
  //
  // Default: `uint64::MAX`
  optional uint64 forbid_greater_pos = 4;
  // The maximum number of items that are allowed to be allocated with the same
  // attribute name as this rule. If `max_count` items have already been
  // allocated in previous positions, then no more items with the attribute
  // name can be allocated.
  //
  // Default: `uint64::MAX`
  optional uint64 max_count = 5;
}

// Diversity rules modify the scores of insertions if equivalent insertions have
// been previously allocated.
// 
// The purpose of diversity rules is to penalize or boost equivalent
// insertions. Two insertions `i` and `j` are considered equivalent if they
// have the same property. For example, if we have `i[animal] = dog` and
// `j[animal] = dog`, and if `i` was just allocated, then the score of `j` will
// be modified by `score_j = score_j * multi`.
//
// NOTE: a multiplier `m <= 0.0` means that matched insertions will never be
// allocated again in subsequent steps (because non-positive scores
// disqualify items outright). Multipliers `m < 1.0` act as a penalty.
// Multipliers `m > 1.0` act as a boost, meaning that similar insertions will
// be allocated with a higher likelihood, which might lead to grouping of
// insertions.
message DiversityRule {
  // A factor modifying items' scores. If an item has been allocated at
  // position `p`, then all the allocated item's value of the attribute with
  // matching name is taken. All other items that a) have an attribute that the
  // rule applies to, and b) share the same value as the just allocated item
  // will have their score multiplied by `multi`.
  //
  // Example: if insertion `i` has been allocated at position `p`, then an
  // insertion `j` will have its score modified by `p.score *= multi` if and
  // only if `a[rule.attribute_name] == b[rule.attribute_name]` and if
  // `a[rule.attribute_name] != nil`.
  //
  // NOTE (repeating the above): a multiplier `m <= 0.0` means that matched
  // insertions will never be allocated again in subsequent steps (because
  // non-positive scores disqualify items outright). Multipliers `m < 1.0` act
  // as a penalty. Multipliers `m > 1.0` act as a boost, meaning that similar
  // insertions will be allocated with a higher likelihood, which might lead to
  // grouping of insertions.
  optional double multi = 1;
}

// `QualityScoreConfig` defines how a quality score for each insertion is
// calculated, and by that establishes a ranking of all available insertions.
// If an insertion's quality score is zero or negative, then that insertion
// must not be allocated.
//
// This message allows defining expressions like the one below:
//
// ```
// SCORE_i := TERM_1 + (TERM_2 * TERM_3) + TERM_4
message QualityScoreConfig {
  // A list of quality score terms. The terms of this list are summed.
  //
  // Default: empty (if empty, the optimized promoted.ai default quality score
  // term will be used)
  repeated QualityScoreTerm weighted_sum_term = 1;
}

// `QualityScoreTerms` is a list of quality score terms defining a product of
// terms.
//
// This message exists to work around protobuf not permitting `repeatead`
// inside `oneof` fields.
message QualityScoreTerms {
  // A list of quality score terms. The terms of this list are always
  // multiplied.
  //
  // Default: empty (if empty, the term defined by this list will be dropped)
  repeated QualityScoreTerm quality_score_terms = 1;
}

// `QualityScoreTerm` defines a term in either the root level
// `weighted_sum_term`, or in a product of terms that themselves a quality
// score term.
message QualityScoreTerm {
  // How to fetch the base values of this term vector.
  //
  // If `fetch_method` is `attribute_name`, then this quality score term is
  // a terminal leaf and will evaluate to a value. If `fetch_method` is
  // `product`, then this defines term a subtree.
  //
  // If `fetch_method` is null or if an insertion does not have a property with
  // key `attribute_name`, then this term will be set to `0.0`.
  oneof fetch_method {
    // The name of the insertion property that will supply the final value to
    // be used to calculate the quality score for an insertion.
    string attribute_name = 1;
    // Recursively evaluate terms and multiply their evaluations as a product.
    QualityScoreTerms product = 3;
  }
  reserved 4 to 9; // Reserving fields for future fetch_method options.
  // The upper bound used to clamp the value supplied by an insertion's
  // property (before weight and offset).
  //
  // Default: float::MAX (The maximum value of a single precision 32 bit float)
  optional float fetch_high = 10;
  // The lower bound used to clamp the value supplied by an insertion's
  // property (before weight and offset).
  //
  // Default: float::MIN (The minimum value of a single precision 32 bit float)
  optional float fetch_low = 11;
  // The weight of the value supplied by an insertion's property. This constant
  // multiplies the value before it enters into the sum or product of
  // terms.
  //
  // Default: 1.0 (no multiply).
  optional float weight = 12;
  // An offset added to the value supplied by an insertion's property. This constant
  // is added to the value (after it's modified by the weight) before it enters into
  // the sum or product of terms.
  //
  // Default: 0.0 (no offset)
  float offset = 13;
  // The value that this term evaluates to if the provided eval method
  // evaluates to false. This field is used to conditionally set or unset
  // terms from the sum of terms.
  //
  // For example, this field allows to construct ternary operators to define
  // scores like so ( where `i` is some insertion, and `IMPORTANT`,
  // `p_NAVIGATE`, and `p_POST_CLICK_CONVERSION` are terms and insertion
  // properties):
  //
  // ```
  // score_i := i[IMPORTANT] + i[IMPORTANT] : 0 ? 1 * i[p_NAVIGATE] * i[p_POST_CLICK_CONVERSION]
  // ```
  //
  // This sets `score_i` to the value of the `IMPORTANT` property or, if it
  // evaluates to `false` the product `p_NAVIGATE * p_POST_CLICK_CONVERSION`.
  //
  // Default: none (ignored)
  optional TermConditionalEvaluation term_conditional_evaluation = 14;
}

// If `TermConditionalEvaluation` is specified, then the `eval_method` applied
// to an insertion must evaluate to `true`. If `false`, the quality term that
// contains this `TermConditionalEvaluation` will be set/evaluate to
// `value_if_false`.
message TermConditionalEvaluation {
  // The value the contained term will be set to if the evaluation yields `false`.
  //
  // Default: 0.0
  float value_if_false = 1;
  // The property with key `attribute_name` that will be used for `eval_method`.
  //
  // Default: "" (if the attribute name is not set, then this conditional eval
  // will be ignored because it can't be applied to any property).
  string attribute_name = 2;
  // How to evaluate an insertion to determine if this conditional eval changes
  // the quality term it is contained in.
  //
  // If the result of an evaluation is `true`, then the containing quality term
  // is not affected. if `false`, the containing quality term is set to
  // `value_if_false`.
  //
  // If an insertion lacks a matching attribute, it will always evaluate to `false`.
  //
  // See the respective eval method entries for more information.
  //
  // Default: flag (if `eval_method` is not set, this rule will fall back to
  // boolean evaluation and check if a the property with key `attribute_name` is
  // `true`)
  oneof eval_method {
    Flag flag = 4;
    GreaterThan greater_than = 6;
    LessThan less_than = 7;
    Interval interval = 8;
    EqualV2 equal_v2 = 10;
  }
}
