syntax = "proto3";
package delivery;

option java_multiple_files = true;
option java_package = "ai.promoted.proto.delivery";
option java_outer_classname = "Blender";
option go_package = "github.com/promotedai/schema/generated/go/proto/delivery";
option csharp_namespace = "Promoted.Delivery";

// Lookups behave like a COALESCE in SQL. Lookups are performed in order until
// one succeeds. If they all fail, the default value is produced.
//
// If no lookups are specified, a variable name is checked for. There is no
// coalescing here; a variable must exist.
//
// A leaf with constant value can be represented by a default with no lookups
// or variable name.
//
// Next ID = 4.
message LeafExpression {
  repeated Lookup lookups = 1;
  float default = 2;
  string variable_name = 3;
}

// This represents a lookup into data structures outside of the syntax tree
// (e.g. a feature map).
//
// Next ID = 3.
message Lookup {
  oneof lookup_type {
    uint64 feature_id = 1;
    uint64 parameter_key = 2;
  }
}

// Wrapper messages to include a repeated inside a oneof.
message BlenderBoolValues { repeated bool values = 1; }
message BlenderInt32Values { repeated int32 values = 1; }
message BlenderFloatValues { repeated float values = 1; }
message BlenderStringValues { repeated string values = 1; }

// How an assignment statement evaluated.
//
// Next ID = 6.
message BlenderVariableLog {
  string name = 1;
  // Ordering corresponds to `ids` in the session log.
  // TODO(james): Deprecate and reserve.
  repeated float values = 2;

  // If true, then the following repeated should have a length of 1 and the
  // value can be used for all `ids`.
  bool is_scalar = 3;
  // Ordering of repeated in sub-messages corresponds to `ids` in the session
  // log.
  oneof typed_values {
    BlenderBoolValues bool_values = 4;
    BlenderInt32Values int32_values = 5;
    BlenderFloatValues float_values = 6;
    BlenderStringValues string_values = 7;
  }
};

// How an allocation statement evaluated.
//
// Next ID = 5.
message BlenderAllocationLog {
  // These indexes correspond to elements of `ids` in the session log.
  repeated int32 indexes = 1;
  // The name of the rule corresponding to this statement.
  string name = 2;
  // Positions which this rule tried to fill.
  repeated int32 positions_considered = 3;
  // Positions which were successfully filled.
  repeated int32 positions_filled = 4;
};

// A Blender config, input IDs, and how statements evaluated. Inputs only have
// their IDs included to not duplicate the feature maps.
//
// Next ID = 6.
message BlenderSessionLog {
  // This is the config, but split by statement to simplify downstream
  // processing.
  repeated string config_statements = 1;
  // Feature IDs which appear in the config.
  repeated uint64 relevant_feature_ids = 5;

  // Order corresponds to the order of inputs across the session. The same
  // ordering is used for the entire session.
  repeated string ids = 2;
  // Order corresponds to the order of assignment statements in the config.
  repeated BlenderVariableLog variable_logs = 3;
  // Order corresponds to the order of allocation statements in the config.
  repeated BlenderAllocationLog allocation_logs = 4;
}

// This is only capable of exploring values in simple ways. More complex logic
// description (e.g. conditionals) is left to Blender.
//
// Next ID = 2.
message HyperloopConfig {
  // Parameter keys in Blender correspond to this map.
  map<uint64, HyperloopParameter> parameters = 1;
}

// A parameter is effectively an experiment. Invalid parameter descriptions are
// skipped.
//
// Next ID = 3.
message HyperloopParameter {
  // Each parameter has 1000 buckets, shared among the groups. A parameter is
  // considered invalid if:
  // - Groups have overlapping bucket ranges
  // - Any bucket range starts below 0 or ends above 1000
  repeated HyperloopGroup groups = 1;
  // Any buckets which are not claimed by a group produce this value.
  float default = 2;
}

// A group is a bucket range and method of value generation.
//
// Next ID = 4.
message HyperloopGroup {
  // [low_bucket, high_bucket]
  int32 low_bucket = 1;
  int32 high_bucket = 2;
  HyperloopExpression exp = 3;
}

// See the comment for BlenderExpression.
//
// Next ID = 4.
message HyperloopExpression {
  oneof node_type {
    LeafExpression leaf = 1;
    HyperloopGeneratorExpression generator_exp = 2;
    HyperloopConditionalExpression conditional_exp = 3;
  }
}

// This is distinct from leaf in case we ever want to do generation based on
// other expressions.
//
// Next ID = 3.
message HyperloopGeneratorExpression {
  oneof generator {
    HyperloopUniformGenerator uniform = 1;
    HyperloopUniformMultiGenerator uniform_multi = 2;
  }
}

// Generates a value from a uniform distribution.
//
// Next ID = 3.
message HyperloopUniformGenerator {
  // [low_bound, high_bound]
  float low_bound = 1;
  float high_bound = 2;
}

// Uses a uniform distribution to choose a multiplier, but not to actually
// generate the final value. The final value is bounded by (base / multi, base *
// multi). There's a 50/50 chance whether multiplication or division is done.
//
// Next ID = 3.
message HyperloopUniformMultiGenerator {
  float base = 1;
  // A multi of <= 1 is invalid.
  float multi = 2;
}

// This represents if(-else) branches in processing. For a single execution of
// the expression:
// - Both sides of the predicate are computed
// - Only one of the branches is computed
//
// Conjunction/disjunctions (i.e. AND/OR) can be formed by nesting conditionals.
//
// Next ID = 6.
message HyperloopConditionalExpression {
  enum Operator {
    UNKNOWN = 0;
    EQUAL = 1;
    GREATER_THAN = 2;
    GREATER_THAN_OR_EQUAL = 3;
  }
  Operator op = 1;
  HyperloopExpression predicate_lhs = 2;
  HyperloopExpression predicate_rhs = 3;
  HyperloopExpression then_branch = 4;
  HyperloopExpression else_branch = 5;
}

// These correspond to the above Hyperloop messages, but group assignment and
// values have been realized.
//
// Next ID = 2.
message HyperloopLog { map<uint64, HyperloopParameterLog> parameter_logs = 1; }

// Next ID = 3.
message HyperloopParameterLog {
  int32 bucket = 1;
  float value = 2;
}
