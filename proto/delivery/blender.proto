syntax = "proto3";
package delivery;

option java_multiple_files = true;
option java_package = "ai.promoted.proto.delivery";
option java_outer_classname = "Blender";
option go_package = "github.com/promotedai/schema/generated/go/proto/delivery";

// See: https://github.com/promotedai/blender for README
// Next ID = 17.
message BlenderRule {
  // The name of item attribute that this rule applies to. It may be a JSON key path.
  string attribute_name = 1;
  reserved 10;
  reserved 2 to 5; // Reserving fields for future common fields.
  oneof rule {
    PositiveRule positive_rule = 6;
    InsertRule insert_rule = 7;
    NegativeRule negative_rule = 8;
    DiversityRule diversity_rule = 9;
  }

  // If eval_method is not set, falls back to boolean evaluation (described below).
  oneof eval_method {
    Boolean boolean = 11;
    Equal equal = 12 [deprecated = true];
    GreaterThan greater_than = 13;
    LessThan less_than = 14;
    Interval interval = 15;
    EqualV2 equal_v2 = 16;
  }
}

// Tests if an insertion has an attribute of name `attribute_name` and if its value is not falsy.
// If the insertion lacks the attribute, this evaluates to `false`. If it does contain the
// attribute but is `nil`, `false`, the empty string `""`, zero `0.0`, the empty list `[]`, etc
// then it also evaluates to `false`.  If the attribute value can be considered truthy, then this
// evaluates to `true`.
//
// Next ID = 1;
message Boolean {}

// Tests if a number or string is equal to some predefined value.
// Default: none; if neither `number` nor `string` are set then the containing context will be
// dropped (for example, a rule will be discarded because it cannot be evaluated).
// Next ID = 3
message EqualV2 {
    oneof equality_type {
        Equal number = 1;
        StringEquality string = 2;
    }
}

// Tests if an an insertion's attribute of name `attribute_name` and value `x`
// fulfills `x ∈ compared_to ± tolerance`. Evaluates to `false` if the insertion lacks the
// attribute or the attribute does not contain a numeric value.
// Next ID = 3;
message Equal {
    float compared_to = 1;
    float tolerance = 2;
}

// Tests if a string is equal to the defined value.
// Next ID = 3;
message StringEquality {
    oneof value {
        string raw = 1;
    }
}

// Tests if an an insertion's attribute of name `attribute_name` and value `x`
// fulfills `x > compared_to` (if `or_equal = false`) or `x ≥ compared_to` (if `or_equal = true`).
// Evaluates to `false` if the insertion lacks the attribute or the attribute
// does not contain a numeric value.
// Next ID = 3
message GreaterThan {
    float compared_to = 1;
    bool or_equal = 2;
}

// Tests if an an insertion's attribute of name `attribute_name` and value `x`
// fulfills `x < compared_to` (if `or_equal = false`) or `x ≤ compared_to` (if `or_equal = true`).
// Evaluates to `false` if the insertion lacks the attribute or the attribute
// does not contain a numeric value.
// Next ID = 3
message LessThan {
    float compared_to = 1;
    bool or_equal = 2;
}

// Tests if an an insertion's attribute of name `attribute_name` and value `x`
// fulfills `x ∈ (lower_bound, upper_bound)` (open interval). The interval can be closed or
// half-closed by setting either or both of `lower_inclusive` and `upper_inclusive` to `true`.
// Evaluates to `false` if the insertion lacks the attribute or the attribute
// does not contain a numeric value.
// Next ID = 5
message Interval {
    float upper_bound = 1;
    float lower_bound = 2;
    bool lower_inclusive = 3;
    bool upper_inclusive = 4;
}

message SparseIdMatch {
    string str = 1;
}

// A positive rule selects insertions by their score if they are associated with the same attribute
// that the rule is associated with.
//
// If one seeks to fill a position `p` with an insertion, then one positive rule is selected by
// random out of all positive rules. The selection process works in the following way:
//
// 1. positive rules are filtered by whether for a given rule there exist any insertions that could
//    potentially be selected (meaning there are insertions that are not yet associated with a
//    different position, that are associated with the same attribute as a given rule, and that
//    have not been filtered out by negative rules [see the comment on negative rules for that]);
// 2. the rules remaining after 1. are filtered for the condition
//    `rule.min_pos <= p <= rule.max_pos`;
// 3. from the rules remaining after 2. one is selected by random based on their weight in
//    `rule.select_pct`.
//
// After a positive rule has been selected, the insertion of the highest score is associated with
// position `p` (if, remembering point 1., that insertion is available to be allocated, has the
// same associated attribute as the selected rule, and is not ruled out by application of negative
// rules).
//
// Note that there is a chance of no rule (and hence no insertion) being selected if the sum of all
// rules selected in step 3. is less than 100.0. The probability of that happening is `100 - sum`.
//
// Positive rules are similar to insert rules, but used in a different context. While items can be
// selected just based on insert rules, positive rules are used in tandem with negative rules.
// First, negative rules are tested to filter out items. Afterwards, a positive rule is used to
// select items just like an insert rule (just without the filtered out items).
//
// Next ID = 4.
message PositiveRule {
  // Value between 0 and 100. The weight of this rule to be selected.
  //
  // If the sum `W` of all weights is less than 100, then the chance N of no weight being chosen is
  // assigned the weight `N = 100 - W`.
  //
  // Examples (given weights `{a, b, ..., z}`, each entry corresponds to a rule with weight `a`,
  // `b`, `c`, etc):
  // + `{100, 100}`: 2 rules with equal weight: 50% chance of each being selected
  // + `{50, 50}`: as above
  // + `{25, 25}`: each rule has a 25% chance of being selected; there is a 50% chance of no rule
  //    being selected
  // + `{10, 10, 10, 10, 10`}: each of the 5 rules has a 5% chance of being selected; there is a
  //   is a 50% chance of no rule being selected.
  // + `{50, 100}`: 2/3 chance of selecting the rule with weight 100, 1/3 chance to select that of
  //   weight 50.
  //
  // NOTE: a value of 0 means this rule will never be selected.
  //
  // Default: `100.0`
  optional double select_pct = 1;
  // The minimum position that this rule applies to. If one seeks to fill a position `p < min_pos`,
  // then this rule will not be considered for selection. `min_pos <= max_pos` must hold.
  //
  // Default: `0`
  optional uint64 min_pos = 2;
  // The maximum position that this rule applies to. If one seeks to fill a position `p > max_pos`,
  // then this rule will not be considered for selection. `max_pos >= min_pos` must hold.
  //
  // Default `uint64::MAX`
  optional uint64 max_pos = 3;
}

// How to rank insertions. This enum is used in `InsertRule`s to specify how
// insertions matched under that rule shall be selected. `QUALITY_SCORE` (the
// default) selects available insertions in order highest score, while
// `REQUEST_ORDER` selects availle insertions in the order they were received.
enum RankingMethod {
    QUALITY_SCORE = 0;
    REQUEST_ORDER = 1;
}

// An insert rule selects insertions by their score if they are associated with the same attribute
// that the rule is associated with.
//
// If one seeks to fill a position `p` with an insertion, then one insert rule is selected by
// random out of all insert rules. The selection process works in the following way:
//
// 1. insert rules are filtered by whether for a given rule there exist any insertions that could
//    potentially be selected (meaning there are insertions that are not yet associated with a
//    different position, and that are associated with the same attribute as a given rule);
// 2. the rules remaining after 1. are filtered for the condition
//    `rule.min_pos <= p <= rule.max_pos`;
// 3. from the rules remaining after 2. one is selected by random based on their weight in
//    `rule.select_pct`.
//
// After an insert rule has been selected, the insertion of the highest score is associated with
// position `p` (if, remembering point 1., that insertion is available to be allocated, and has the
// same associated attribute as the selected rule).
//
// Note that there is a chance of no rule (and hence no insertion) being selected if the sum of all
// rules selected in step 3. is less than 100.0. The probability of that happening is `100 - sum`.
// 
// Next ID = 7.
message InsertRule {
  // Value between 0 and 100. The weight of this rule to be selected.
  //
  // If the sum `W` of all weights is less than 100, then the chance N of no weight being chosen is
  // assigned the weight `N = 100 - W`.
  //
  // Examples (given weights `{a, b, ..., z}`, each entry corresponds to a rule with weight `a`,
  // `b`, `c`, etc):
  // + `{100, 100}`: 2 rules with equal weight: 50% chance of each being selected
  // + `{50, 50}`: as above
  // + `{25, 25}`: each rule has a 25% chance of being selected; there is a 50% chance of no rule
  //    being selected
  // + `{10, 10, 10, 10, 10`}: each of the 5 rules has a 5% chance of being selected; there is a
  //   is a 50% chance of no rule being selected.
  // + `{50, 100}`: 2/3 chance of selecting the rule with weight 100, 1/3 chance to select that of
  //   weight 50.
  //
  // NOTE: a value of 0 means this rule will never be selected.
  //
  // Default: `100.0`
  optional double select_pct = 1;
  // The minimum position that this rule applies to. If one seeks to fill a position `p < min_pos`,
  // then this rule will not be considered for selection. `min_pos <= max_pos` must hold.
  //
  // Default: `0`
  optional uint64 min_pos = 2;
  // The maximum position that this rule applies to. If one seeks to fill a position `p > max_pos`,
  // then this rule will not be considered for selection. `max_pos >= min_pos` must hold.
  //
  // Default `uint64::MAX`
  optional uint64 max_pos = 3;
  // The priority of this rule. When picking an insert rule to allocate an
  // insertion to a position, blender will first select from rules of highest
  // priority. A larger value implies higher priority, and a value of `0` is
  // considered lowest priority. If two or more rules have the same priority,
  // then one rule will be randomly picked from the set of same-priority rules
  // and based on their relative weight (= `select_pct`). Blender will move on
  // the the next-highest priority only if no more insertions can be selected
  // under the current priority level (this happens if for the current set of
  // rules all available insertions evaluate to `false` under their respective
  // evaluation methods).
  //
  // Default: `0` (lowest priority)
  uint32 priority = 4;
 
  // Causes this rule to ignore the value of `attribute_name` in this insert
  // rule's `BlenderRule` wrapper, causing this `InsertRule` to apply to all
  // insertions that are sent to blender.
  // Default: `false`.
  bool applies_to_all_insertions = 5;

  // How this rule should select insertions for allocation (see `RankingMethod`
  // for more information).
  // Default: QUALITY_SCORE
  RankingMethod ranking_method = 6;
}

// A negative rule tests if a given insertion may not be selected under application of positive
// rules (see the description of positive rules to undertand that process).
// 
// A negative rule is associated with an attribute and applies to all those insertions that are
// associated with the same attribute. The applicable insertions are tested against the conditions
// laid out by the negative rule. If they fail one of the conditions, then the item is precluded
// from being selected under the subsequent application of positive rules.
//
// Next ID = 6.
message NegativeRule {
  // Value between 0 and 100. The probability that an item will be failed ("plucked) even if it
  // passes all other conditions.
  //
  // NOTE: a value of 0 means that the item has to fail one of the other conditions to be discarded.
  // A value of 100 means that an item will always be discarded, no matter the other conditions, as
  // as long as it has an attribute matching this rule's.
  //
  // Default: `100.0`
  optional double pluck_pct = 1;
  // The minimum position that items with matching associated attribute can be placed in. Items
  // with the same associated attribute as the negative rule will not be considered for selection
  // if one seeks to fill a position `p < forbid_less_pos`.
  //
  // Default: `0`
  optional uint64 forbid_less_pos = 2;
  // The minimum number of positions between the current position and its precursor. For example,
  // if `min_spacing = 1` and one seeks to fill a position `p`, then an item is discarded if the
  // item at position `p-1` and the item under consideration have the same associated attribute as
  // the current rule (note that attribute values do not have to match; only the fact that they
  // have the same associated attribute matters).
  //
  // Default: `uint64::MAX`
  optional uint64 min_spacing = 3;
  // The maximum position that items with matching associated attribute can be placed in. Items
  // with the same associated attribute as the negative rule will not be considered for selection
  // if one seeks to fill a position `p > forbid_greater_pos`.
  //
  // Default: `uint64::MAX`
  optional uint64 forbid_greater_pos = 4;
  // The maximum number of items that are allowed to be allocated with the same attribute name as
  // this rule. If `max_count` items have already been allocated in previous positions, then no
  // more items with the attribute name can be allocated.
  //
  // Default: `uint64::MAX`
  optional uint64 max_count = 5;
}

// Diversity rules modify the scores of insertions if equivalent insertions have been previously
// allocated.
//
// The purpose of diversity rules is to penalize equivalent insertions. Two insertions `i` and `j`
// are considered equivalent if they are associated with the same attribute as the rule, and if
// the value of said attribute is the same, i.e. the condition `i[attr] == j[attr]` and
// `i[attr] != nil`.
// Next ID = 2.
message DiversityRule {
  // A factor modifying items' scores. If an item has been allocated at position `p`, then all the
  // allocated item's value of the attribute with matching name is taken. All other items that a)
  // have an attribute that the rule applies to, and b) share the same value as the just allocated
  // item will have their score multiplied by `multi`.
  //
  // Example: if insertion `i` has been allocated at position `p`, then an insertion `j` will have
  // its score modified by `p.score *= multi` if and only if
  // `a[rule.attribute_name] == b[rule.attribute_name]` and if `a[rule.attribute_name] != nil`.
  //
  // NOTE: a multiplier `m <= 0.0` means that modified items will never be allocated again (because
  // non-positive scores disqualify items outright). Multipliers of `m > 1.0` act as as a boost.
  // To act as a penalty, it should be set `0.0 > m < 1.0`, but this is currently not enforced.
  optional double multi = 1;
}

// Next ID = 3.
message BlenderConfig {
  // List of blender rules.
  repeated BlenderRule blender_rule = 1;
  QualityScoreConfig quality_score_config = 2;
}

// See: https://github.com/promotedai/qualityscore
// Next ID = 2.
message QualityScoreConfig {
    // A list of quality score terms. These are always summed.
  repeated QualityScoreTerm weighted_sum_term = 1;
}

// Next ID = 2.
message QualityScoreTerms {
  // A list of quality score terms. These are always multiplied.
  repeated QualityScoreTerm quality_score_terms = 1;
}

// Next ID = 15.
message QualityScoreTerm {
  // How to fetch the base values of this term vector.
  //
  // If `fetch_method` is null, `attribute_name`, or `hashed_attribute` and the
  // value cannot be retrieved from an insertion's sparse map, then this term
  // will be set to `0.0`. Note: this will cause the product that this term is
  // a part of to evaluate to 0.0.
  oneof fetch_method {
    // A named vector provided from elsewhere.
    string attribute_name = 1;
    // Recursively evaluate terms and multiply their evaluations as a product.
    QualityScoreTerms product = 3;
  }
  reserved 4 to 9; // Reserving fields for future fetch_method options.
  // Maximum limit of underlying value (before weight and offset).
  optional float fetch_high = 10;
  // Minimum limit of underlying value (before weight and offset).
  optional float fetch_low = 11;
  // Multiply by this value.
  // Default: 1.0 (no multiply).
  optional float weight = 12;
  // Add a constant to this term (after applying the weight).
  // Default: 0
  float offset = 13;
  // The value that this term evaluates to if the provided eval method evaluates to false.
  // Default: ignored
  optional TermConditionalEvaluation term_conditional_evaluation = 14;
}

// If specified, then the condition must evaluate to True. Otherwise, this
// term evaluates to "value"
// Use to define terms specific to different item types with different
// Features. For example: video vs images.
// Next Id 12;
message TermConditionalEvaluation {
  float value_if_false = 1;
  string attribute_name = 2;
  uint64 hashed_attribute = 3;
  oneof eval_method {
    Boolean boolean = 4;
    Equal equal = 5;
    GreaterThan greater_than = 6;
    LessThan less_than = 7;
    Interval interval = 8;
    SparseIdMatch sparse_id_match = 9;
  }
}
