// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/delivery/blender.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_2fdelivery_2fblender_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_proto_2fdelivery_2fblender_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3015000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3015003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proto_2fdelivery_2fblender_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2fdelivery_2fblender_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[19]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_proto_2fdelivery_2fblender_2eproto;
::PROTOBUF_NAMESPACE_ID::Metadata descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(int index);
namespace delivery {
class BlenderArithmeticExpression;
struct BlenderArithmeticExpressionDefaultTypeInternal;
extern BlenderArithmeticExpressionDefaultTypeInternal _BlenderArithmeticExpression_default_instance_;
class BlenderConditionalExpression;
struct BlenderConditionalExpressionDefaultTypeInternal;
extern BlenderConditionalExpressionDefaultTypeInternal _BlenderConditionalExpression_default_instance_;
class BlenderConfig;
struct BlenderConfigDefaultTypeInternal;
extern BlenderConfigDefaultTypeInternal _BlenderConfig_default_instance_;
class BlenderExpression;
struct BlenderExpressionDefaultTypeInternal;
extern BlenderExpressionDefaultTypeInternal _BlenderExpression_default_instance_;
class BlenderSortKey;
struct BlenderSortKeyDefaultTypeInternal;
extern BlenderSortKeyDefaultTypeInternal _BlenderSortKey_default_instance_;
class HyperloopConditionalExpression;
struct HyperloopConditionalExpressionDefaultTypeInternal;
extern HyperloopConditionalExpressionDefaultTypeInternal _HyperloopConditionalExpression_default_instance_;
class HyperloopConfig;
struct HyperloopConfigDefaultTypeInternal;
extern HyperloopConfigDefaultTypeInternal _HyperloopConfig_default_instance_;
class HyperloopConfig_ParametersEntry_DoNotUse;
struct HyperloopConfig_ParametersEntry_DoNotUseDefaultTypeInternal;
extern HyperloopConfig_ParametersEntry_DoNotUseDefaultTypeInternal _HyperloopConfig_ParametersEntry_DoNotUse_default_instance_;
class HyperloopExpression;
struct HyperloopExpressionDefaultTypeInternal;
extern HyperloopExpressionDefaultTypeInternal _HyperloopExpression_default_instance_;
class HyperloopGeneratorExpression;
struct HyperloopGeneratorExpressionDefaultTypeInternal;
extern HyperloopGeneratorExpressionDefaultTypeInternal _HyperloopGeneratorExpression_default_instance_;
class HyperloopGroup;
struct HyperloopGroupDefaultTypeInternal;
extern HyperloopGroupDefaultTypeInternal _HyperloopGroup_default_instance_;
class HyperloopLog;
struct HyperloopLogDefaultTypeInternal;
extern HyperloopLogDefaultTypeInternal _HyperloopLog_default_instance_;
class HyperloopLog_ParameterLogsEntry_DoNotUse;
struct HyperloopLog_ParameterLogsEntry_DoNotUseDefaultTypeInternal;
extern HyperloopLog_ParameterLogsEntry_DoNotUseDefaultTypeInternal _HyperloopLog_ParameterLogsEntry_DoNotUse_default_instance_;
class HyperloopParameter;
struct HyperloopParameterDefaultTypeInternal;
extern HyperloopParameterDefaultTypeInternal _HyperloopParameter_default_instance_;
class HyperloopParameterLog;
struct HyperloopParameterLogDefaultTypeInternal;
extern HyperloopParameterLogDefaultTypeInternal _HyperloopParameterLog_default_instance_;
class HyperloopUniformGenerator;
struct HyperloopUniformGeneratorDefaultTypeInternal;
extern HyperloopUniformGeneratorDefaultTypeInternal _HyperloopUniformGenerator_default_instance_;
class HyperloopUniformMultiGenerator;
struct HyperloopUniformMultiGeneratorDefaultTypeInternal;
extern HyperloopUniformMultiGeneratorDefaultTypeInternal _HyperloopUniformMultiGenerator_default_instance_;
class LeafExpression;
struct LeafExpressionDefaultTypeInternal;
extern LeafExpressionDefaultTypeInternal _LeafExpression_default_instance_;
class Lookup;
struct LookupDefaultTypeInternal;
extern LookupDefaultTypeInternal _Lookup_default_instance_;
}  // namespace delivery
PROTOBUF_NAMESPACE_OPEN
template<> ::delivery::BlenderArithmeticExpression* Arena::CreateMaybeMessage<::delivery::BlenderArithmeticExpression>(Arena*);
template<> ::delivery::BlenderConditionalExpression* Arena::CreateMaybeMessage<::delivery::BlenderConditionalExpression>(Arena*);
template<> ::delivery::BlenderConfig* Arena::CreateMaybeMessage<::delivery::BlenderConfig>(Arena*);
template<> ::delivery::BlenderExpression* Arena::CreateMaybeMessage<::delivery::BlenderExpression>(Arena*);
template<> ::delivery::BlenderSortKey* Arena::CreateMaybeMessage<::delivery::BlenderSortKey>(Arena*);
template<> ::delivery::HyperloopConditionalExpression* Arena::CreateMaybeMessage<::delivery::HyperloopConditionalExpression>(Arena*);
template<> ::delivery::HyperloopConfig* Arena::CreateMaybeMessage<::delivery::HyperloopConfig>(Arena*);
template<> ::delivery::HyperloopConfig_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::delivery::HyperloopConfig_ParametersEntry_DoNotUse>(Arena*);
template<> ::delivery::HyperloopExpression* Arena::CreateMaybeMessage<::delivery::HyperloopExpression>(Arena*);
template<> ::delivery::HyperloopGeneratorExpression* Arena::CreateMaybeMessage<::delivery::HyperloopGeneratorExpression>(Arena*);
template<> ::delivery::HyperloopGroup* Arena::CreateMaybeMessage<::delivery::HyperloopGroup>(Arena*);
template<> ::delivery::HyperloopLog* Arena::CreateMaybeMessage<::delivery::HyperloopLog>(Arena*);
template<> ::delivery::HyperloopLog_ParameterLogsEntry_DoNotUse* Arena::CreateMaybeMessage<::delivery::HyperloopLog_ParameterLogsEntry_DoNotUse>(Arena*);
template<> ::delivery::HyperloopParameter* Arena::CreateMaybeMessage<::delivery::HyperloopParameter>(Arena*);
template<> ::delivery::HyperloopParameterLog* Arena::CreateMaybeMessage<::delivery::HyperloopParameterLog>(Arena*);
template<> ::delivery::HyperloopUniformGenerator* Arena::CreateMaybeMessage<::delivery::HyperloopUniformGenerator>(Arena*);
template<> ::delivery::HyperloopUniformMultiGenerator* Arena::CreateMaybeMessage<::delivery::HyperloopUniformMultiGenerator>(Arena*);
template<> ::delivery::LeafExpression* Arena::CreateMaybeMessage<::delivery::LeafExpression>(Arena*);
template<> ::delivery::Lookup* Arena::CreateMaybeMessage<::delivery::Lookup>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace delivery {

enum BlenderArithmeticExpression_Operator : int {
  BlenderArithmeticExpression_Operator_UNKNOWN = 0,
  BlenderArithmeticExpression_Operator_ADD = 1,
  BlenderArithmeticExpression_Operator_MULTIPLY = 2,
  BlenderArithmeticExpression_Operator_SUBTRACT = 3,
  BlenderArithmeticExpression_Operator_DIVIDE = 4,
  BlenderArithmeticExpression_Operator_MIN = 5,
  BlenderArithmeticExpression_Operator_MAX = 6,
  BlenderArithmeticExpression_Operator_FLOOR = 7,
  BlenderArithmeticExpression_Operator_CEILING = 8,
  BlenderArithmeticExpression_Operator_BlenderArithmeticExpression_Operator_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BlenderArithmeticExpression_Operator_BlenderArithmeticExpression_Operator_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BlenderArithmeticExpression_Operator_IsValid(int value);
constexpr BlenderArithmeticExpression_Operator BlenderArithmeticExpression_Operator_Operator_MIN = BlenderArithmeticExpression_Operator_UNKNOWN;
constexpr BlenderArithmeticExpression_Operator BlenderArithmeticExpression_Operator_Operator_MAX = BlenderArithmeticExpression_Operator_CEILING;
constexpr int BlenderArithmeticExpression_Operator_Operator_ARRAYSIZE = BlenderArithmeticExpression_Operator_Operator_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BlenderArithmeticExpression_Operator_descriptor();
template<typename T>
inline const std::string& BlenderArithmeticExpression_Operator_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BlenderArithmeticExpression_Operator>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BlenderArithmeticExpression_Operator_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BlenderArithmeticExpression_Operator_descriptor(), enum_t_value);
}
inline bool BlenderArithmeticExpression_Operator_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BlenderArithmeticExpression_Operator* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BlenderArithmeticExpression_Operator>(
    BlenderArithmeticExpression_Operator_descriptor(), name, value);
}
enum BlenderConditionalExpression_Operator : int {
  BlenderConditionalExpression_Operator_UNKNOWN = 0,
  BlenderConditionalExpression_Operator_EQUAL = 1,
  BlenderConditionalExpression_Operator_GREATER_THAN = 2,
  BlenderConditionalExpression_Operator_GREATER_THAN_OR_EQUAL = 3,
  BlenderConditionalExpression_Operator_BlenderConditionalExpression_Operator_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BlenderConditionalExpression_Operator_BlenderConditionalExpression_Operator_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BlenderConditionalExpression_Operator_IsValid(int value);
constexpr BlenderConditionalExpression_Operator BlenderConditionalExpression_Operator_Operator_MIN = BlenderConditionalExpression_Operator_UNKNOWN;
constexpr BlenderConditionalExpression_Operator BlenderConditionalExpression_Operator_Operator_MAX = BlenderConditionalExpression_Operator_GREATER_THAN_OR_EQUAL;
constexpr int BlenderConditionalExpression_Operator_Operator_ARRAYSIZE = BlenderConditionalExpression_Operator_Operator_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BlenderConditionalExpression_Operator_descriptor();
template<typename T>
inline const std::string& BlenderConditionalExpression_Operator_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BlenderConditionalExpression_Operator>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BlenderConditionalExpression_Operator_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BlenderConditionalExpression_Operator_descriptor(), enum_t_value);
}
inline bool BlenderConditionalExpression_Operator_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BlenderConditionalExpression_Operator* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BlenderConditionalExpression_Operator>(
    BlenderConditionalExpression_Operator_descriptor(), name, value);
}
enum HyperloopConditionalExpression_Operator : int {
  HyperloopConditionalExpression_Operator_UNKNOWN = 0,
  HyperloopConditionalExpression_Operator_EQUAL = 1,
  HyperloopConditionalExpression_Operator_GREATER_THAN = 2,
  HyperloopConditionalExpression_Operator_GREATER_THAN_OR_EQUAL = 3,
  HyperloopConditionalExpression_Operator_HyperloopConditionalExpression_Operator_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  HyperloopConditionalExpression_Operator_HyperloopConditionalExpression_Operator_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool HyperloopConditionalExpression_Operator_IsValid(int value);
constexpr HyperloopConditionalExpression_Operator HyperloopConditionalExpression_Operator_Operator_MIN = HyperloopConditionalExpression_Operator_UNKNOWN;
constexpr HyperloopConditionalExpression_Operator HyperloopConditionalExpression_Operator_Operator_MAX = HyperloopConditionalExpression_Operator_GREATER_THAN_OR_EQUAL;
constexpr int HyperloopConditionalExpression_Operator_Operator_ARRAYSIZE = HyperloopConditionalExpression_Operator_Operator_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HyperloopConditionalExpression_Operator_descriptor();
template<typename T>
inline const std::string& HyperloopConditionalExpression_Operator_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HyperloopConditionalExpression_Operator>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HyperloopConditionalExpression_Operator_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HyperloopConditionalExpression_Operator_descriptor(), enum_t_value);
}
inline bool HyperloopConditionalExpression_Operator_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HyperloopConditionalExpression_Operator* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HyperloopConditionalExpression_Operator>(
    HyperloopConditionalExpression_Operator_descriptor(), name, value);
}
// ===================================================================

class LeafExpression PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.LeafExpression) */ {
 public:
  inline LeafExpression() : LeafExpression(nullptr) {}
  virtual ~LeafExpression();
  explicit constexpr LeafExpression(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeafExpression(const LeafExpression& from);
  LeafExpression(LeafExpression&& from) noexcept
    : LeafExpression() {
    *this = ::std::move(from);
  }

  inline LeafExpression& operator=(const LeafExpression& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeafExpression& operator=(LeafExpression&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LeafExpression& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeafExpression* internal_default_instance() {
    return reinterpret_cast<const LeafExpression*>(
               &_LeafExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LeafExpression& a, LeafExpression& b) {
    a.Swap(&b);
  }
  inline void Swap(LeafExpression* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeafExpression* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LeafExpression* New() const final {
    return CreateMaybeMessage<LeafExpression>(nullptr);
  }

  LeafExpression* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LeafExpression>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LeafExpression& from);
  void MergeFrom(const LeafExpression& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeafExpression* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.LeafExpression";
  }
  protected:
  explicit LeafExpression(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLookupsFieldNumber = 1,
    kDefaultFieldNumber = 2,
  };
  // repeated .delivery.Lookup lookups = 1 [json_name = "lookups"];
  int lookups_size() const;
  private:
  int _internal_lookups_size() const;
  public:
  void clear_lookups();
  ::delivery::Lookup* mutable_lookups(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::Lookup >*
      mutable_lookups();
  private:
  const ::delivery::Lookup& _internal_lookups(int index) const;
  ::delivery::Lookup* _internal_add_lookups();
  public:
  const ::delivery::Lookup& lookups(int index) const;
  ::delivery::Lookup* add_lookups();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::Lookup >&
      lookups() const;

  // float default = 2 [json_name = "default"];
  void clear_default_();
  float default_() const;
  void set_default_(float value);
  private:
  float _internal_default_() const;
  void _internal_set_default_(float value);
  public:

  // @@protoc_insertion_point(class_scope:delivery.LeafExpression)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::Lookup > lookups_;
  float default__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// -------------------------------------------------------------------

class Lookup PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.Lookup) */ {
 public:
  inline Lookup() : Lookup(nullptr) {}
  virtual ~Lookup();
  explicit constexpr Lookup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Lookup(const Lookup& from);
  Lookup(Lookup&& from) noexcept
    : Lookup() {
    *this = ::std::move(from);
  }

  inline Lookup& operator=(const Lookup& from) {
    CopyFrom(from);
    return *this;
  }
  inline Lookup& operator=(Lookup&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Lookup& default_instance() {
    return *internal_default_instance();
  }
  enum LookupTypeCase {
    kFeatureId = 1,
    kParameterKey = 2,
    LOOKUP_TYPE_NOT_SET = 0,
  };

  static inline const Lookup* internal_default_instance() {
    return reinterpret_cast<const Lookup*>(
               &_Lookup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Lookup& a, Lookup& b) {
    a.Swap(&b);
  }
  inline void Swap(Lookup* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Lookup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Lookup* New() const final {
    return CreateMaybeMessage<Lookup>(nullptr);
  }

  Lookup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Lookup>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Lookup& from);
  void MergeFrom(const Lookup& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Lookup* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.Lookup";
  }
  protected:
  explicit Lookup(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeatureIdFieldNumber = 1,
    kParameterKeyFieldNumber = 2,
  };
  // uint64 feature_id = 1 [json_name = "featureId"];
  bool has_feature_id() const;
  private:
  bool _internal_has_feature_id() const;
  public:
  void clear_feature_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 feature_id() const;
  void set_feature_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_feature_id() const;
  void _internal_set_feature_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 parameter_key = 2 [json_name = "parameterKey"];
  bool has_parameter_key() const;
  private:
  bool _internal_has_parameter_key() const;
  public:
  void clear_parameter_key();
  ::PROTOBUF_NAMESPACE_ID::uint64 parameter_key() const;
  void set_parameter_key(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_parameter_key() const;
  void _internal_set_parameter_key(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  void clear_lookup_type();
  LookupTypeCase lookup_type_case() const;
  // @@protoc_insertion_point(class_scope:delivery.Lookup)
 private:
  class _Internal;
  void set_has_feature_id();
  void set_has_parameter_key();

  inline bool has_lookup_type() const;
  inline void clear_has_lookup_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union LookupTypeUnion {
    constexpr LookupTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::uint64 feature_id_;
    ::PROTOBUF_NAMESPACE_ID::uint64 parameter_key_;
  } lookup_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// -------------------------------------------------------------------

class BlenderConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.BlenderConfig) */ {
 public:
  inline BlenderConfig() : BlenderConfig(nullptr) {}
  virtual ~BlenderConfig();
  explicit constexpr BlenderConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlenderConfig(const BlenderConfig& from);
  BlenderConfig(BlenderConfig&& from) noexcept
    : BlenderConfig() {
    *this = ::std::move(from);
  }

  inline BlenderConfig& operator=(const BlenderConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlenderConfig& operator=(BlenderConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BlenderConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlenderConfig* internal_default_instance() {
    return reinterpret_cast<const BlenderConfig*>(
               &_BlenderConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BlenderConfig& a, BlenderConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(BlenderConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlenderConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlenderConfig* New() const final {
    return CreateMaybeMessage<BlenderConfig>(nullptr);
  }

  BlenderConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlenderConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BlenderConfig& from);
  void MergeFrom(const BlenderConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlenderConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.BlenderConfig";
  }
  protected:
  explicit BlenderConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQualityScoreFieldNumber = 1,
    kSortKeyFieldNumber = 2,
  };
  // .delivery.BlenderExpression quality_score = 1 [json_name = "qualityScore"];
  bool has_quality_score() const;
  private:
  bool _internal_has_quality_score() const;
  public:
  void clear_quality_score();
  const ::delivery::BlenderExpression& quality_score() const;
  ::delivery::BlenderExpression* release_quality_score();
  ::delivery::BlenderExpression* mutable_quality_score();
  void set_allocated_quality_score(::delivery::BlenderExpression* quality_score);
  private:
  const ::delivery::BlenderExpression& _internal_quality_score() const;
  ::delivery::BlenderExpression* _internal_mutable_quality_score();
  public:
  void unsafe_arena_set_allocated_quality_score(
      ::delivery::BlenderExpression* quality_score);
  ::delivery::BlenderExpression* unsafe_arena_release_quality_score();

  // .delivery.BlenderSortKey sort_key = 2 [json_name = "sortKey"];
  bool has_sort_key() const;
  private:
  bool _internal_has_sort_key() const;
  public:
  void clear_sort_key();
  const ::delivery::BlenderSortKey& sort_key() const;
  ::delivery::BlenderSortKey* release_sort_key();
  ::delivery::BlenderSortKey* mutable_sort_key();
  void set_allocated_sort_key(::delivery::BlenderSortKey* sort_key);
  private:
  const ::delivery::BlenderSortKey& _internal_sort_key() const;
  ::delivery::BlenderSortKey* _internal_mutable_sort_key();
  public:
  void unsafe_arena_set_allocated_sort_key(
      ::delivery::BlenderSortKey* sort_key);
  ::delivery::BlenderSortKey* unsafe_arena_release_sort_key();

  // @@protoc_insertion_point(class_scope:delivery.BlenderConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::delivery::BlenderExpression* quality_score_;
  ::delivery::BlenderSortKey* sort_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// -------------------------------------------------------------------

class BlenderExpression PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.BlenderExpression) */ {
 public:
  inline BlenderExpression() : BlenderExpression(nullptr) {}
  virtual ~BlenderExpression();
  explicit constexpr BlenderExpression(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlenderExpression(const BlenderExpression& from);
  BlenderExpression(BlenderExpression&& from) noexcept
    : BlenderExpression() {
    *this = ::std::move(from);
  }

  inline BlenderExpression& operator=(const BlenderExpression& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlenderExpression& operator=(BlenderExpression&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BlenderExpression& default_instance() {
    return *internal_default_instance();
  }
  enum ExpTypeCase {
    kLeaf = 1,
    kArithmeticExp = 2,
    kConditionalExp = 3,
    EXP_TYPE_NOT_SET = 0,
  };

  static inline const BlenderExpression* internal_default_instance() {
    return reinterpret_cast<const BlenderExpression*>(
               &_BlenderExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BlenderExpression& a, BlenderExpression& b) {
    a.Swap(&b);
  }
  inline void Swap(BlenderExpression* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlenderExpression* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlenderExpression* New() const final {
    return CreateMaybeMessage<BlenderExpression>(nullptr);
  }

  BlenderExpression* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlenderExpression>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BlenderExpression& from);
  void MergeFrom(const BlenderExpression& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlenderExpression* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.BlenderExpression";
  }
  protected:
  explicit BlenderExpression(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeafFieldNumber = 1,
    kArithmeticExpFieldNumber = 2,
    kConditionalExpFieldNumber = 3,
  };
  // .delivery.LeafExpression leaf = 1 [json_name = "leaf"];
  bool has_leaf() const;
  private:
  bool _internal_has_leaf() const;
  public:
  void clear_leaf();
  const ::delivery::LeafExpression& leaf() const;
  ::delivery::LeafExpression* release_leaf();
  ::delivery::LeafExpression* mutable_leaf();
  void set_allocated_leaf(::delivery::LeafExpression* leaf);
  private:
  const ::delivery::LeafExpression& _internal_leaf() const;
  ::delivery::LeafExpression* _internal_mutable_leaf();
  public:
  void unsafe_arena_set_allocated_leaf(
      ::delivery::LeafExpression* leaf);
  ::delivery::LeafExpression* unsafe_arena_release_leaf();

  // .delivery.BlenderArithmeticExpression arithmetic_exp = 2 [json_name = "arithmeticExp"];
  bool has_arithmetic_exp() const;
  private:
  bool _internal_has_arithmetic_exp() const;
  public:
  void clear_arithmetic_exp();
  const ::delivery::BlenderArithmeticExpression& arithmetic_exp() const;
  ::delivery::BlenderArithmeticExpression* release_arithmetic_exp();
  ::delivery::BlenderArithmeticExpression* mutable_arithmetic_exp();
  void set_allocated_arithmetic_exp(::delivery::BlenderArithmeticExpression* arithmetic_exp);
  private:
  const ::delivery::BlenderArithmeticExpression& _internal_arithmetic_exp() const;
  ::delivery::BlenderArithmeticExpression* _internal_mutable_arithmetic_exp();
  public:
  void unsafe_arena_set_allocated_arithmetic_exp(
      ::delivery::BlenderArithmeticExpression* arithmetic_exp);
  ::delivery::BlenderArithmeticExpression* unsafe_arena_release_arithmetic_exp();

  // .delivery.BlenderConditionalExpression conditional_exp = 3 [json_name = "conditionalExp"];
  bool has_conditional_exp() const;
  private:
  bool _internal_has_conditional_exp() const;
  public:
  void clear_conditional_exp();
  const ::delivery::BlenderConditionalExpression& conditional_exp() const;
  ::delivery::BlenderConditionalExpression* release_conditional_exp();
  ::delivery::BlenderConditionalExpression* mutable_conditional_exp();
  void set_allocated_conditional_exp(::delivery::BlenderConditionalExpression* conditional_exp);
  private:
  const ::delivery::BlenderConditionalExpression& _internal_conditional_exp() const;
  ::delivery::BlenderConditionalExpression* _internal_mutable_conditional_exp();
  public:
  void unsafe_arena_set_allocated_conditional_exp(
      ::delivery::BlenderConditionalExpression* conditional_exp);
  ::delivery::BlenderConditionalExpression* unsafe_arena_release_conditional_exp();

  void clear_exp_type();
  ExpTypeCase exp_type_case() const;
  // @@protoc_insertion_point(class_scope:delivery.BlenderExpression)
 private:
  class _Internal;
  void set_has_leaf();
  void set_has_arithmetic_exp();
  void set_has_conditional_exp();

  inline bool has_exp_type() const;
  inline void clear_has_exp_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ExpTypeUnion {
    constexpr ExpTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::delivery::LeafExpression* leaf_;
    ::delivery::BlenderArithmeticExpression* arithmetic_exp_;
    ::delivery::BlenderConditionalExpression* conditional_exp_;
  } exp_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// -------------------------------------------------------------------

class BlenderArithmeticExpression PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.BlenderArithmeticExpression) */ {
 public:
  inline BlenderArithmeticExpression() : BlenderArithmeticExpression(nullptr) {}
  virtual ~BlenderArithmeticExpression();
  explicit constexpr BlenderArithmeticExpression(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlenderArithmeticExpression(const BlenderArithmeticExpression& from);
  BlenderArithmeticExpression(BlenderArithmeticExpression&& from) noexcept
    : BlenderArithmeticExpression() {
    *this = ::std::move(from);
  }

  inline BlenderArithmeticExpression& operator=(const BlenderArithmeticExpression& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlenderArithmeticExpression& operator=(BlenderArithmeticExpression&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BlenderArithmeticExpression& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlenderArithmeticExpression* internal_default_instance() {
    return reinterpret_cast<const BlenderArithmeticExpression*>(
               &_BlenderArithmeticExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BlenderArithmeticExpression& a, BlenderArithmeticExpression& b) {
    a.Swap(&b);
  }
  inline void Swap(BlenderArithmeticExpression* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlenderArithmeticExpression* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlenderArithmeticExpression* New() const final {
    return CreateMaybeMessage<BlenderArithmeticExpression>(nullptr);
  }

  BlenderArithmeticExpression* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlenderArithmeticExpression>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BlenderArithmeticExpression& from);
  void MergeFrom(const BlenderArithmeticExpression& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlenderArithmeticExpression* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.BlenderArithmeticExpression";
  }
  protected:
  explicit BlenderArithmeticExpression(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  typedef BlenderArithmeticExpression_Operator Operator;
  static constexpr Operator UNKNOWN =
    BlenderArithmeticExpression_Operator_UNKNOWN;
  static constexpr Operator ADD =
    BlenderArithmeticExpression_Operator_ADD;
  static constexpr Operator MULTIPLY =
    BlenderArithmeticExpression_Operator_MULTIPLY;
  static constexpr Operator SUBTRACT =
    BlenderArithmeticExpression_Operator_SUBTRACT;
  static constexpr Operator DIVIDE =
    BlenderArithmeticExpression_Operator_DIVIDE;
  static constexpr Operator MIN =
    BlenderArithmeticExpression_Operator_MIN;
  static constexpr Operator MAX =
    BlenderArithmeticExpression_Operator_MAX;
  static constexpr Operator FLOOR =
    BlenderArithmeticExpression_Operator_FLOOR;
  static constexpr Operator CEILING =
    BlenderArithmeticExpression_Operator_CEILING;
  static inline bool Operator_IsValid(int value) {
    return BlenderArithmeticExpression_Operator_IsValid(value);
  }
  static constexpr Operator Operator_MIN =
    BlenderArithmeticExpression_Operator_Operator_MIN;
  static constexpr Operator Operator_MAX =
    BlenderArithmeticExpression_Operator_Operator_MAX;
  static constexpr int Operator_ARRAYSIZE =
    BlenderArithmeticExpression_Operator_Operator_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Operator_descriptor() {
    return BlenderArithmeticExpression_Operator_descriptor();
  }
  template<typename T>
  static inline const std::string& Operator_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Operator>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Operator_Name.");
    return BlenderArithmeticExpression_Operator_Name(enum_t_value);
  }
  static inline bool Operator_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Operator* value) {
    return BlenderArithmeticExpression_Operator_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kInputsFieldNumber = 2,
    kOpFieldNumber = 1,
  };
  // repeated .delivery.BlenderExpression inputs = 2 [json_name = "inputs"];
  int inputs_size() const;
  private:
  int _internal_inputs_size() const;
  public:
  void clear_inputs();
  ::delivery::BlenderExpression* mutable_inputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::BlenderExpression >*
      mutable_inputs();
  private:
  const ::delivery::BlenderExpression& _internal_inputs(int index) const;
  ::delivery::BlenderExpression* _internal_add_inputs();
  public:
  const ::delivery::BlenderExpression& inputs(int index) const;
  ::delivery::BlenderExpression* add_inputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::BlenderExpression >&
      inputs() const;

  // .delivery.BlenderArithmeticExpression.Operator op = 1 [json_name = "op"];
  void clear_op();
  ::delivery::BlenderArithmeticExpression_Operator op() const;
  void set_op(::delivery::BlenderArithmeticExpression_Operator value);
  private:
  ::delivery::BlenderArithmeticExpression_Operator _internal_op() const;
  void _internal_set_op(::delivery::BlenderArithmeticExpression_Operator value);
  public:

  // @@protoc_insertion_point(class_scope:delivery.BlenderArithmeticExpression)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::BlenderExpression > inputs_;
  int op_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// -------------------------------------------------------------------

class BlenderConditionalExpression PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.BlenderConditionalExpression) */ {
 public:
  inline BlenderConditionalExpression() : BlenderConditionalExpression(nullptr) {}
  virtual ~BlenderConditionalExpression();
  explicit constexpr BlenderConditionalExpression(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlenderConditionalExpression(const BlenderConditionalExpression& from);
  BlenderConditionalExpression(BlenderConditionalExpression&& from) noexcept
    : BlenderConditionalExpression() {
    *this = ::std::move(from);
  }

  inline BlenderConditionalExpression& operator=(const BlenderConditionalExpression& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlenderConditionalExpression& operator=(BlenderConditionalExpression&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BlenderConditionalExpression& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlenderConditionalExpression* internal_default_instance() {
    return reinterpret_cast<const BlenderConditionalExpression*>(
               &_BlenderConditionalExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BlenderConditionalExpression& a, BlenderConditionalExpression& b) {
    a.Swap(&b);
  }
  inline void Swap(BlenderConditionalExpression* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlenderConditionalExpression* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlenderConditionalExpression* New() const final {
    return CreateMaybeMessage<BlenderConditionalExpression>(nullptr);
  }

  BlenderConditionalExpression* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlenderConditionalExpression>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BlenderConditionalExpression& from);
  void MergeFrom(const BlenderConditionalExpression& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlenderConditionalExpression* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.BlenderConditionalExpression";
  }
  protected:
  explicit BlenderConditionalExpression(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  typedef BlenderConditionalExpression_Operator Operator;
  static constexpr Operator UNKNOWN =
    BlenderConditionalExpression_Operator_UNKNOWN;
  static constexpr Operator EQUAL =
    BlenderConditionalExpression_Operator_EQUAL;
  static constexpr Operator GREATER_THAN =
    BlenderConditionalExpression_Operator_GREATER_THAN;
  static constexpr Operator GREATER_THAN_OR_EQUAL =
    BlenderConditionalExpression_Operator_GREATER_THAN_OR_EQUAL;
  static inline bool Operator_IsValid(int value) {
    return BlenderConditionalExpression_Operator_IsValid(value);
  }
  static constexpr Operator Operator_MIN =
    BlenderConditionalExpression_Operator_Operator_MIN;
  static constexpr Operator Operator_MAX =
    BlenderConditionalExpression_Operator_Operator_MAX;
  static constexpr int Operator_ARRAYSIZE =
    BlenderConditionalExpression_Operator_Operator_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Operator_descriptor() {
    return BlenderConditionalExpression_Operator_descriptor();
  }
  template<typename T>
  static inline const std::string& Operator_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Operator>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Operator_Name.");
    return BlenderConditionalExpression_Operator_Name(enum_t_value);
  }
  static inline bool Operator_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Operator* value) {
    return BlenderConditionalExpression_Operator_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPredicateLhsFieldNumber = 2,
    kPredicateRhsFieldNumber = 3,
    kThenBranchFieldNumber = 4,
    kElseBranchFieldNumber = 5,
    kOpFieldNumber = 1,
  };
  // .delivery.BlenderExpression predicate_lhs = 2 [json_name = "predicateLhs"];
  bool has_predicate_lhs() const;
  private:
  bool _internal_has_predicate_lhs() const;
  public:
  void clear_predicate_lhs();
  const ::delivery::BlenderExpression& predicate_lhs() const;
  ::delivery::BlenderExpression* release_predicate_lhs();
  ::delivery::BlenderExpression* mutable_predicate_lhs();
  void set_allocated_predicate_lhs(::delivery::BlenderExpression* predicate_lhs);
  private:
  const ::delivery::BlenderExpression& _internal_predicate_lhs() const;
  ::delivery::BlenderExpression* _internal_mutable_predicate_lhs();
  public:
  void unsafe_arena_set_allocated_predicate_lhs(
      ::delivery::BlenderExpression* predicate_lhs);
  ::delivery::BlenderExpression* unsafe_arena_release_predicate_lhs();

  // .delivery.BlenderExpression predicate_rhs = 3 [json_name = "predicateRhs"];
  bool has_predicate_rhs() const;
  private:
  bool _internal_has_predicate_rhs() const;
  public:
  void clear_predicate_rhs();
  const ::delivery::BlenderExpression& predicate_rhs() const;
  ::delivery::BlenderExpression* release_predicate_rhs();
  ::delivery::BlenderExpression* mutable_predicate_rhs();
  void set_allocated_predicate_rhs(::delivery::BlenderExpression* predicate_rhs);
  private:
  const ::delivery::BlenderExpression& _internal_predicate_rhs() const;
  ::delivery::BlenderExpression* _internal_mutable_predicate_rhs();
  public:
  void unsafe_arena_set_allocated_predicate_rhs(
      ::delivery::BlenderExpression* predicate_rhs);
  ::delivery::BlenderExpression* unsafe_arena_release_predicate_rhs();

  // .delivery.BlenderExpression then_branch = 4 [json_name = "thenBranch"];
  bool has_then_branch() const;
  private:
  bool _internal_has_then_branch() const;
  public:
  void clear_then_branch();
  const ::delivery::BlenderExpression& then_branch() const;
  ::delivery::BlenderExpression* release_then_branch();
  ::delivery::BlenderExpression* mutable_then_branch();
  void set_allocated_then_branch(::delivery::BlenderExpression* then_branch);
  private:
  const ::delivery::BlenderExpression& _internal_then_branch() const;
  ::delivery::BlenderExpression* _internal_mutable_then_branch();
  public:
  void unsafe_arena_set_allocated_then_branch(
      ::delivery::BlenderExpression* then_branch);
  ::delivery::BlenderExpression* unsafe_arena_release_then_branch();

  // .delivery.BlenderExpression else_branch = 5 [json_name = "elseBranch"];
  bool has_else_branch() const;
  private:
  bool _internal_has_else_branch() const;
  public:
  void clear_else_branch();
  const ::delivery::BlenderExpression& else_branch() const;
  ::delivery::BlenderExpression* release_else_branch();
  ::delivery::BlenderExpression* mutable_else_branch();
  void set_allocated_else_branch(::delivery::BlenderExpression* else_branch);
  private:
  const ::delivery::BlenderExpression& _internal_else_branch() const;
  ::delivery::BlenderExpression* _internal_mutable_else_branch();
  public:
  void unsafe_arena_set_allocated_else_branch(
      ::delivery::BlenderExpression* else_branch);
  ::delivery::BlenderExpression* unsafe_arena_release_else_branch();

  // .delivery.BlenderConditionalExpression.Operator op = 1 [json_name = "op"];
  void clear_op();
  ::delivery::BlenderConditionalExpression_Operator op() const;
  void set_op(::delivery::BlenderConditionalExpression_Operator value);
  private:
  ::delivery::BlenderConditionalExpression_Operator _internal_op() const;
  void _internal_set_op(::delivery::BlenderConditionalExpression_Operator value);
  public:

  // @@protoc_insertion_point(class_scope:delivery.BlenderConditionalExpression)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::delivery::BlenderExpression* predicate_lhs_;
  ::delivery::BlenderExpression* predicate_rhs_;
  ::delivery::BlenderExpression* then_branch_;
  ::delivery::BlenderExpression* else_branch_;
  int op_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// -------------------------------------------------------------------

class BlenderSortKey PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.BlenderSortKey) */ {
 public:
  inline BlenderSortKey() : BlenderSortKey(nullptr) {}
  virtual ~BlenderSortKey();
  explicit constexpr BlenderSortKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlenderSortKey(const BlenderSortKey& from);
  BlenderSortKey(BlenderSortKey&& from) noexcept
    : BlenderSortKey() {
    *this = ::std::move(from);
  }

  inline BlenderSortKey& operator=(const BlenderSortKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlenderSortKey& operator=(BlenderSortKey&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BlenderSortKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlenderSortKey* internal_default_instance() {
    return reinterpret_cast<const BlenderSortKey*>(
               &_BlenderSortKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BlenderSortKey& a, BlenderSortKey& b) {
    a.Swap(&b);
  }
  inline void Swap(BlenderSortKey* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlenderSortKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlenderSortKey* New() const final {
    return CreateMaybeMessage<BlenderSortKey>(nullptr);
  }

  BlenderSortKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlenderSortKey>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BlenderSortKey& from);
  void MergeFrom(const BlenderSortKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlenderSortKey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.BlenderSortKey";
  }
  protected:
  explicit BlenderSortKey(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kElementsFieldNumber = 1,
  };
  // repeated .delivery.BlenderExpression elements = 1 [json_name = "elements"];
  int elements_size() const;
  private:
  int _internal_elements_size() const;
  public:
  void clear_elements();
  ::delivery::BlenderExpression* mutable_elements(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::BlenderExpression >*
      mutable_elements();
  private:
  const ::delivery::BlenderExpression& _internal_elements(int index) const;
  ::delivery::BlenderExpression* _internal_add_elements();
  public:
  const ::delivery::BlenderExpression& elements(int index) const;
  ::delivery::BlenderExpression* add_elements();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::BlenderExpression >&
      elements() const;

  // @@protoc_insertion_point(class_scope:delivery.BlenderSortKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::BlenderExpression > elements_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// -------------------------------------------------------------------

class HyperloopConfig_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HyperloopConfig_ParametersEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::uint64, ::delivery::HyperloopParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HyperloopConfig_ParametersEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::uint64, ::delivery::HyperloopParameter,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  HyperloopConfig_ParametersEntry_DoNotUse();
  explicit constexpr HyperloopConfig_ParametersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit HyperloopConfig_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const HyperloopConfig_ParametersEntry_DoNotUse& other);
  static const HyperloopConfig_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const HyperloopConfig_ParametersEntry_DoNotUse*>(&_HyperloopConfig_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fdelivery_2fblender_2eproto);
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto.file_level_metadata[7];
  }

  public:
};

// -------------------------------------------------------------------

class HyperloopConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.HyperloopConfig) */ {
 public:
  inline HyperloopConfig() : HyperloopConfig(nullptr) {}
  virtual ~HyperloopConfig();
  explicit constexpr HyperloopConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HyperloopConfig(const HyperloopConfig& from);
  HyperloopConfig(HyperloopConfig&& from) noexcept
    : HyperloopConfig() {
    *this = ::std::move(from);
  }

  inline HyperloopConfig& operator=(const HyperloopConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline HyperloopConfig& operator=(HyperloopConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HyperloopConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const HyperloopConfig* internal_default_instance() {
    return reinterpret_cast<const HyperloopConfig*>(
               &_HyperloopConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(HyperloopConfig& a, HyperloopConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(HyperloopConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HyperloopConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HyperloopConfig* New() const final {
    return CreateMaybeMessage<HyperloopConfig>(nullptr);
  }

  HyperloopConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HyperloopConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HyperloopConfig& from);
  void MergeFrom(const HyperloopConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HyperloopConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.HyperloopConfig";
  }
  protected:
  explicit HyperloopConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 1,
  };
  // map<uint64, .delivery.HyperloopParameter> parameters = 1 [json_name = "parameters"];
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::delivery::HyperloopParameter >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::delivery::HyperloopParameter >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::delivery::HyperloopParameter >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::delivery::HyperloopParameter >*
      mutable_parameters();

  // @@protoc_insertion_point(class_scope:delivery.HyperloopConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      HyperloopConfig_ParametersEntry_DoNotUse,
      ::PROTOBUF_NAMESPACE_ID::uint64, ::delivery::HyperloopParameter,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> parameters_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// -------------------------------------------------------------------

class HyperloopParameter PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.HyperloopParameter) */ {
 public:
  inline HyperloopParameter() : HyperloopParameter(nullptr) {}
  virtual ~HyperloopParameter();
  explicit constexpr HyperloopParameter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HyperloopParameter(const HyperloopParameter& from);
  HyperloopParameter(HyperloopParameter&& from) noexcept
    : HyperloopParameter() {
    *this = ::std::move(from);
  }

  inline HyperloopParameter& operator=(const HyperloopParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline HyperloopParameter& operator=(HyperloopParameter&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HyperloopParameter& default_instance() {
    return *internal_default_instance();
  }
  static inline const HyperloopParameter* internal_default_instance() {
    return reinterpret_cast<const HyperloopParameter*>(
               &_HyperloopParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(HyperloopParameter& a, HyperloopParameter& b) {
    a.Swap(&b);
  }
  inline void Swap(HyperloopParameter* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HyperloopParameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HyperloopParameter* New() const final {
    return CreateMaybeMessage<HyperloopParameter>(nullptr);
  }

  HyperloopParameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HyperloopParameter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HyperloopParameter& from);
  void MergeFrom(const HyperloopParameter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HyperloopParameter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.HyperloopParameter";
  }
  protected:
  explicit HyperloopParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupsFieldNumber = 1,
    kDefaultFieldNumber = 2,
  };
  // repeated .delivery.HyperloopGroup groups = 1 [json_name = "groups"];
  int groups_size() const;
  private:
  int _internal_groups_size() const;
  public:
  void clear_groups();
  ::delivery::HyperloopGroup* mutable_groups(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::HyperloopGroup >*
      mutable_groups();
  private:
  const ::delivery::HyperloopGroup& _internal_groups(int index) const;
  ::delivery::HyperloopGroup* _internal_add_groups();
  public:
  const ::delivery::HyperloopGroup& groups(int index) const;
  ::delivery::HyperloopGroup* add_groups();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::HyperloopGroup >&
      groups() const;

  // float default = 2 [json_name = "default"];
  void clear_default_();
  float default_() const;
  void set_default_(float value);
  private:
  float _internal_default_() const;
  void _internal_set_default_(float value);
  public:

  // @@protoc_insertion_point(class_scope:delivery.HyperloopParameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::HyperloopGroup > groups_;
  float default__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// -------------------------------------------------------------------

class HyperloopGroup PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.HyperloopGroup) */ {
 public:
  inline HyperloopGroup() : HyperloopGroup(nullptr) {}
  virtual ~HyperloopGroup();
  explicit constexpr HyperloopGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HyperloopGroup(const HyperloopGroup& from);
  HyperloopGroup(HyperloopGroup&& from) noexcept
    : HyperloopGroup() {
    *this = ::std::move(from);
  }

  inline HyperloopGroup& operator=(const HyperloopGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline HyperloopGroup& operator=(HyperloopGroup&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HyperloopGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const HyperloopGroup* internal_default_instance() {
    return reinterpret_cast<const HyperloopGroup*>(
               &_HyperloopGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(HyperloopGroup& a, HyperloopGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(HyperloopGroup* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HyperloopGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HyperloopGroup* New() const final {
    return CreateMaybeMessage<HyperloopGroup>(nullptr);
  }

  HyperloopGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HyperloopGroup>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HyperloopGroup& from);
  void MergeFrom(const HyperloopGroup& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HyperloopGroup* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.HyperloopGroup";
  }
  protected:
  explicit HyperloopGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExpFieldNumber = 3,
    kLowBucketFieldNumber = 1,
    kHighBucketFieldNumber = 2,
  };
  // .delivery.HyperloopExpression exp = 3 [json_name = "exp"];
  bool has_exp() const;
  private:
  bool _internal_has_exp() const;
  public:
  void clear_exp();
  const ::delivery::HyperloopExpression& exp() const;
  ::delivery::HyperloopExpression* release_exp();
  ::delivery::HyperloopExpression* mutable_exp();
  void set_allocated_exp(::delivery::HyperloopExpression* exp);
  private:
  const ::delivery::HyperloopExpression& _internal_exp() const;
  ::delivery::HyperloopExpression* _internal_mutable_exp();
  public:
  void unsafe_arena_set_allocated_exp(
      ::delivery::HyperloopExpression* exp);
  ::delivery::HyperloopExpression* unsafe_arena_release_exp();

  // int32 low_bucket = 1 [json_name = "lowBucket"];
  void clear_low_bucket();
  ::PROTOBUF_NAMESPACE_ID::int32 low_bucket() const;
  void set_low_bucket(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_low_bucket() const;
  void _internal_set_low_bucket(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 high_bucket = 2 [json_name = "highBucket"];
  void clear_high_bucket();
  ::PROTOBUF_NAMESPACE_ID::int32 high_bucket() const;
  void set_high_bucket(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_high_bucket() const;
  void _internal_set_high_bucket(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:delivery.HyperloopGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::delivery::HyperloopExpression* exp_;
  ::PROTOBUF_NAMESPACE_ID::int32 low_bucket_;
  ::PROTOBUF_NAMESPACE_ID::int32 high_bucket_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// -------------------------------------------------------------------

class HyperloopExpression PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.HyperloopExpression) */ {
 public:
  inline HyperloopExpression() : HyperloopExpression(nullptr) {}
  virtual ~HyperloopExpression();
  explicit constexpr HyperloopExpression(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HyperloopExpression(const HyperloopExpression& from);
  HyperloopExpression(HyperloopExpression&& from) noexcept
    : HyperloopExpression() {
    *this = ::std::move(from);
  }

  inline HyperloopExpression& operator=(const HyperloopExpression& from) {
    CopyFrom(from);
    return *this;
  }
  inline HyperloopExpression& operator=(HyperloopExpression&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HyperloopExpression& default_instance() {
    return *internal_default_instance();
  }
  enum NodeTypeCase {
    kLeaf = 1,
    kGeneratorExp = 2,
    kConditionalExp = 3,
    NODE_TYPE_NOT_SET = 0,
  };

  static inline const HyperloopExpression* internal_default_instance() {
    return reinterpret_cast<const HyperloopExpression*>(
               &_HyperloopExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(HyperloopExpression& a, HyperloopExpression& b) {
    a.Swap(&b);
  }
  inline void Swap(HyperloopExpression* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HyperloopExpression* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HyperloopExpression* New() const final {
    return CreateMaybeMessage<HyperloopExpression>(nullptr);
  }

  HyperloopExpression* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HyperloopExpression>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HyperloopExpression& from);
  void MergeFrom(const HyperloopExpression& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HyperloopExpression* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.HyperloopExpression";
  }
  protected:
  explicit HyperloopExpression(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeafFieldNumber = 1,
    kGeneratorExpFieldNumber = 2,
    kConditionalExpFieldNumber = 3,
  };
  // .delivery.LeafExpression leaf = 1 [json_name = "leaf"];
  bool has_leaf() const;
  private:
  bool _internal_has_leaf() const;
  public:
  void clear_leaf();
  const ::delivery::LeafExpression& leaf() const;
  ::delivery::LeafExpression* release_leaf();
  ::delivery::LeafExpression* mutable_leaf();
  void set_allocated_leaf(::delivery::LeafExpression* leaf);
  private:
  const ::delivery::LeafExpression& _internal_leaf() const;
  ::delivery::LeafExpression* _internal_mutable_leaf();
  public:
  void unsafe_arena_set_allocated_leaf(
      ::delivery::LeafExpression* leaf);
  ::delivery::LeafExpression* unsafe_arena_release_leaf();

  // .delivery.HyperloopGeneratorExpression generator_exp = 2 [json_name = "generatorExp"];
  bool has_generator_exp() const;
  private:
  bool _internal_has_generator_exp() const;
  public:
  void clear_generator_exp();
  const ::delivery::HyperloopGeneratorExpression& generator_exp() const;
  ::delivery::HyperloopGeneratorExpression* release_generator_exp();
  ::delivery::HyperloopGeneratorExpression* mutable_generator_exp();
  void set_allocated_generator_exp(::delivery::HyperloopGeneratorExpression* generator_exp);
  private:
  const ::delivery::HyperloopGeneratorExpression& _internal_generator_exp() const;
  ::delivery::HyperloopGeneratorExpression* _internal_mutable_generator_exp();
  public:
  void unsafe_arena_set_allocated_generator_exp(
      ::delivery::HyperloopGeneratorExpression* generator_exp);
  ::delivery::HyperloopGeneratorExpression* unsafe_arena_release_generator_exp();

  // .delivery.HyperloopConditionalExpression conditional_exp = 3 [json_name = "conditionalExp"];
  bool has_conditional_exp() const;
  private:
  bool _internal_has_conditional_exp() const;
  public:
  void clear_conditional_exp();
  const ::delivery::HyperloopConditionalExpression& conditional_exp() const;
  ::delivery::HyperloopConditionalExpression* release_conditional_exp();
  ::delivery::HyperloopConditionalExpression* mutable_conditional_exp();
  void set_allocated_conditional_exp(::delivery::HyperloopConditionalExpression* conditional_exp);
  private:
  const ::delivery::HyperloopConditionalExpression& _internal_conditional_exp() const;
  ::delivery::HyperloopConditionalExpression* _internal_mutable_conditional_exp();
  public:
  void unsafe_arena_set_allocated_conditional_exp(
      ::delivery::HyperloopConditionalExpression* conditional_exp);
  ::delivery::HyperloopConditionalExpression* unsafe_arena_release_conditional_exp();

  void clear_node_type();
  NodeTypeCase node_type_case() const;
  // @@protoc_insertion_point(class_scope:delivery.HyperloopExpression)
 private:
  class _Internal;
  void set_has_leaf();
  void set_has_generator_exp();
  void set_has_conditional_exp();

  inline bool has_node_type() const;
  inline void clear_has_node_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union NodeTypeUnion {
    constexpr NodeTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::delivery::LeafExpression* leaf_;
    ::delivery::HyperloopGeneratorExpression* generator_exp_;
    ::delivery::HyperloopConditionalExpression* conditional_exp_;
  } node_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// -------------------------------------------------------------------

class HyperloopGeneratorExpression PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.HyperloopGeneratorExpression) */ {
 public:
  inline HyperloopGeneratorExpression() : HyperloopGeneratorExpression(nullptr) {}
  virtual ~HyperloopGeneratorExpression();
  explicit constexpr HyperloopGeneratorExpression(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HyperloopGeneratorExpression(const HyperloopGeneratorExpression& from);
  HyperloopGeneratorExpression(HyperloopGeneratorExpression&& from) noexcept
    : HyperloopGeneratorExpression() {
    *this = ::std::move(from);
  }

  inline HyperloopGeneratorExpression& operator=(const HyperloopGeneratorExpression& from) {
    CopyFrom(from);
    return *this;
  }
  inline HyperloopGeneratorExpression& operator=(HyperloopGeneratorExpression&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HyperloopGeneratorExpression& default_instance() {
    return *internal_default_instance();
  }
  enum GeneratorCase {
    kUniform = 1,
    kUniformMulti = 2,
    GENERATOR_NOT_SET = 0,
  };

  static inline const HyperloopGeneratorExpression* internal_default_instance() {
    return reinterpret_cast<const HyperloopGeneratorExpression*>(
               &_HyperloopGeneratorExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(HyperloopGeneratorExpression& a, HyperloopGeneratorExpression& b) {
    a.Swap(&b);
  }
  inline void Swap(HyperloopGeneratorExpression* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HyperloopGeneratorExpression* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HyperloopGeneratorExpression* New() const final {
    return CreateMaybeMessage<HyperloopGeneratorExpression>(nullptr);
  }

  HyperloopGeneratorExpression* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HyperloopGeneratorExpression>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HyperloopGeneratorExpression& from);
  void MergeFrom(const HyperloopGeneratorExpression& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HyperloopGeneratorExpression* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.HyperloopGeneratorExpression";
  }
  protected:
  explicit HyperloopGeneratorExpression(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUniformFieldNumber = 1,
    kUniformMultiFieldNumber = 2,
  };
  // .delivery.HyperloopUniformGenerator uniform = 1 [json_name = "uniform"];
  bool has_uniform() const;
  private:
  bool _internal_has_uniform() const;
  public:
  void clear_uniform();
  const ::delivery::HyperloopUniformGenerator& uniform() const;
  ::delivery::HyperloopUniformGenerator* release_uniform();
  ::delivery::HyperloopUniformGenerator* mutable_uniform();
  void set_allocated_uniform(::delivery::HyperloopUniformGenerator* uniform);
  private:
  const ::delivery::HyperloopUniformGenerator& _internal_uniform() const;
  ::delivery::HyperloopUniformGenerator* _internal_mutable_uniform();
  public:
  void unsafe_arena_set_allocated_uniform(
      ::delivery::HyperloopUniformGenerator* uniform);
  ::delivery::HyperloopUniformGenerator* unsafe_arena_release_uniform();

  // .delivery.HyperloopUniformMultiGenerator uniform_multi = 2 [json_name = "uniformMulti"];
  bool has_uniform_multi() const;
  private:
  bool _internal_has_uniform_multi() const;
  public:
  void clear_uniform_multi();
  const ::delivery::HyperloopUniformMultiGenerator& uniform_multi() const;
  ::delivery::HyperloopUniformMultiGenerator* release_uniform_multi();
  ::delivery::HyperloopUniformMultiGenerator* mutable_uniform_multi();
  void set_allocated_uniform_multi(::delivery::HyperloopUniformMultiGenerator* uniform_multi);
  private:
  const ::delivery::HyperloopUniformMultiGenerator& _internal_uniform_multi() const;
  ::delivery::HyperloopUniformMultiGenerator* _internal_mutable_uniform_multi();
  public:
  void unsafe_arena_set_allocated_uniform_multi(
      ::delivery::HyperloopUniformMultiGenerator* uniform_multi);
  ::delivery::HyperloopUniformMultiGenerator* unsafe_arena_release_uniform_multi();

  void clear_generator();
  GeneratorCase generator_case() const;
  // @@protoc_insertion_point(class_scope:delivery.HyperloopGeneratorExpression)
 private:
  class _Internal;
  void set_has_uniform();
  void set_has_uniform_multi();

  inline bool has_generator() const;
  inline void clear_has_generator();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union GeneratorUnion {
    constexpr GeneratorUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::delivery::HyperloopUniformGenerator* uniform_;
    ::delivery::HyperloopUniformMultiGenerator* uniform_multi_;
  } generator_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// -------------------------------------------------------------------

class HyperloopUniformGenerator PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.HyperloopUniformGenerator) */ {
 public:
  inline HyperloopUniformGenerator() : HyperloopUniformGenerator(nullptr) {}
  virtual ~HyperloopUniformGenerator();
  explicit constexpr HyperloopUniformGenerator(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HyperloopUniformGenerator(const HyperloopUniformGenerator& from);
  HyperloopUniformGenerator(HyperloopUniformGenerator&& from) noexcept
    : HyperloopUniformGenerator() {
    *this = ::std::move(from);
  }

  inline HyperloopUniformGenerator& operator=(const HyperloopUniformGenerator& from) {
    CopyFrom(from);
    return *this;
  }
  inline HyperloopUniformGenerator& operator=(HyperloopUniformGenerator&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HyperloopUniformGenerator& default_instance() {
    return *internal_default_instance();
  }
  static inline const HyperloopUniformGenerator* internal_default_instance() {
    return reinterpret_cast<const HyperloopUniformGenerator*>(
               &_HyperloopUniformGenerator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(HyperloopUniformGenerator& a, HyperloopUniformGenerator& b) {
    a.Swap(&b);
  }
  inline void Swap(HyperloopUniformGenerator* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HyperloopUniformGenerator* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HyperloopUniformGenerator* New() const final {
    return CreateMaybeMessage<HyperloopUniformGenerator>(nullptr);
  }

  HyperloopUniformGenerator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HyperloopUniformGenerator>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HyperloopUniformGenerator& from);
  void MergeFrom(const HyperloopUniformGenerator& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HyperloopUniformGenerator* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.HyperloopUniformGenerator";
  }
  protected:
  explicit HyperloopUniformGenerator(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLowBoundFieldNumber = 1,
    kHighBoundFieldNumber = 2,
  };
  // float low_bound = 1 [json_name = "lowBound"];
  void clear_low_bound();
  float low_bound() const;
  void set_low_bound(float value);
  private:
  float _internal_low_bound() const;
  void _internal_set_low_bound(float value);
  public:

  // float high_bound = 2 [json_name = "highBound"];
  void clear_high_bound();
  float high_bound() const;
  void set_high_bound(float value);
  private:
  float _internal_high_bound() const;
  void _internal_set_high_bound(float value);
  public:

  // @@protoc_insertion_point(class_scope:delivery.HyperloopUniformGenerator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float low_bound_;
  float high_bound_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// -------------------------------------------------------------------

class HyperloopUniformMultiGenerator PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.HyperloopUniformMultiGenerator) */ {
 public:
  inline HyperloopUniformMultiGenerator() : HyperloopUniformMultiGenerator(nullptr) {}
  virtual ~HyperloopUniformMultiGenerator();
  explicit constexpr HyperloopUniformMultiGenerator(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HyperloopUniformMultiGenerator(const HyperloopUniformMultiGenerator& from);
  HyperloopUniformMultiGenerator(HyperloopUniformMultiGenerator&& from) noexcept
    : HyperloopUniformMultiGenerator() {
    *this = ::std::move(from);
  }

  inline HyperloopUniformMultiGenerator& operator=(const HyperloopUniformMultiGenerator& from) {
    CopyFrom(from);
    return *this;
  }
  inline HyperloopUniformMultiGenerator& operator=(HyperloopUniformMultiGenerator&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HyperloopUniformMultiGenerator& default_instance() {
    return *internal_default_instance();
  }
  static inline const HyperloopUniformMultiGenerator* internal_default_instance() {
    return reinterpret_cast<const HyperloopUniformMultiGenerator*>(
               &_HyperloopUniformMultiGenerator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(HyperloopUniformMultiGenerator& a, HyperloopUniformMultiGenerator& b) {
    a.Swap(&b);
  }
  inline void Swap(HyperloopUniformMultiGenerator* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HyperloopUniformMultiGenerator* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HyperloopUniformMultiGenerator* New() const final {
    return CreateMaybeMessage<HyperloopUniformMultiGenerator>(nullptr);
  }

  HyperloopUniformMultiGenerator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HyperloopUniformMultiGenerator>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HyperloopUniformMultiGenerator& from);
  void MergeFrom(const HyperloopUniformMultiGenerator& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HyperloopUniformMultiGenerator* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.HyperloopUniformMultiGenerator";
  }
  protected:
  explicit HyperloopUniformMultiGenerator(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaseFieldNumber = 1,
    kMultiFieldNumber = 2,
  };
  // float base = 1 [json_name = "base"];
  void clear_base();
  float base() const;
  void set_base(float value);
  private:
  float _internal_base() const;
  void _internal_set_base(float value);
  public:

  // float multi = 2 [json_name = "multi"];
  void clear_multi();
  float multi() const;
  void set_multi(float value);
  private:
  float _internal_multi() const;
  void _internal_set_multi(float value);
  public:

  // @@protoc_insertion_point(class_scope:delivery.HyperloopUniformMultiGenerator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float base_;
  float multi_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// -------------------------------------------------------------------

class HyperloopConditionalExpression PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.HyperloopConditionalExpression) */ {
 public:
  inline HyperloopConditionalExpression() : HyperloopConditionalExpression(nullptr) {}
  virtual ~HyperloopConditionalExpression();
  explicit constexpr HyperloopConditionalExpression(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HyperloopConditionalExpression(const HyperloopConditionalExpression& from);
  HyperloopConditionalExpression(HyperloopConditionalExpression&& from) noexcept
    : HyperloopConditionalExpression() {
    *this = ::std::move(from);
  }

  inline HyperloopConditionalExpression& operator=(const HyperloopConditionalExpression& from) {
    CopyFrom(from);
    return *this;
  }
  inline HyperloopConditionalExpression& operator=(HyperloopConditionalExpression&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HyperloopConditionalExpression& default_instance() {
    return *internal_default_instance();
  }
  static inline const HyperloopConditionalExpression* internal_default_instance() {
    return reinterpret_cast<const HyperloopConditionalExpression*>(
               &_HyperloopConditionalExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(HyperloopConditionalExpression& a, HyperloopConditionalExpression& b) {
    a.Swap(&b);
  }
  inline void Swap(HyperloopConditionalExpression* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HyperloopConditionalExpression* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HyperloopConditionalExpression* New() const final {
    return CreateMaybeMessage<HyperloopConditionalExpression>(nullptr);
  }

  HyperloopConditionalExpression* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HyperloopConditionalExpression>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HyperloopConditionalExpression& from);
  void MergeFrom(const HyperloopConditionalExpression& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HyperloopConditionalExpression* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.HyperloopConditionalExpression";
  }
  protected:
  explicit HyperloopConditionalExpression(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  typedef HyperloopConditionalExpression_Operator Operator;
  static constexpr Operator UNKNOWN =
    HyperloopConditionalExpression_Operator_UNKNOWN;
  static constexpr Operator EQUAL =
    HyperloopConditionalExpression_Operator_EQUAL;
  static constexpr Operator GREATER_THAN =
    HyperloopConditionalExpression_Operator_GREATER_THAN;
  static constexpr Operator GREATER_THAN_OR_EQUAL =
    HyperloopConditionalExpression_Operator_GREATER_THAN_OR_EQUAL;
  static inline bool Operator_IsValid(int value) {
    return HyperloopConditionalExpression_Operator_IsValid(value);
  }
  static constexpr Operator Operator_MIN =
    HyperloopConditionalExpression_Operator_Operator_MIN;
  static constexpr Operator Operator_MAX =
    HyperloopConditionalExpression_Operator_Operator_MAX;
  static constexpr int Operator_ARRAYSIZE =
    HyperloopConditionalExpression_Operator_Operator_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Operator_descriptor() {
    return HyperloopConditionalExpression_Operator_descriptor();
  }
  template<typename T>
  static inline const std::string& Operator_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Operator>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Operator_Name.");
    return HyperloopConditionalExpression_Operator_Name(enum_t_value);
  }
  static inline bool Operator_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Operator* value) {
    return HyperloopConditionalExpression_Operator_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPredicateLhsFieldNumber = 2,
    kPredicateRhsFieldNumber = 3,
    kThenBranchFieldNumber = 4,
    kElseBranchFieldNumber = 5,
    kOpFieldNumber = 1,
  };
  // .delivery.HyperloopExpression predicate_lhs = 2 [json_name = "predicateLhs"];
  bool has_predicate_lhs() const;
  private:
  bool _internal_has_predicate_lhs() const;
  public:
  void clear_predicate_lhs();
  const ::delivery::HyperloopExpression& predicate_lhs() const;
  ::delivery::HyperloopExpression* release_predicate_lhs();
  ::delivery::HyperloopExpression* mutable_predicate_lhs();
  void set_allocated_predicate_lhs(::delivery::HyperloopExpression* predicate_lhs);
  private:
  const ::delivery::HyperloopExpression& _internal_predicate_lhs() const;
  ::delivery::HyperloopExpression* _internal_mutable_predicate_lhs();
  public:
  void unsafe_arena_set_allocated_predicate_lhs(
      ::delivery::HyperloopExpression* predicate_lhs);
  ::delivery::HyperloopExpression* unsafe_arena_release_predicate_lhs();

  // .delivery.HyperloopExpression predicate_rhs = 3 [json_name = "predicateRhs"];
  bool has_predicate_rhs() const;
  private:
  bool _internal_has_predicate_rhs() const;
  public:
  void clear_predicate_rhs();
  const ::delivery::HyperloopExpression& predicate_rhs() const;
  ::delivery::HyperloopExpression* release_predicate_rhs();
  ::delivery::HyperloopExpression* mutable_predicate_rhs();
  void set_allocated_predicate_rhs(::delivery::HyperloopExpression* predicate_rhs);
  private:
  const ::delivery::HyperloopExpression& _internal_predicate_rhs() const;
  ::delivery::HyperloopExpression* _internal_mutable_predicate_rhs();
  public:
  void unsafe_arena_set_allocated_predicate_rhs(
      ::delivery::HyperloopExpression* predicate_rhs);
  ::delivery::HyperloopExpression* unsafe_arena_release_predicate_rhs();

  // .delivery.HyperloopExpression then_branch = 4 [json_name = "thenBranch"];
  bool has_then_branch() const;
  private:
  bool _internal_has_then_branch() const;
  public:
  void clear_then_branch();
  const ::delivery::HyperloopExpression& then_branch() const;
  ::delivery::HyperloopExpression* release_then_branch();
  ::delivery::HyperloopExpression* mutable_then_branch();
  void set_allocated_then_branch(::delivery::HyperloopExpression* then_branch);
  private:
  const ::delivery::HyperloopExpression& _internal_then_branch() const;
  ::delivery::HyperloopExpression* _internal_mutable_then_branch();
  public:
  void unsafe_arena_set_allocated_then_branch(
      ::delivery::HyperloopExpression* then_branch);
  ::delivery::HyperloopExpression* unsafe_arena_release_then_branch();

  // .delivery.HyperloopExpression else_branch = 5 [json_name = "elseBranch"];
  bool has_else_branch() const;
  private:
  bool _internal_has_else_branch() const;
  public:
  void clear_else_branch();
  const ::delivery::HyperloopExpression& else_branch() const;
  ::delivery::HyperloopExpression* release_else_branch();
  ::delivery::HyperloopExpression* mutable_else_branch();
  void set_allocated_else_branch(::delivery::HyperloopExpression* else_branch);
  private:
  const ::delivery::HyperloopExpression& _internal_else_branch() const;
  ::delivery::HyperloopExpression* _internal_mutable_else_branch();
  public:
  void unsafe_arena_set_allocated_else_branch(
      ::delivery::HyperloopExpression* else_branch);
  ::delivery::HyperloopExpression* unsafe_arena_release_else_branch();

  // .delivery.HyperloopConditionalExpression.Operator op = 1 [json_name = "op"];
  void clear_op();
  ::delivery::HyperloopConditionalExpression_Operator op() const;
  void set_op(::delivery::HyperloopConditionalExpression_Operator value);
  private:
  ::delivery::HyperloopConditionalExpression_Operator _internal_op() const;
  void _internal_set_op(::delivery::HyperloopConditionalExpression_Operator value);
  public:

  // @@protoc_insertion_point(class_scope:delivery.HyperloopConditionalExpression)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::delivery::HyperloopExpression* predicate_lhs_;
  ::delivery::HyperloopExpression* predicate_rhs_;
  ::delivery::HyperloopExpression* then_branch_;
  ::delivery::HyperloopExpression* else_branch_;
  int op_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// -------------------------------------------------------------------

class HyperloopLog_ParameterLogsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HyperloopLog_ParameterLogsEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::uint64, ::delivery::HyperloopParameterLog,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HyperloopLog_ParameterLogsEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::uint64, ::delivery::HyperloopParameterLog,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  HyperloopLog_ParameterLogsEntry_DoNotUse();
  explicit constexpr HyperloopLog_ParameterLogsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit HyperloopLog_ParameterLogsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const HyperloopLog_ParameterLogsEntry_DoNotUse& other);
  static const HyperloopLog_ParameterLogsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const HyperloopLog_ParameterLogsEntry_DoNotUse*>(&_HyperloopLog_ParameterLogsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_proto_2fdelivery_2fblender_2eproto);
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto.file_level_metadata[16];
  }

  public:
};

// -------------------------------------------------------------------

class HyperloopLog PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.HyperloopLog) */ {
 public:
  inline HyperloopLog() : HyperloopLog(nullptr) {}
  virtual ~HyperloopLog();
  explicit constexpr HyperloopLog(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HyperloopLog(const HyperloopLog& from);
  HyperloopLog(HyperloopLog&& from) noexcept
    : HyperloopLog() {
    *this = ::std::move(from);
  }

  inline HyperloopLog& operator=(const HyperloopLog& from) {
    CopyFrom(from);
    return *this;
  }
  inline HyperloopLog& operator=(HyperloopLog&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HyperloopLog& default_instance() {
    return *internal_default_instance();
  }
  static inline const HyperloopLog* internal_default_instance() {
    return reinterpret_cast<const HyperloopLog*>(
               &_HyperloopLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(HyperloopLog& a, HyperloopLog& b) {
    a.Swap(&b);
  }
  inline void Swap(HyperloopLog* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HyperloopLog* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HyperloopLog* New() const final {
    return CreateMaybeMessage<HyperloopLog>(nullptr);
  }

  HyperloopLog* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HyperloopLog>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HyperloopLog& from);
  void MergeFrom(const HyperloopLog& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HyperloopLog* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.HyperloopLog";
  }
  protected:
  explicit HyperloopLog(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParameterLogsFieldNumber = 1,
  };
  // map<uint64, .delivery.HyperloopParameterLog> parameter_logs = 1 [json_name = "parameterLogs"];
  int parameter_logs_size() const;
  private:
  int _internal_parameter_logs_size() const;
  public:
  void clear_parameter_logs();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::delivery::HyperloopParameterLog >&
      _internal_parameter_logs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::delivery::HyperloopParameterLog >*
      _internal_mutable_parameter_logs();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::delivery::HyperloopParameterLog >&
      parameter_logs() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::delivery::HyperloopParameterLog >*
      mutable_parameter_logs();

  // @@protoc_insertion_point(class_scope:delivery.HyperloopLog)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      HyperloopLog_ParameterLogsEntry_DoNotUse,
      ::PROTOBUF_NAMESPACE_ID::uint64, ::delivery::HyperloopParameterLog,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> parameter_logs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// -------------------------------------------------------------------

class HyperloopParameterLog PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.HyperloopParameterLog) */ {
 public:
  inline HyperloopParameterLog() : HyperloopParameterLog(nullptr) {}
  virtual ~HyperloopParameterLog();
  explicit constexpr HyperloopParameterLog(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HyperloopParameterLog(const HyperloopParameterLog& from);
  HyperloopParameterLog(HyperloopParameterLog&& from) noexcept
    : HyperloopParameterLog() {
    *this = ::std::move(from);
  }

  inline HyperloopParameterLog& operator=(const HyperloopParameterLog& from) {
    CopyFrom(from);
    return *this;
  }
  inline HyperloopParameterLog& operator=(HyperloopParameterLog&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HyperloopParameterLog& default_instance() {
    return *internal_default_instance();
  }
  static inline const HyperloopParameterLog* internal_default_instance() {
    return reinterpret_cast<const HyperloopParameterLog*>(
               &_HyperloopParameterLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(HyperloopParameterLog& a, HyperloopParameterLog& b) {
    a.Swap(&b);
  }
  inline void Swap(HyperloopParameterLog* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HyperloopParameterLog* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HyperloopParameterLog* New() const final {
    return CreateMaybeMessage<HyperloopParameterLog>(nullptr);
  }

  HyperloopParameterLog* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HyperloopParameterLog>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HyperloopParameterLog& from);
  void MergeFrom(const HyperloopParameterLog& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HyperloopParameterLog* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.HyperloopParameterLog";
  }
  protected:
  explicit HyperloopParameterLog(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBucketFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // int32 bucket = 1 [json_name = "bucket"];
  void clear_bucket();
  ::PROTOBUF_NAMESPACE_ID::int32 bucket() const;
  void set_bucket(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_bucket() const;
  void _internal_set_bucket(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // float value = 2 [json_name = "value"];
  void clear_value();
  float value() const;
  void set_value(float value);
  private:
  float _internal_value() const;
  void _internal_set_value(float value);
  public:

  // @@protoc_insertion_point(class_scope:delivery.HyperloopParameterLog)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 bucket_;
  float value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LeafExpression

// repeated .delivery.Lookup lookups = 1 [json_name = "lookups"];
inline int LeafExpression::_internal_lookups_size() const {
  return lookups_.size();
}
inline int LeafExpression::lookups_size() const {
  return _internal_lookups_size();
}
inline void LeafExpression::clear_lookups() {
  lookups_.Clear();
}
inline ::delivery::Lookup* LeafExpression::mutable_lookups(int index) {
  // @@protoc_insertion_point(field_mutable:delivery.LeafExpression.lookups)
  return lookups_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::Lookup >*
LeafExpression::mutable_lookups() {
  // @@protoc_insertion_point(field_mutable_list:delivery.LeafExpression.lookups)
  return &lookups_;
}
inline const ::delivery::Lookup& LeafExpression::_internal_lookups(int index) const {
  return lookups_.Get(index);
}
inline const ::delivery::Lookup& LeafExpression::lookups(int index) const {
  // @@protoc_insertion_point(field_get:delivery.LeafExpression.lookups)
  return _internal_lookups(index);
}
inline ::delivery::Lookup* LeafExpression::_internal_add_lookups() {
  return lookups_.Add();
}
inline ::delivery::Lookup* LeafExpression::add_lookups() {
  // @@protoc_insertion_point(field_add:delivery.LeafExpression.lookups)
  return _internal_add_lookups();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::Lookup >&
LeafExpression::lookups() const {
  // @@protoc_insertion_point(field_list:delivery.LeafExpression.lookups)
  return lookups_;
}

// float default = 2 [json_name = "default"];
inline void LeafExpression::clear_default_() {
  default__ = 0;
}
inline float LeafExpression::_internal_default_() const {
  return default__;
}
inline float LeafExpression::default_() const {
  // @@protoc_insertion_point(field_get:delivery.LeafExpression.default)
  return _internal_default_();
}
inline void LeafExpression::_internal_set_default_(float value) {
  
  default__ = value;
}
inline void LeafExpression::set_default_(float value) {
  _internal_set_default_(value);
  // @@protoc_insertion_point(field_set:delivery.LeafExpression.default)
}

// -------------------------------------------------------------------

// Lookup

// uint64 feature_id = 1 [json_name = "featureId"];
inline bool Lookup::_internal_has_feature_id() const {
  return lookup_type_case() == kFeatureId;
}
inline bool Lookup::has_feature_id() const {
  return _internal_has_feature_id();
}
inline void Lookup::set_has_feature_id() {
  _oneof_case_[0] = kFeatureId;
}
inline void Lookup::clear_feature_id() {
  if (_internal_has_feature_id()) {
    lookup_type_.feature_id_ = PROTOBUF_ULONGLONG(0);
    clear_has_lookup_type();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Lookup::_internal_feature_id() const {
  if (_internal_has_feature_id()) {
    return lookup_type_.feature_id_;
  }
  return PROTOBUF_ULONGLONG(0);
}
inline void Lookup::_internal_set_feature_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  if (!_internal_has_feature_id()) {
    clear_lookup_type();
    set_has_feature_id();
  }
  lookup_type_.feature_id_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Lookup::feature_id() const {
  // @@protoc_insertion_point(field_get:delivery.Lookup.feature_id)
  return _internal_feature_id();
}
inline void Lookup::set_feature_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_feature_id(value);
  // @@protoc_insertion_point(field_set:delivery.Lookup.feature_id)
}

// uint64 parameter_key = 2 [json_name = "parameterKey"];
inline bool Lookup::_internal_has_parameter_key() const {
  return lookup_type_case() == kParameterKey;
}
inline bool Lookup::has_parameter_key() const {
  return _internal_has_parameter_key();
}
inline void Lookup::set_has_parameter_key() {
  _oneof_case_[0] = kParameterKey;
}
inline void Lookup::clear_parameter_key() {
  if (_internal_has_parameter_key()) {
    lookup_type_.parameter_key_ = PROTOBUF_ULONGLONG(0);
    clear_has_lookup_type();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Lookup::_internal_parameter_key() const {
  if (_internal_has_parameter_key()) {
    return lookup_type_.parameter_key_;
  }
  return PROTOBUF_ULONGLONG(0);
}
inline void Lookup::_internal_set_parameter_key(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  if (!_internal_has_parameter_key()) {
    clear_lookup_type();
    set_has_parameter_key();
  }
  lookup_type_.parameter_key_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Lookup::parameter_key() const {
  // @@protoc_insertion_point(field_get:delivery.Lookup.parameter_key)
  return _internal_parameter_key();
}
inline void Lookup::set_parameter_key(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_parameter_key(value);
  // @@protoc_insertion_point(field_set:delivery.Lookup.parameter_key)
}

inline bool Lookup::has_lookup_type() const {
  return lookup_type_case() != LOOKUP_TYPE_NOT_SET;
}
inline void Lookup::clear_has_lookup_type() {
  _oneof_case_[0] = LOOKUP_TYPE_NOT_SET;
}
inline Lookup::LookupTypeCase Lookup::lookup_type_case() const {
  return Lookup::LookupTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BlenderConfig

// .delivery.BlenderExpression quality_score = 1 [json_name = "qualityScore"];
inline bool BlenderConfig::_internal_has_quality_score() const {
  return this != internal_default_instance() && quality_score_ != nullptr;
}
inline bool BlenderConfig::has_quality_score() const {
  return _internal_has_quality_score();
}
inline void BlenderConfig::clear_quality_score() {
  if (GetArena() == nullptr && quality_score_ != nullptr) {
    delete quality_score_;
  }
  quality_score_ = nullptr;
}
inline const ::delivery::BlenderExpression& BlenderConfig::_internal_quality_score() const {
  const ::delivery::BlenderExpression* p = quality_score_;
  return p != nullptr ? *p : reinterpret_cast<const ::delivery::BlenderExpression&>(
      ::delivery::_BlenderExpression_default_instance_);
}
inline const ::delivery::BlenderExpression& BlenderConfig::quality_score() const {
  // @@protoc_insertion_point(field_get:delivery.BlenderConfig.quality_score)
  return _internal_quality_score();
}
inline void BlenderConfig::unsafe_arena_set_allocated_quality_score(
    ::delivery::BlenderExpression* quality_score) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(quality_score_);
  }
  quality_score_ = quality_score;
  if (quality_score) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.BlenderConfig.quality_score)
}
inline ::delivery::BlenderExpression* BlenderConfig::release_quality_score() {
  
  ::delivery::BlenderExpression* temp = quality_score_;
  quality_score_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::delivery::BlenderExpression* BlenderConfig::unsafe_arena_release_quality_score() {
  // @@protoc_insertion_point(field_release:delivery.BlenderConfig.quality_score)
  
  ::delivery::BlenderExpression* temp = quality_score_;
  quality_score_ = nullptr;
  return temp;
}
inline ::delivery::BlenderExpression* BlenderConfig::_internal_mutable_quality_score() {
  
  if (quality_score_ == nullptr) {
    auto* p = CreateMaybeMessage<::delivery::BlenderExpression>(GetArena());
    quality_score_ = p;
  }
  return quality_score_;
}
inline ::delivery::BlenderExpression* BlenderConfig::mutable_quality_score() {
  // @@protoc_insertion_point(field_mutable:delivery.BlenderConfig.quality_score)
  return _internal_mutable_quality_score();
}
inline void BlenderConfig::set_allocated_quality_score(::delivery::BlenderExpression* quality_score) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete quality_score_;
  }
  if (quality_score) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(quality_score);
    if (message_arena != submessage_arena) {
      quality_score = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, quality_score, submessage_arena);
    }
    
  } else {
    
  }
  quality_score_ = quality_score;
  // @@protoc_insertion_point(field_set_allocated:delivery.BlenderConfig.quality_score)
}

// .delivery.BlenderSortKey sort_key = 2 [json_name = "sortKey"];
inline bool BlenderConfig::_internal_has_sort_key() const {
  return this != internal_default_instance() && sort_key_ != nullptr;
}
inline bool BlenderConfig::has_sort_key() const {
  return _internal_has_sort_key();
}
inline void BlenderConfig::clear_sort_key() {
  if (GetArena() == nullptr && sort_key_ != nullptr) {
    delete sort_key_;
  }
  sort_key_ = nullptr;
}
inline const ::delivery::BlenderSortKey& BlenderConfig::_internal_sort_key() const {
  const ::delivery::BlenderSortKey* p = sort_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::delivery::BlenderSortKey&>(
      ::delivery::_BlenderSortKey_default_instance_);
}
inline const ::delivery::BlenderSortKey& BlenderConfig::sort_key() const {
  // @@protoc_insertion_point(field_get:delivery.BlenderConfig.sort_key)
  return _internal_sort_key();
}
inline void BlenderConfig::unsafe_arena_set_allocated_sort_key(
    ::delivery::BlenderSortKey* sort_key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sort_key_);
  }
  sort_key_ = sort_key;
  if (sort_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.BlenderConfig.sort_key)
}
inline ::delivery::BlenderSortKey* BlenderConfig::release_sort_key() {
  
  ::delivery::BlenderSortKey* temp = sort_key_;
  sort_key_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::delivery::BlenderSortKey* BlenderConfig::unsafe_arena_release_sort_key() {
  // @@protoc_insertion_point(field_release:delivery.BlenderConfig.sort_key)
  
  ::delivery::BlenderSortKey* temp = sort_key_;
  sort_key_ = nullptr;
  return temp;
}
inline ::delivery::BlenderSortKey* BlenderConfig::_internal_mutable_sort_key() {
  
  if (sort_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::delivery::BlenderSortKey>(GetArena());
    sort_key_ = p;
  }
  return sort_key_;
}
inline ::delivery::BlenderSortKey* BlenderConfig::mutable_sort_key() {
  // @@protoc_insertion_point(field_mutable:delivery.BlenderConfig.sort_key)
  return _internal_mutable_sort_key();
}
inline void BlenderConfig::set_allocated_sort_key(::delivery::BlenderSortKey* sort_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete sort_key_;
  }
  if (sort_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(sort_key);
    if (message_arena != submessage_arena) {
      sort_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sort_key, submessage_arena);
    }
    
  } else {
    
  }
  sort_key_ = sort_key;
  // @@protoc_insertion_point(field_set_allocated:delivery.BlenderConfig.sort_key)
}

// -------------------------------------------------------------------

// BlenderExpression

// .delivery.LeafExpression leaf = 1 [json_name = "leaf"];
inline bool BlenderExpression::_internal_has_leaf() const {
  return exp_type_case() == kLeaf;
}
inline bool BlenderExpression::has_leaf() const {
  return _internal_has_leaf();
}
inline void BlenderExpression::set_has_leaf() {
  _oneof_case_[0] = kLeaf;
}
inline void BlenderExpression::clear_leaf() {
  if (_internal_has_leaf()) {
    if (GetArena() == nullptr) {
      delete exp_type_.leaf_;
    }
    clear_has_exp_type();
  }
}
inline ::delivery::LeafExpression* BlenderExpression::release_leaf() {
  // @@protoc_insertion_point(field_release:delivery.BlenderExpression.leaf)
  if (_internal_has_leaf()) {
    clear_has_exp_type();
      ::delivery::LeafExpression* temp = exp_type_.leaf_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    exp_type_.leaf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::delivery::LeafExpression& BlenderExpression::_internal_leaf() const {
  return _internal_has_leaf()
      ? *exp_type_.leaf_
      : reinterpret_cast< ::delivery::LeafExpression&>(::delivery::_LeafExpression_default_instance_);
}
inline const ::delivery::LeafExpression& BlenderExpression::leaf() const {
  // @@protoc_insertion_point(field_get:delivery.BlenderExpression.leaf)
  return _internal_leaf();
}
inline ::delivery::LeafExpression* BlenderExpression::unsafe_arena_release_leaf() {
  // @@protoc_insertion_point(field_unsafe_arena_release:delivery.BlenderExpression.leaf)
  if (_internal_has_leaf()) {
    clear_has_exp_type();
    ::delivery::LeafExpression* temp = exp_type_.leaf_;
    exp_type_.leaf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlenderExpression::unsafe_arena_set_allocated_leaf(::delivery::LeafExpression* leaf) {
  clear_exp_type();
  if (leaf) {
    set_has_leaf();
    exp_type_.leaf_ = leaf;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.BlenderExpression.leaf)
}
inline ::delivery::LeafExpression* BlenderExpression::_internal_mutable_leaf() {
  if (!_internal_has_leaf()) {
    clear_exp_type();
    set_has_leaf();
    exp_type_.leaf_ = CreateMaybeMessage< ::delivery::LeafExpression >(GetArena());
  }
  return exp_type_.leaf_;
}
inline ::delivery::LeafExpression* BlenderExpression::mutable_leaf() {
  // @@protoc_insertion_point(field_mutable:delivery.BlenderExpression.leaf)
  return _internal_mutable_leaf();
}

// .delivery.BlenderArithmeticExpression arithmetic_exp = 2 [json_name = "arithmeticExp"];
inline bool BlenderExpression::_internal_has_arithmetic_exp() const {
  return exp_type_case() == kArithmeticExp;
}
inline bool BlenderExpression::has_arithmetic_exp() const {
  return _internal_has_arithmetic_exp();
}
inline void BlenderExpression::set_has_arithmetic_exp() {
  _oneof_case_[0] = kArithmeticExp;
}
inline void BlenderExpression::clear_arithmetic_exp() {
  if (_internal_has_arithmetic_exp()) {
    if (GetArena() == nullptr) {
      delete exp_type_.arithmetic_exp_;
    }
    clear_has_exp_type();
  }
}
inline ::delivery::BlenderArithmeticExpression* BlenderExpression::release_arithmetic_exp() {
  // @@protoc_insertion_point(field_release:delivery.BlenderExpression.arithmetic_exp)
  if (_internal_has_arithmetic_exp()) {
    clear_has_exp_type();
      ::delivery::BlenderArithmeticExpression* temp = exp_type_.arithmetic_exp_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    exp_type_.arithmetic_exp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::delivery::BlenderArithmeticExpression& BlenderExpression::_internal_arithmetic_exp() const {
  return _internal_has_arithmetic_exp()
      ? *exp_type_.arithmetic_exp_
      : reinterpret_cast< ::delivery::BlenderArithmeticExpression&>(::delivery::_BlenderArithmeticExpression_default_instance_);
}
inline const ::delivery::BlenderArithmeticExpression& BlenderExpression::arithmetic_exp() const {
  // @@protoc_insertion_point(field_get:delivery.BlenderExpression.arithmetic_exp)
  return _internal_arithmetic_exp();
}
inline ::delivery::BlenderArithmeticExpression* BlenderExpression::unsafe_arena_release_arithmetic_exp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:delivery.BlenderExpression.arithmetic_exp)
  if (_internal_has_arithmetic_exp()) {
    clear_has_exp_type();
    ::delivery::BlenderArithmeticExpression* temp = exp_type_.arithmetic_exp_;
    exp_type_.arithmetic_exp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlenderExpression::unsafe_arena_set_allocated_arithmetic_exp(::delivery::BlenderArithmeticExpression* arithmetic_exp) {
  clear_exp_type();
  if (arithmetic_exp) {
    set_has_arithmetic_exp();
    exp_type_.arithmetic_exp_ = arithmetic_exp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.BlenderExpression.arithmetic_exp)
}
inline ::delivery::BlenderArithmeticExpression* BlenderExpression::_internal_mutable_arithmetic_exp() {
  if (!_internal_has_arithmetic_exp()) {
    clear_exp_type();
    set_has_arithmetic_exp();
    exp_type_.arithmetic_exp_ = CreateMaybeMessage< ::delivery::BlenderArithmeticExpression >(GetArena());
  }
  return exp_type_.arithmetic_exp_;
}
inline ::delivery::BlenderArithmeticExpression* BlenderExpression::mutable_arithmetic_exp() {
  // @@protoc_insertion_point(field_mutable:delivery.BlenderExpression.arithmetic_exp)
  return _internal_mutable_arithmetic_exp();
}

// .delivery.BlenderConditionalExpression conditional_exp = 3 [json_name = "conditionalExp"];
inline bool BlenderExpression::_internal_has_conditional_exp() const {
  return exp_type_case() == kConditionalExp;
}
inline bool BlenderExpression::has_conditional_exp() const {
  return _internal_has_conditional_exp();
}
inline void BlenderExpression::set_has_conditional_exp() {
  _oneof_case_[0] = kConditionalExp;
}
inline void BlenderExpression::clear_conditional_exp() {
  if (_internal_has_conditional_exp()) {
    if (GetArena() == nullptr) {
      delete exp_type_.conditional_exp_;
    }
    clear_has_exp_type();
  }
}
inline ::delivery::BlenderConditionalExpression* BlenderExpression::release_conditional_exp() {
  // @@protoc_insertion_point(field_release:delivery.BlenderExpression.conditional_exp)
  if (_internal_has_conditional_exp()) {
    clear_has_exp_type();
      ::delivery::BlenderConditionalExpression* temp = exp_type_.conditional_exp_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    exp_type_.conditional_exp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::delivery::BlenderConditionalExpression& BlenderExpression::_internal_conditional_exp() const {
  return _internal_has_conditional_exp()
      ? *exp_type_.conditional_exp_
      : reinterpret_cast< ::delivery::BlenderConditionalExpression&>(::delivery::_BlenderConditionalExpression_default_instance_);
}
inline const ::delivery::BlenderConditionalExpression& BlenderExpression::conditional_exp() const {
  // @@protoc_insertion_point(field_get:delivery.BlenderExpression.conditional_exp)
  return _internal_conditional_exp();
}
inline ::delivery::BlenderConditionalExpression* BlenderExpression::unsafe_arena_release_conditional_exp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:delivery.BlenderExpression.conditional_exp)
  if (_internal_has_conditional_exp()) {
    clear_has_exp_type();
    ::delivery::BlenderConditionalExpression* temp = exp_type_.conditional_exp_;
    exp_type_.conditional_exp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlenderExpression::unsafe_arena_set_allocated_conditional_exp(::delivery::BlenderConditionalExpression* conditional_exp) {
  clear_exp_type();
  if (conditional_exp) {
    set_has_conditional_exp();
    exp_type_.conditional_exp_ = conditional_exp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.BlenderExpression.conditional_exp)
}
inline ::delivery::BlenderConditionalExpression* BlenderExpression::_internal_mutable_conditional_exp() {
  if (!_internal_has_conditional_exp()) {
    clear_exp_type();
    set_has_conditional_exp();
    exp_type_.conditional_exp_ = CreateMaybeMessage< ::delivery::BlenderConditionalExpression >(GetArena());
  }
  return exp_type_.conditional_exp_;
}
inline ::delivery::BlenderConditionalExpression* BlenderExpression::mutable_conditional_exp() {
  // @@protoc_insertion_point(field_mutable:delivery.BlenderExpression.conditional_exp)
  return _internal_mutable_conditional_exp();
}

inline bool BlenderExpression::has_exp_type() const {
  return exp_type_case() != EXP_TYPE_NOT_SET;
}
inline void BlenderExpression::clear_has_exp_type() {
  _oneof_case_[0] = EXP_TYPE_NOT_SET;
}
inline BlenderExpression::ExpTypeCase BlenderExpression::exp_type_case() const {
  return BlenderExpression::ExpTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BlenderArithmeticExpression

// .delivery.BlenderArithmeticExpression.Operator op = 1 [json_name = "op"];
inline void BlenderArithmeticExpression::clear_op() {
  op_ = 0;
}
inline ::delivery::BlenderArithmeticExpression_Operator BlenderArithmeticExpression::_internal_op() const {
  return static_cast< ::delivery::BlenderArithmeticExpression_Operator >(op_);
}
inline ::delivery::BlenderArithmeticExpression_Operator BlenderArithmeticExpression::op() const {
  // @@protoc_insertion_point(field_get:delivery.BlenderArithmeticExpression.op)
  return _internal_op();
}
inline void BlenderArithmeticExpression::_internal_set_op(::delivery::BlenderArithmeticExpression_Operator value) {
  
  op_ = value;
}
inline void BlenderArithmeticExpression::set_op(::delivery::BlenderArithmeticExpression_Operator value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:delivery.BlenderArithmeticExpression.op)
}

// repeated .delivery.BlenderExpression inputs = 2 [json_name = "inputs"];
inline int BlenderArithmeticExpression::_internal_inputs_size() const {
  return inputs_.size();
}
inline int BlenderArithmeticExpression::inputs_size() const {
  return _internal_inputs_size();
}
inline void BlenderArithmeticExpression::clear_inputs() {
  inputs_.Clear();
}
inline ::delivery::BlenderExpression* BlenderArithmeticExpression::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:delivery.BlenderArithmeticExpression.inputs)
  return inputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::BlenderExpression >*
BlenderArithmeticExpression::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:delivery.BlenderArithmeticExpression.inputs)
  return &inputs_;
}
inline const ::delivery::BlenderExpression& BlenderArithmeticExpression::_internal_inputs(int index) const {
  return inputs_.Get(index);
}
inline const ::delivery::BlenderExpression& BlenderArithmeticExpression::inputs(int index) const {
  // @@protoc_insertion_point(field_get:delivery.BlenderArithmeticExpression.inputs)
  return _internal_inputs(index);
}
inline ::delivery::BlenderExpression* BlenderArithmeticExpression::_internal_add_inputs() {
  return inputs_.Add();
}
inline ::delivery::BlenderExpression* BlenderArithmeticExpression::add_inputs() {
  // @@protoc_insertion_point(field_add:delivery.BlenderArithmeticExpression.inputs)
  return _internal_add_inputs();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::BlenderExpression >&
BlenderArithmeticExpression::inputs() const {
  // @@protoc_insertion_point(field_list:delivery.BlenderArithmeticExpression.inputs)
  return inputs_;
}

// -------------------------------------------------------------------

// BlenderConditionalExpression

// .delivery.BlenderConditionalExpression.Operator op = 1 [json_name = "op"];
inline void BlenderConditionalExpression::clear_op() {
  op_ = 0;
}
inline ::delivery::BlenderConditionalExpression_Operator BlenderConditionalExpression::_internal_op() const {
  return static_cast< ::delivery::BlenderConditionalExpression_Operator >(op_);
}
inline ::delivery::BlenderConditionalExpression_Operator BlenderConditionalExpression::op() const {
  // @@protoc_insertion_point(field_get:delivery.BlenderConditionalExpression.op)
  return _internal_op();
}
inline void BlenderConditionalExpression::_internal_set_op(::delivery::BlenderConditionalExpression_Operator value) {
  
  op_ = value;
}
inline void BlenderConditionalExpression::set_op(::delivery::BlenderConditionalExpression_Operator value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:delivery.BlenderConditionalExpression.op)
}

// .delivery.BlenderExpression predicate_lhs = 2 [json_name = "predicateLhs"];
inline bool BlenderConditionalExpression::_internal_has_predicate_lhs() const {
  return this != internal_default_instance() && predicate_lhs_ != nullptr;
}
inline bool BlenderConditionalExpression::has_predicate_lhs() const {
  return _internal_has_predicate_lhs();
}
inline void BlenderConditionalExpression::clear_predicate_lhs() {
  if (GetArena() == nullptr && predicate_lhs_ != nullptr) {
    delete predicate_lhs_;
  }
  predicate_lhs_ = nullptr;
}
inline const ::delivery::BlenderExpression& BlenderConditionalExpression::_internal_predicate_lhs() const {
  const ::delivery::BlenderExpression* p = predicate_lhs_;
  return p != nullptr ? *p : reinterpret_cast<const ::delivery::BlenderExpression&>(
      ::delivery::_BlenderExpression_default_instance_);
}
inline const ::delivery::BlenderExpression& BlenderConditionalExpression::predicate_lhs() const {
  // @@protoc_insertion_point(field_get:delivery.BlenderConditionalExpression.predicate_lhs)
  return _internal_predicate_lhs();
}
inline void BlenderConditionalExpression::unsafe_arena_set_allocated_predicate_lhs(
    ::delivery::BlenderExpression* predicate_lhs) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(predicate_lhs_);
  }
  predicate_lhs_ = predicate_lhs;
  if (predicate_lhs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.BlenderConditionalExpression.predicate_lhs)
}
inline ::delivery::BlenderExpression* BlenderConditionalExpression::release_predicate_lhs() {
  
  ::delivery::BlenderExpression* temp = predicate_lhs_;
  predicate_lhs_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::delivery::BlenderExpression* BlenderConditionalExpression::unsafe_arena_release_predicate_lhs() {
  // @@protoc_insertion_point(field_release:delivery.BlenderConditionalExpression.predicate_lhs)
  
  ::delivery::BlenderExpression* temp = predicate_lhs_;
  predicate_lhs_ = nullptr;
  return temp;
}
inline ::delivery::BlenderExpression* BlenderConditionalExpression::_internal_mutable_predicate_lhs() {
  
  if (predicate_lhs_ == nullptr) {
    auto* p = CreateMaybeMessage<::delivery::BlenderExpression>(GetArena());
    predicate_lhs_ = p;
  }
  return predicate_lhs_;
}
inline ::delivery::BlenderExpression* BlenderConditionalExpression::mutable_predicate_lhs() {
  // @@protoc_insertion_point(field_mutable:delivery.BlenderConditionalExpression.predicate_lhs)
  return _internal_mutable_predicate_lhs();
}
inline void BlenderConditionalExpression::set_allocated_predicate_lhs(::delivery::BlenderExpression* predicate_lhs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete predicate_lhs_;
  }
  if (predicate_lhs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(predicate_lhs);
    if (message_arena != submessage_arena) {
      predicate_lhs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, predicate_lhs, submessage_arena);
    }
    
  } else {
    
  }
  predicate_lhs_ = predicate_lhs;
  // @@protoc_insertion_point(field_set_allocated:delivery.BlenderConditionalExpression.predicate_lhs)
}

// .delivery.BlenderExpression predicate_rhs = 3 [json_name = "predicateRhs"];
inline bool BlenderConditionalExpression::_internal_has_predicate_rhs() const {
  return this != internal_default_instance() && predicate_rhs_ != nullptr;
}
inline bool BlenderConditionalExpression::has_predicate_rhs() const {
  return _internal_has_predicate_rhs();
}
inline void BlenderConditionalExpression::clear_predicate_rhs() {
  if (GetArena() == nullptr && predicate_rhs_ != nullptr) {
    delete predicate_rhs_;
  }
  predicate_rhs_ = nullptr;
}
inline const ::delivery::BlenderExpression& BlenderConditionalExpression::_internal_predicate_rhs() const {
  const ::delivery::BlenderExpression* p = predicate_rhs_;
  return p != nullptr ? *p : reinterpret_cast<const ::delivery::BlenderExpression&>(
      ::delivery::_BlenderExpression_default_instance_);
}
inline const ::delivery::BlenderExpression& BlenderConditionalExpression::predicate_rhs() const {
  // @@protoc_insertion_point(field_get:delivery.BlenderConditionalExpression.predicate_rhs)
  return _internal_predicate_rhs();
}
inline void BlenderConditionalExpression::unsafe_arena_set_allocated_predicate_rhs(
    ::delivery::BlenderExpression* predicate_rhs) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(predicate_rhs_);
  }
  predicate_rhs_ = predicate_rhs;
  if (predicate_rhs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.BlenderConditionalExpression.predicate_rhs)
}
inline ::delivery::BlenderExpression* BlenderConditionalExpression::release_predicate_rhs() {
  
  ::delivery::BlenderExpression* temp = predicate_rhs_;
  predicate_rhs_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::delivery::BlenderExpression* BlenderConditionalExpression::unsafe_arena_release_predicate_rhs() {
  // @@protoc_insertion_point(field_release:delivery.BlenderConditionalExpression.predicate_rhs)
  
  ::delivery::BlenderExpression* temp = predicate_rhs_;
  predicate_rhs_ = nullptr;
  return temp;
}
inline ::delivery::BlenderExpression* BlenderConditionalExpression::_internal_mutable_predicate_rhs() {
  
  if (predicate_rhs_ == nullptr) {
    auto* p = CreateMaybeMessage<::delivery::BlenderExpression>(GetArena());
    predicate_rhs_ = p;
  }
  return predicate_rhs_;
}
inline ::delivery::BlenderExpression* BlenderConditionalExpression::mutable_predicate_rhs() {
  // @@protoc_insertion_point(field_mutable:delivery.BlenderConditionalExpression.predicate_rhs)
  return _internal_mutable_predicate_rhs();
}
inline void BlenderConditionalExpression::set_allocated_predicate_rhs(::delivery::BlenderExpression* predicate_rhs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete predicate_rhs_;
  }
  if (predicate_rhs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(predicate_rhs);
    if (message_arena != submessage_arena) {
      predicate_rhs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, predicate_rhs, submessage_arena);
    }
    
  } else {
    
  }
  predicate_rhs_ = predicate_rhs;
  // @@protoc_insertion_point(field_set_allocated:delivery.BlenderConditionalExpression.predicate_rhs)
}

// .delivery.BlenderExpression then_branch = 4 [json_name = "thenBranch"];
inline bool BlenderConditionalExpression::_internal_has_then_branch() const {
  return this != internal_default_instance() && then_branch_ != nullptr;
}
inline bool BlenderConditionalExpression::has_then_branch() const {
  return _internal_has_then_branch();
}
inline void BlenderConditionalExpression::clear_then_branch() {
  if (GetArena() == nullptr && then_branch_ != nullptr) {
    delete then_branch_;
  }
  then_branch_ = nullptr;
}
inline const ::delivery::BlenderExpression& BlenderConditionalExpression::_internal_then_branch() const {
  const ::delivery::BlenderExpression* p = then_branch_;
  return p != nullptr ? *p : reinterpret_cast<const ::delivery::BlenderExpression&>(
      ::delivery::_BlenderExpression_default_instance_);
}
inline const ::delivery::BlenderExpression& BlenderConditionalExpression::then_branch() const {
  // @@protoc_insertion_point(field_get:delivery.BlenderConditionalExpression.then_branch)
  return _internal_then_branch();
}
inline void BlenderConditionalExpression::unsafe_arena_set_allocated_then_branch(
    ::delivery::BlenderExpression* then_branch) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(then_branch_);
  }
  then_branch_ = then_branch;
  if (then_branch) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.BlenderConditionalExpression.then_branch)
}
inline ::delivery::BlenderExpression* BlenderConditionalExpression::release_then_branch() {
  
  ::delivery::BlenderExpression* temp = then_branch_;
  then_branch_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::delivery::BlenderExpression* BlenderConditionalExpression::unsafe_arena_release_then_branch() {
  // @@protoc_insertion_point(field_release:delivery.BlenderConditionalExpression.then_branch)
  
  ::delivery::BlenderExpression* temp = then_branch_;
  then_branch_ = nullptr;
  return temp;
}
inline ::delivery::BlenderExpression* BlenderConditionalExpression::_internal_mutable_then_branch() {
  
  if (then_branch_ == nullptr) {
    auto* p = CreateMaybeMessage<::delivery::BlenderExpression>(GetArena());
    then_branch_ = p;
  }
  return then_branch_;
}
inline ::delivery::BlenderExpression* BlenderConditionalExpression::mutable_then_branch() {
  // @@protoc_insertion_point(field_mutable:delivery.BlenderConditionalExpression.then_branch)
  return _internal_mutable_then_branch();
}
inline void BlenderConditionalExpression::set_allocated_then_branch(::delivery::BlenderExpression* then_branch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete then_branch_;
  }
  if (then_branch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(then_branch);
    if (message_arena != submessage_arena) {
      then_branch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, then_branch, submessage_arena);
    }
    
  } else {
    
  }
  then_branch_ = then_branch;
  // @@protoc_insertion_point(field_set_allocated:delivery.BlenderConditionalExpression.then_branch)
}

// .delivery.BlenderExpression else_branch = 5 [json_name = "elseBranch"];
inline bool BlenderConditionalExpression::_internal_has_else_branch() const {
  return this != internal_default_instance() && else_branch_ != nullptr;
}
inline bool BlenderConditionalExpression::has_else_branch() const {
  return _internal_has_else_branch();
}
inline void BlenderConditionalExpression::clear_else_branch() {
  if (GetArena() == nullptr && else_branch_ != nullptr) {
    delete else_branch_;
  }
  else_branch_ = nullptr;
}
inline const ::delivery::BlenderExpression& BlenderConditionalExpression::_internal_else_branch() const {
  const ::delivery::BlenderExpression* p = else_branch_;
  return p != nullptr ? *p : reinterpret_cast<const ::delivery::BlenderExpression&>(
      ::delivery::_BlenderExpression_default_instance_);
}
inline const ::delivery::BlenderExpression& BlenderConditionalExpression::else_branch() const {
  // @@protoc_insertion_point(field_get:delivery.BlenderConditionalExpression.else_branch)
  return _internal_else_branch();
}
inline void BlenderConditionalExpression::unsafe_arena_set_allocated_else_branch(
    ::delivery::BlenderExpression* else_branch) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(else_branch_);
  }
  else_branch_ = else_branch;
  if (else_branch) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.BlenderConditionalExpression.else_branch)
}
inline ::delivery::BlenderExpression* BlenderConditionalExpression::release_else_branch() {
  
  ::delivery::BlenderExpression* temp = else_branch_;
  else_branch_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::delivery::BlenderExpression* BlenderConditionalExpression::unsafe_arena_release_else_branch() {
  // @@protoc_insertion_point(field_release:delivery.BlenderConditionalExpression.else_branch)
  
  ::delivery::BlenderExpression* temp = else_branch_;
  else_branch_ = nullptr;
  return temp;
}
inline ::delivery::BlenderExpression* BlenderConditionalExpression::_internal_mutable_else_branch() {
  
  if (else_branch_ == nullptr) {
    auto* p = CreateMaybeMessage<::delivery::BlenderExpression>(GetArena());
    else_branch_ = p;
  }
  return else_branch_;
}
inline ::delivery::BlenderExpression* BlenderConditionalExpression::mutable_else_branch() {
  // @@protoc_insertion_point(field_mutable:delivery.BlenderConditionalExpression.else_branch)
  return _internal_mutable_else_branch();
}
inline void BlenderConditionalExpression::set_allocated_else_branch(::delivery::BlenderExpression* else_branch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete else_branch_;
  }
  if (else_branch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(else_branch);
    if (message_arena != submessage_arena) {
      else_branch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, else_branch, submessage_arena);
    }
    
  } else {
    
  }
  else_branch_ = else_branch;
  // @@protoc_insertion_point(field_set_allocated:delivery.BlenderConditionalExpression.else_branch)
}

// -------------------------------------------------------------------

// BlenderSortKey

// repeated .delivery.BlenderExpression elements = 1 [json_name = "elements"];
inline int BlenderSortKey::_internal_elements_size() const {
  return elements_.size();
}
inline int BlenderSortKey::elements_size() const {
  return _internal_elements_size();
}
inline void BlenderSortKey::clear_elements() {
  elements_.Clear();
}
inline ::delivery::BlenderExpression* BlenderSortKey::mutable_elements(int index) {
  // @@protoc_insertion_point(field_mutable:delivery.BlenderSortKey.elements)
  return elements_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::BlenderExpression >*
BlenderSortKey::mutable_elements() {
  // @@protoc_insertion_point(field_mutable_list:delivery.BlenderSortKey.elements)
  return &elements_;
}
inline const ::delivery::BlenderExpression& BlenderSortKey::_internal_elements(int index) const {
  return elements_.Get(index);
}
inline const ::delivery::BlenderExpression& BlenderSortKey::elements(int index) const {
  // @@protoc_insertion_point(field_get:delivery.BlenderSortKey.elements)
  return _internal_elements(index);
}
inline ::delivery::BlenderExpression* BlenderSortKey::_internal_add_elements() {
  return elements_.Add();
}
inline ::delivery::BlenderExpression* BlenderSortKey::add_elements() {
  // @@protoc_insertion_point(field_add:delivery.BlenderSortKey.elements)
  return _internal_add_elements();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::BlenderExpression >&
BlenderSortKey::elements() const {
  // @@protoc_insertion_point(field_list:delivery.BlenderSortKey.elements)
  return elements_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HyperloopConfig

// map<uint64, .delivery.HyperloopParameter> parameters = 1 [json_name = "parameters"];
inline int HyperloopConfig::_internal_parameters_size() const {
  return parameters_.size();
}
inline int HyperloopConfig::parameters_size() const {
  return _internal_parameters_size();
}
inline void HyperloopConfig::clear_parameters() {
  parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::delivery::HyperloopParameter >&
HyperloopConfig::_internal_parameters() const {
  return parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::delivery::HyperloopParameter >&
HyperloopConfig::parameters() const {
  // @@protoc_insertion_point(field_map:delivery.HyperloopConfig.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::delivery::HyperloopParameter >*
HyperloopConfig::_internal_mutable_parameters() {
  return parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::delivery::HyperloopParameter >*
HyperloopConfig::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:delivery.HyperloopConfig.parameters)
  return _internal_mutable_parameters();
}

// -------------------------------------------------------------------

// HyperloopParameter

// repeated .delivery.HyperloopGroup groups = 1 [json_name = "groups"];
inline int HyperloopParameter::_internal_groups_size() const {
  return groups_.size();
}
inline int HyperloopParameter::groups_size() const {
  return _internal_groups_size();
}
inline void HyperloopParameter::clear_groups() {
  groups_.Clear();
}
inline ::delivery::HyperloopGroup* HyperloopParameter::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:delivery.HyperloopParameter.groups)
  return groups_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::HyperloopGroup >*
HyperloopParameter::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:delivery.HyperloopParameter.groups)
  return &groups_;
}
inline const ::delivery::HyperloopGroup& HyperloopParameter::_internal_groups(int index) const {
  return groups_.Get(index);
}
inline const ::delivery::HyperloopGroup& HyperloopParameter::groups(int index) const {
  // @@protoc_insertion_point(field_get:delivery.HyperloopParameter.groups)
  return _internal_groups(index);
}
inline ::delivery::HyperloopGroup* HyperloopParameter::_internal_add_groups() {
  return groups_.Add();
}
inline ::delivery::HyperloopGroup* HyperloopParameter::add_groups() {
  // @@protoc_insertion_point(field_add:delivery.HyperloopParameter.groups)
  return _internal_add_groups();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::HyperloopGroup >&
HyperloopParameter::groups() const {
  // @@protoc_insertion_point(field_list:delivery.HyperloopParameter.groups)
  return groups_;
}

// float default = 2 [json_name = "default"];
inline void HyperloopParameter::clear_default_() {
  default__ = 0;
}
inline float HyperloopParameter::_internal_default_() const {
  return default__;
}
inline float HyperloopParameter::default_() const {
  // @@protoc_insertion_point(field_get:delivery.HyperloopParameter.default)
  return _internal_default_();
}
inline void HyperloopParameter::_internal_set_default_(float value) {
  
  default__ = value;
}
inline void HyperloopParameter::set_default_(float value) {
  _internal_set_default_(value);
  // @@protoc_insertion_point(field_set:delivery.HyperloopParameter.default)
}

// -------------------------------------------------------------------

// HyperloopGroup

// int32 low_bucket = 1 [json_name = "lowBucket"];
inline void HyperloopGroup::clear_low_bucket() {
  low_bucket_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HyperloopGroup::_internal_low_bucket() const {
  return low_bucket_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HyperloopGroup::low_bucket() const {
  // @@protoc_insertion_point(field_get:delivery.HyperloopGroup.low_bucket)
  return _internal_low_bucket();
}
inline void HyperloopGroup::_internal_set_low_bucket(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  low_bucket_ = value;
}
inline void HyperloopGroup::set_low_bucket(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_low_bucket(value);
  // @@protoc_insertion_point(field_set:delivery.HyperloopGroup.low_bucket)
}

// int32 high_bucket = 2 [json_name = "highBucket"];
inline void HyperloopGroup::clear_high_bucket() {
  high_bucket_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HyperloopGroup::_internal_high_bucket() const {
  return high_bucket_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HyperloopGroup::high_bucket() const {
  // @@protoc_insertion_point(field_get:delivery.HyperloopGroup.high_bucket)
  return _internal_high_bucket();
}
inline void HyperloopGroup::_internal_set_high_bucket(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  high_bucket_ = value;
}
inline void HyperloopGroup::set_high_bucket(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_high_bucket(value);
  // @@protoc_insertion_point(field_set:delivery.HyperloopGroup.high_bucket)
}

// .delivery.HyperloopExpression exp = 3 [json_name = "exp"];
inline bool HyperloopGroup::_internal_has_exp() const {
  return this != internal_default_instance() && exp_ != nullptr;
}
inline bool HyperloopGroup::has_exp() const {
  return _internal_has_exp();
}
inline void HyperloopGroup::clear_exp() {
  if (GetArena() == nullptr && exp_ != nullptr) {
    delete exp_;
  }
  exp_ = nullptr;
}
inline const ::delivery::HyperloopExpression& HyperloopGroup::_internal_exp() const {
  const ::delivery::HyperloopExpression* p = exp_;
  return p != nullptr ? *p : reinterpret_cast<const ::delivery::HyperloopExpression&>(
      ::delivery::_HyperloopExpression_default_instance_);
}
inline const ::delivery::HyperloopExpression& HyperloopGroup::exp() const {
  // @@protoc_insertion_point(field_get:delivery.HyperloopGroup.exp)
  return _internal_exp();
}
inline void HyperloopGroup::unsafe_arena_set_allocated_exp(
    ::delivery::HyperloopExpression* exp) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(exp_);
  }
  exp_ = exp;
  if (exp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.HyperloopGroup.exp)
}
inline ::delivery::HyperloopExpression* HyperloopGroup::release_exp() {
  
  ::delivery::HyperloopExpression* temp = exp_;
  exp_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::delivery::HyperloopExpression* HyperloopGroup::unsafe_arena_release_exp() {
  // @@protoc_insertion_point(field_release:delivery.HyperloopGroup.exp)
  
  ::delivery::HyperloopExpression* temp = exp_;
  exp_ = nullptr;
  return temp;
}
inline ::delivery::HyperloopExpression* HyperloopGroup::_internal_mutable_exp() {
  
  if (exp_ == nullptr) {
    auto* p = CreateMaybeMessage<::delivery::HyperloopExpression>(GetArena());
    exp_ = p;
  }
  return exp_;
}
inline ::delivery::HyperloopExpression* HyperloopGroup::mutable_exp() {
  // @@protoc_insertion_point(field_mutable:delivery.HyperloopGroup.exp)
  return _internal_mutable_exp();
}
inline void HyperloopGroup::set_allocated_exp(::delivery::HyperloopExpression* exp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete exp_;
  }
  if (exp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(exp);
    if (message_arena != submessage_arena) {
      exp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, exp, submessage_arena);
    }
    
  } else {
    
  }
  exp_ = exp;
  // @@protoc_insertion_point(field_set_allocated:delivery.HyperloopGroup.exp)
}

// -------------------------------------------------------------------

// HyperloopExpression

// .delivery.LeafExpression leaf = 1 [json_name = "leaf"];
inline bool HyperloopExpression::_internal_has_leaf() const {
  return node_type_case() == kLeaf;
}
inline bool HyperloopExpression::has_leaf() const {
  return _internal_has_leaf();
}
inline void HyperloopExpression::set_has_leaf() {
  _oneof_case_[0] = kLeaf;
}
inline void HyperloopExpression::clear_leaf() {
  if (_internal_has_leaf()) {
    if (GetArena() == nullptr) {
      delete node_type_.leaf_;
    }
    clear_has_node_type();
  }
}
inline ::delivery::LeafExpression* HyperloopExpression::release_leaf() {
  // @@protoc_insertion_point(field_release:delivery.HyperloopExpression.leaf)
  if (_internal_has_leaf()) {
    clear_has_node_type();
      ::delivery::LeafExpression* temp = node_type_.leaf_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    node_type_.leaf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::delivery::LeafExpression& HyperloopExpression::_internal_leaf() const {
  return _internal_has_leaf()
      ? *node_type_.leaf_
      : reinterpret_cast< ::delivery::LeafExpression&>(::delivery::_LeafExpression_default_instance_);
}
inline const ::delivery::LeafExpression& HyperloopExpression::leaf() const {
  // @@protoc_insertion_point(field_get:delivery.HyperloopExpression.leaf)
  return _internal_leaf();
}
inline ::delivery::LeafExpression* HyperloopExpression::unsafe_arena_release_leaf() {
  // @@protoc_insertion_point(field_unsafe_arena_release:delivery.HyperloopExpression.leaf)
  if (_internal_has_leaf()) {
    clear_has_node_type();
    ::delivery::LeafExpression* temp = node_type_.leaf_;
    node_type_.leaf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void HyperloopExpression::unsafe_arena_set_allocated_leaf(::delivery::LeafExpression* leaf) {
  clear_node_type();
  if (leaf) {
    set_has_leaf();
    node_type_.leaf_ = leaf;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.HyperloopExpression.leaf)
}
inline ::delivery::LeafExpression* HyperloopExpression::_internal_mutable_leaf() {
  if (!_internal_has_leaf()) {
    clear_node_type();
    set_has_leaf();
    node_type_.leaf_ = CreateMaybeMessage< ::delivery::LeafExpression >(GetArena());
  }
  return node_type_.leaf_;
}
inline ::delivery::LeafExpression* HyperloopExpression::mutable_leaf() {
  // @@protoc_insertion_point(field_mutable:delivery.HyperloopExpression.leaf)
  return _internal_mutable_leaf();
}

// .delivery.HyperloopGeneratorExpression generator_exp = 2 [json_name = "generatorExp"];
inline bool HyperloopExpression::_internal_has_generator_exp() const {
  return node_type_case() == kGeneratorExp;
}
inline bool HyperloopExpression::has_generator_exp() const {
  return _internal_has_generator_exp();
}
inline void HyperloopExpression::set_has_generator_exp() {
  _oneof_case_[0] = kGeneratorExp;
}
inline void HyperloopExpression::clear_generator_exp() {
  if (_internal_has_generator_exp()) {
    if (GetArena() == nullptr) {
      delete node_type_.generator_exp_;
    }
    clear_has_node_type();
  }
}
inline ::delivery::HyperloopGeneratorExpression* HyperloopExpression::release_generator_exp() {
  // @@protoc_insertion_point(field_release:delivery.HyperloopExpression.generator_exp)
  if (_internal_has_generator_exp()) {
    clear_has_node_type();
      ::delivery::HyperloopGeneratorExpression* temp = node_type_.generator_exp_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    node_type_.generator_exp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::delivery::HyperloopGeneratorExpression& HyperloopExpression::_internal_generator_exp() const {
  return _internal_has_generator_exp()
      ? *node_type_.generator_exp_
      : reinterpret_cast< ::delivery::HyperloopGeneratorExpression&>(::delivery::_HyperloopGeneratorExpression_default_instance_);
}
inline const ::delivery::HyperloopGeneratorExpression& HyperloopExpression::generator_exp() const {
  // @@protoc_insertion_point(field_get:delivery.HyperloopExpression.generator_exp)
  return _internal_generator_exp();
}
inline ::delivery::HyperloopGeneratorExpression* HyperloopExpression::unsafe_arena_release_generator_exp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:delivery.HyperloopExpression.generator_exp)
  if (_internal_has_generator_exp()) {
    clear_has_node_type();
    ::delivery::HyperloopGeneratorExpression* temp = node_type_.generator_exp_;
    node_type_.generator_exp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void HyperloopExpression::unsafe_arena_set_allocated_generator_exp(::delivery::HyperloopGeneratorExpression* generator_exp) {
  clear_node_type();
  if (generator_exp) {
    set_has_generator_exp();
    node_type_.generator_exp_ = generator_exp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.HyperloopExpression.generator_exp)
}
inline ::delivery::HyperloopGeneratorExpression* HyperloopExpression::_internal_mutable_generator_exp() {
  if (!_internal_has_generator_exp()) {
    clear_node_type();
    set_has_generator_exp();
    node_type_.generator_exp_ = CreateMaybeMessage< ::delivery::HyperloopGeneratorExpression >(GetArena());
  }
  return node_type_.generator_exp_;
}
inline ::delivery::HyperloopGeneratorExpression* HyperloopExpression::mutable_generator_exp() {
  // @@protoc_insertion_point(field_mutable:delivery.HyperloopExpression.generator_exp)
  return _internal_mutable_generator_exp();
}

// .delivery.HyperloopConditionalExpression conditional_exp = 3 [json_name = "conditionalExp"];
inline bool HyperloopExpression::_internal_has_conditional_exp() const {
  return node_type_case() == kConditionalExp;
}
inline bool HyperloopExpression::has_conditional_exp() const {
  return _internal_has_conditional_exp();
}
inline void HyperloopExpression::set_has_conditional_exp() {
  _oneof_case_[0] = kConditionalExp;
}
inline void HyperloopExpression::clear_conditional_exp() {
  if (_internal_has_conditional_exp()) {
    if (GetArena() == nullptr) {
      delete node_type_.conditional_exp_;
    }
    clear_has_node_type();
  }
}
inline ::delivery::HyperloopConditionalExpression* HyperloopExpression::release_conditional_exp() {
  // @@protoc_insertion_point(field_release:delivery.HyperloopExpression.conditional_exp)
  if (_internal_has_conditional_exp()) {
    clear_has_node_type();
      ::delivery::HyperloopConditionalExpression* temp = node_type_.conditional_exp_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    node_type_.conditional_exp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::delivery::HyperloopConditionalExpression& HyperloopExpression::_internal_conditional_exp() const {
  return _internal_has_conditional_exp()
      ? *node_type_.conditional_exp_
      : reinterpret_cast< ::delivery::HyperloopConditionalExpression&>(::delivery::_HyperloopConditionalExpression_default_instance_);
}
inline const ::delivery::HyperloopConditionalExpression& HyperloopExpression::conditional_exp() const {
  // @@protoc_insertion_point(field_get:delivery.HyperloopExpression.conditional_exp)
  return _internal_conditional_exp();
}
inline ::delivery::HyperloopConditionalExpression* HyperloopExpression::unsafe_arena_release_conditional_exp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:delivery.HyperloopExpression.conditional_exp)
  if (_internal_has_conditional_exp()) {
    clear_has_node_type();
    ::delivery::HyperloopConditionalExpression* temp = node_type_.conditional_exp_;
    node_type_.conditional_exp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void HyperloopExpression::unsafe_arena_set_allocated_conditional_exp(::delivery::HyperloopConditionalExpression* conditional_exp) {
  clear_node_type();
  if (conditional_exp) {
    set_has_conditional_exp();
    node_type_.conditional_exp_ = conditional_exp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.HyperloopExpression.conditional_exp)
}
inline ::delivery::HyperloopConditionalExpression* HyperloopExpression::_internal_mutable_conditional_exp() {
  if (!_internal_has_conditional_exp()) {
    clear_node_type();
    set_has_conditional_exp();
    node_type_.conditional_exp_ = CreateMaybeMessage< ::delivery::HyperloopConditionalExpression >(GetArena());
  }
  return node_type_.conditional_exp_;
}
inline ::delivery::HyperloopConditionalExpression* HyperloopExpression::mutable_conditional_exp() {
  // @@protoc_insertion_point(field_mutable:delivery.HyperloopExpression.conditional_exp)
  return _internal_mutable_conditional_exp();
}

inline bool HyperloopExpression::has_node_type() const {
  return node_type_case() != NODE_TYPE_NOT_SET;
}
inline void HyperloopExpression::clear_has_node_type() {
  _oneof_case_[0] = NODE_TYPE_NOT_SET;
}
inline HyperloopExpression::NodeTypeCase HyperloopExpression::node_type_case() const {
  return HyperloopExpression::NodeTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// HyperloopGeneratorExpression

// .delivery.HyperloopUniformGenerator uniform = 1 [json_name = "uniform"];
inline bool HyperloopGeneratorExpression::_internal_has_uniform() const {
  return generator_case() == kUniform;
}
inline bool HyperloopGeneratorExpression::has_uniform() const {
  return _internal_has_uniform();
}
inline void HyperloopGeneratorExpression::set_has_uniform() {
  _oneof_case_[0] = kUniform;
}
inline void HyperloopGeneratorExpression::clear_uniform() {
  if (_internal_has_uniform()) {
    if (GetArena() == nullptr) {
      delete generator_.uniform_;
    }
    clear_has_generator();
  }
}
inline ::delivery::HyperloopUniformGenerator* HyperloopGeneratorExpression::release_uniform() {
  // @@protoc_insertion_point(field_release:delivery.HyperloopGeneratorExpression.uniform)
  if (_internal_has_uniform()) {
    clear_has_generator();
      ::delivery::HyperloopUniformGenerator* temp = generator_.uniform_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    generator_.uniform_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::delivery::HyperloopUniformGenerator& HyperloopGeneratorExpression::_internal_uniform() const {
  return _internal_has_uniform()
      ? *generator_.uniform_
      : reinterpret_cast< ::delivery::HyperloopUniformGenerator&>(::delivery::_HyperloopUniformGenerator_default_instance_);
}
inline const ::delivery::HyperloopUniformGenerator& HyperloopGeneratorExpression::uniform() const {
  // @@protoc_insertion_point(field_get:delivery.HyperloopGeneratorExpression.uniform)
  return _internal_uniform();
}
inline ::delivery::HyperloopUniformGenerator* HyperloopGeneratorExpression::unsafe_arena_release_uniform() {
  // @@protoc_insertion_point(field_unsafe_arena_release:delivery.HyperloopGeneratorExpression.uniform)
  if (_internal_has_uniform()) {
    clear_has_generator();
    ::delivery::HyperloopUniformGenerator* temp = generator_.uniform_;
    generator_.uniform_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void HyperloopGeneratorExpression::unsafe_arena_set_allocated_uniform(::delivery::HyperloopUniformGenerator* uniform) {
  clear_generator();
  if (uniform) {
    set_has_uniform();
    generator_.uniform_ = uniform;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.HyperloopGeneratorExpression.uniform)
}
inline ::delivery::HyperloopUniformGenerator* HyperloopGeneratorExpression::_internal_mutable_uniform() {
  if (!_internal_has_uniform()) {
    clear_generator();
    set_has_uniform();
    generator_.uniform_ = CreateMaybeMessage< ::delivery::HyperloopUniformGenerator >(GetArena());
  }
  return generator_.uniform_;
}
inline ::delivery::HyperloopUniformGenerator* HyperloopGeneratorExpression::mutable_uniform() {
  // @@protoc_insertion_point(field_mutable:delivery.HyperloopGeneratorExpression.uniform)
  return _internal_mutable_uniform();
}

// .delivery.HyperloopUniformMultiGenerator uniform_multi = 2 [json_name = "uniformMulti"];
inline bool HyperloopGeneratorExpression::_internal_has_uniform_multi() const {
  return generator_case() == kUniformMulti;
}
inline bool HyperloopGeneratorExpression::has_uniform_multi() const {
  return _internal_has_uniform_multi();
}
inline void HyperloopGeneratorExpression::set_has_uniform_multi() {
  _oneof_case_[0] = kUniformMulti;
}
inline void HyperloopGeneratorExpression::clear_uniform_multi() {
  if (_internal_has_uniform_multi()) {
    if (GetArena() == nullptr) {
      delete generator_.uniform_multi_;
    }
    clear_has_generator();
  }
}
inline ::delivery::HyperloopUniformMultiGenerator* HyperloopGeneratorExpression::release_uniform_multi() {
  // @@protoc_insertion_point(field_release:delivery.HyperloopGeneratorExpression.uniform_multi)
  if (_internal_has_uniform_multi()) {
    clear_has_generator();
      ::delivery::HyperloopUniformMultiGenerator* temp = generator_.uniform_multi_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    generator_.uniform_multi_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::delivery::HyperloopUniformMultiGenerator& HyperloopGeneratorExpression::_internal_uniform_multi() const {
  return _internal_has_uniform_multi()
      ? *generator_.uniform_multi_
      : reinterpret_cast< ::delivery::HyperloopUniformMultiGenerator&>(::delivery::_HyperloopUniformMultiGenerator_default_instance_);
}
inline const ::delivery::HyperloopUniformMultiGenerator& HyperloopGeneratorExpression::uniform_multi() const {
  // @@protoc_insertion_point(field_get:delivery.HyperloopGeneratorExpression.uniform_multi)
  return _internal_uniform_multi();
}
inline ::delivery::HyperloopUniformMultiGenerator* HyperloopGeneratorExpression::unsafe_arena_release_uniform_multi() {
  // @@protoc_insertion_point(field_unsafe_arena_release:delivery.HyperloopGeneratorExpression.uniform_multi)
  if (_internal_has_uniform_multi()) {
    clear_has_generator();
    ::delivery::HyperloopUniformMultiGenerator* temp = generator_.uniform_multi_;
    generator_.uniform_multi_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void HyperloopGeneratorExpression::unsafe_arena_set_allocated_uniform_multi(::delivery::HyperloopUniformMultiGenerator* uniform_multi) {
  clear_generator();
  if (uniform_multi) {
    set_has_uniform_multi();
    generator_.uniform_multi_ = uniform_multi;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.HyperloopGeneratorExpression.uniform_multi)
}
inline ::delivery::HyperloopUniformMultiGenerator* HyperloopGeneratorExpression::_internal_mutable_uniform_multi() {
  if (!_internal_has_uniform_multi()) {
    clear_generator();
    set_has_uniform_multi();
    generator_.uniform_multi_ = CreateMaybeMessage< ::delivery::HyperloopUniformMultiGenerator >(GetArena());
  }
  return generator_.uniform_multi_;
}
inline ::delivery::HyperloopUniformMultiGenerator* HyperloopGeneratorExpression::mutable_uniform_multi() {
  // @@protoc_insertion_point(field_mutable:delivery.HyperloopGeneratorExpression.uniform_multi)
  return _internal_mutable_uniform_multi();
}

inline bool HyperloopGeneratorExpression::has_generator() const {
  return generator_case() != GENERATOR_NOT_SET;
}
inline void HyperloopGeneratorExpression::clear_has_generator() {
  _oneof_case_[0] = GENERATOR_NOT_SET;
}
inline HyperloopGeneratorExpression::GeneratorCase HyperloopGeneratorExpression::generator_case() const {
  return HyperloopGeneratorExpression::GeneratorCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// HyperloopUniformGenerator

// float low_bound = 1 [json_name = "lowBound"];
inline void HyperloopUniformGenerator::clear_low_bound() {
  low_bound_ = 0;
}
inline float HyperloopUniformGenerator::_internal_low_bound() const {
  return low_bound_;
}
inline float HyperloopUniformGenerator::low_bound() const {
  // @@protoc_insertion_point(field_get:delivery.HyperloopUniformGenerator.low_bound)
  return _internal_low_bound();
}
inline void HyperloopUniformGenerator::_internal_set_low_bound(float value) {
  
  low_bound_ = value;
}
inline void HyperloopUniformGenerator::set_low_bound(float value) {
  _internal_set_low_bound(value);
  // @@protoc_insertion_point(field_set:delivery.HyperloopUniformGenerator.low_bound)
}

// float high_bound = 2 [json_name = "highBound"];
inline void HyperloopUniformGenerator::clear_high_bound() {
  high_bound_ = 0;
}
inline float HyperloopUniformGenerator::_internal_high_bound() const {
  return high_bound_;
}
inline float HyperloopUniformGenerator::high_bound() const {
  // @@protoc_insertion_point(field_get:delivery.HyperloopUniformGenerator.high_bound)
  return _internal_high_bound();
}
inline void HyperloopUniformGenerator::_internal_set_high_bound(float value) {
  
  high_bound_ = value;
}
inline void HyperloopUniformGenerator::set_high_bound(float value) {
  _internal_set_high_bound(value);
  // @@protoc_insertion_point(field_set:delivery.HyperloopUniformGenerator.high_bound)
}

// -------------------------------------------------------------------

// HyperloopUniformMultiGenerator

// float base = 1 [json_name = "base"];
inline void HyperloopUniformMultiGenerator::clear_base() {
  base_ = 0;
}
inline float HyperloopUniformMultiGenerator::_internal_base() const {
  return base_;
}
inline float HyperloopUniformMultiGenerator::base() const {
  // @@protoc_insertion_point(field_get:delivery.HyperloopUniformMultiGenerator.base)
  return _internal_base();
}
inline void HyperloopUniformMultiGenerator::_internal_set_base(float value) {
  
  base_ = value;
}
inline void HyperloopUniformMultiGenerator::set_base(float value) {
  _internal_set_base(value);
  // @@protoc_insertion_point(field_set:delivery.HyperloopUniformMultiGenerator.base)
}

// float multi = 2 [json_name = "multi"];
inline void HyperloopUniformMultiGenerator::clear_multi() {
  multi_ = 0;
}
inline float HyperloopUniformMultiGenerator::_internal_multi() const {
  return multi_;
}
inline float HyperloopUniformMultiGenerator::multi() const {
  // @@protoc_insertion_point(field_get:delivery.HyperloopUniformMultiGenerator.multi)
  return _internal_multi();
}
inline void HyperloopUniformMultiGenerator::_internal_set_multi(float value) {
  
  multi_ = value;
}
inline void HyperloopUniformMultiGenerator::set_multi(float value) {
  _internal_set_multi(value);
  // @@protoc_insertion_point(field_set:delivery.HyperloopUniformMultiGenerator.multi)
}

// -------------------------------------------------------------------

// HyperloopConditionalExpression

// .delivery.HyperloopConditionalExpression.Operator op = 1 [json_name = "op"];
inline void HyperloopConditionalExpression::clear_op() {
  op_ = 0;
}
inline ::delivery::HyperloopConditionalExpression_Operator HyperloopConditionalExpression::_internal_op() const {
  return static_cast< ::delivery::HyperloopConditionalExpression_Operator >(op_);
}
inline ::delivery::HyperloopConditionalExpression_Operator HyperloopConditionalExpression::op() const {
  // @@protoc_insertion_point(field_get:delivery.HyperloopConditionalExpression.op)
  return _internal_op();
}
inline void HyperloopConditionalExpression::_internal_set_op(::delivery::HyperloopConditionalExpression_Operator value) {
  
  op_ = value;
}
inline void HyperloopConditionalExpression::set_op(::delivery::HyperloopConditionalExpression_Operator value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:delivery.HyperloopConditionalExpression.op)
}

// .delivery.HyperloopExpression predicate_lhs = 2 [json_name = "predicateLhs"];
inline bool HyperloopConditionalExpression::_internal_has_predicate_lhs() const {
  return this != internal_default_instance() && predicate_lhs_ != nullptr;
}
inline bool HyperloopConditionalExpression::has_predicate_lhs() const {
  return _internal_has_predicate_lhs();
}
inline void HyperloopConditionalExpression::clear_predicate_lhs() {
  if (GetArena() == nullptr && predicate_lhs_ != nullptr) {
    delete predicate_lhs_;
  }
  predicate_lhs_ = nullptr;
}
inline const ::delivery::HyperloopExpression& HyperloopConditionalExpression::_internal_predicate_lhs() const {
  const ::delivery::HyperloopExpression* p = predicate_lhs_;
  return p != nullptr ? *p : reinterpret_cast<const ::delivery::HyperloopExpression&>(
      ::delivery::_HyperloopExpression_default_instance_);
}
inline const ::delivery::HyperloopExpression& HyperloopConditionalExpression::predicate_lhs() const {
  // @@protoc_insertion_point(field_get:delivery.HyperloopConditionalExpression.predicate_lhs)
  return _internal_predicate_lhs();
}
inline void HyperloopConditionalExpression::unsafe_arena_set_allocated_predicate_lhs(
    ::delivery::HyperloopExpression* predicate_lhs) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(predicate_lhs_);
  }
  predicate_lhs_ = predicate_lhs;
  if (predicate_lhs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.HyperloopConditionalExpression.predicate_lhs)
}
inline ::delivery::HyperloopExpression* HyperloopConditionalExpression::release_predicate_lhs() {
  
  ::delivery::HyperloopExpression* temp = predicate_lhs_;
  predicate_lhs_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::delivery::HyperloopExpression* HyperloopConditionalExpression::unsafe_arena_release_predicate_lhs() {
  // @@protoc_insertion_point(field_release:delivery.HyperloopConditionalExpression.predicate_lhs)
  
  ::delivery::HyperloopExpression* temp = predicate_lhs_;
  predicate_lhs_ = nullptr;
  return temp;
}
inline ::delivery::HyperloopExpression* HyperloopConditionalExpression::_internal_mutable_predicate_lhs() {
  
  if (predicate_lhs_ == nullptr) {
    auto* p = CreateMaybeMessage<::delivery::HyperloopExpression>(GetArena());
    predicate_lhs_ = p;
  }
  return predicate_lhs_;
}
inline ::delivery::HyperloopExpression* HyperloopConditionalExpression::mutable_predicate_lhs() {
  // @@protoc_insertion_point(field_mutable:delivery.HyperloopConditionalExpression.predicate_lhs)
  return _internal_mutable_predicate_lhs();
}
inline void HyperloopConditionalExpression::set_allocated_predicate_lhs(::delivery::HyperloopExpression* predicate_lhs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete predicate_lhs_;
  }
  if (predicate_lhs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(predicate_lhs);
    if (message_arena != submessage_arena) {
      predicate_lhs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, predicate_lhs, submessage_arena);
    }
    
  } else {
    
  }
  predicate_lhs_ = predicate_lhs;
  // @@protoc_insertion_point(field_set_allocated:delivery.HyperloopConditionalExpression.predicate_lhs)
}

// .delivery.HyperloopExpression predicate_rhs = 3 [json_name = "predicateRhs"];
inline bool HyperloopConditionalExpression::_internal_has_predicate_rhs() const {
  return this != internal_default_instance() && predicate_rhs_ != nullptr;
}
inline bool HyperloopConditionalExpression::has_predicate_rhs() const {
  return _internal_has_predicate_rhs();
}
inline void HyperloopConditionalExpression::clear_predicate_rhs() {
  if (GetArena() == nullptr && predicate_rhs_ != nullptr) {
    delete predicate_rhs_;
  }
  predicate_rhs_ = nullptr;
}
inline const ::delivery::HyperloopExpression& HyperloopConditionalExpression::_internal_predicate_rhs() const {
  const ::delivery::HyperloopExpression* p = predicate_rhs_;
  return p != nullptr ? *p : reinterpret_cast<const ::delivery::HyperloopExpression&>(
      ::delivery::_HyperloopExpression_default_instance_);
}
inline const ::delivery::HyperloopExpression& HyperloopConditionalExpression::predicate_rhs() const {
  // @@protoc_insertion_point(field_get:delivery.HyperloopConditionalExpression.predicate_rhs)
  return _internal_predicate_rhs();
}
inline void HyperloopConditionalExpression::unsafe_arena_set_allocated_predicate_rhs(
    ::delivery::HyperloopExpression* predicate_rhs) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(predicate_rhs_);
  }
  predicate_rhs_ = predicate_rhs;
  if (predicate_rhs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.HyperloopConditionalExpression.predicate_rhs)
}
inline ::delivery::HyperloopExpression* HyperloopConditionalExpression::release_predicate_rhs() {
  
  ::delivery::HyperloopExpression* temp = predicate_rhs_;
  predicate_rhs_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::delivery::HyperloopExpression* HyperloopConditionalExpression::unsafe_arena_release_predicate_rhs() {
  // @@protoc_insertion_point(field_release:delivery.HyperloopConditionalExpression.predicate_rhs)
  
  ::delivery::HyperloopExpression* temp = predicate_rhs_;
  predicate_rhs_ = nullptr;
  return temp;
}
inline ::delivery::HyperloopExpression* HyperloopConditionalExpression::_internal_mutable_predicate_rhs() {
  
  if (predicate_rhs_ == nullptr) {
    auto* p = CreateMaybeMessage<::delivery::HyperloopExpression>(GetArena());
    predicate_rhs_ = p;
  }
  return predicate_rhs_;
}
inline ::delivery::HyperloopExpression* HyperloopConditionalExpression::mutable_predicate_rhs() {
  // @@protoc_insertion_point(field_mutable:delivery.HyperloopConditionalExpression.predicate_rhs)
  return _internal_mutable_predicate_rhs();
}
inline void HyperloopConditionalExpression::set_allocated_predicate_rhs(::delivery::HyperloopExpression* predicate_rhs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete predicate_rhs_;
  }
  if (predicate_rhs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(predicate_rhs);
    if (message_arena != submessage_arena) {
      predicate_rhs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, predicate_rhs, submessage_arena);
    }
    
  } else {
    
  }
  predicate_rhs_ = predicate_rhs;
  // @@protoc_insertion_point(field_set_allocated:delivery.HyperloopConditionalExpression.predicate_rhs)
}

// .delivery.HyperloopExpression then_branch = 4 [json_name = "thenBranch"];
inline bool HyperloopConditionalExpression::_internal_has_then_branch() const {
  return this != internal_default_instance() && then_branch_ != nullptr;
}
inline bool HyperloopConditionalExpression::has_then_branch() const {
  return _internal_has_then_branch();
}
inline void HyperloopConditionalExpression::clear_then_branch() {
  if (GetArena() == nullptr && then_branch_ != nullptr) {
    delete then_branch_;
  }
  then_branch_ = nullptr;
}
inline const ::delivery::HyperloopExpression& HyperloopConditionalExpression::_internal_then_branch() const {
  const ::delivery::HyperloopExpression* p = then_branch_;
  return p != nullptr ? *p : reinterpret_cast<const ::delivery::HyperloopExpression&>(
      ::delivery::_HyperloopExpression_default_instance_);
}
inline const ::delivery::HyperloopExpression& HyperloopConditionalExpression::then_branch() const {
  // @@protoc_insertion_point(field_get:delivery.HyperloopConditionalExpression.then_branch)
  return _internal_then_branch();
}
inline void HyperloopConditionalExpression::unsafe_arena_set_allocated_then_branch(
    ::delivery::HyperloopExpression* then_branch) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(then_branch_);
  }
  then_branch_ = then_branch;
  if (then_branch) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.HyperloopConditionalExpression.then_branch)
}
inline ::delivery::HyperloopExpression* HyperloopConditionalExpression::release_then_branch() {
  
  ::delivery::HyperloopExpression* temp = then_branch_;
  then_branch_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::delivery::HyperloopExpression* HyperloopConditionalExpression::unsafe_arena_release_then_branch() {
  // @@protoc_insertion_point(field_release:delivery.HyperloopConditionalExpression.then_branch)
  
  ::delivery::HyperloopExpression* temp = then_branch_;
  then_branch_ = nullptr;
  return temp;
}
inline ::delivery::HyperloopExpression* HyperloopConditionalExpression::_internal_mutable_then_branch() {
  
  if (then_branch_ == nullptr) {
    auto* p = CreateMaybeMessage<::delivery::HyperloopExpression>(GetArena());
    then_branch_ = p;
  }
  return then_branch_;
}
inline ::delivery::HyperloopExpression* HyperloopConditionalExpression::mutable_then_branch() {
  // @@protoc_insertion_point(field_mutable:delivery.HyperloopConditionalExpression.then_branch)
  return _internal_mutable_then_branch();
}
inline void HyperloopConditionalExpression::set_allocated_then_branch(::delivery::HyperloopExpression* then_branch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete then_branch_;
  }
  if (then_branch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(then_branch);
    if (message_arena != submessage_arena) {
      then_branch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, then_branch, submessage_arena);
    }
    
  } else {
    
  }
  then_branch_ = then_branch;
  // @@protoc_insertion_point(field_set_allocated:delivery.HyperloopConditionalExpression.then_branch)
}

// .delivery.HyperloopExpression else_branch = 5 [json_name = "elseBranch"];
inline bool HyperloopConditionalExpression::_internal_has_else_branch() const {
  return this != internal_default_instance() && else_branch_ != nullptr;
}
inline bool HyperloopConditionalExpression::has_else_branch() const {
  return _internal_has_else_branch();
}
inline void HyperloopConditionalExpression::clear_else_branch() {
  if (GetArena() == nullptr && else_branch_ != nullptr) {
    delete else_branch_;
  }
  else_branch_ = nullptr;
}
inline const ::delivery::HyperloopExpression& HyperloopConditionalExpression::_internal_else_branch() const {
  const ::delivery::HyperloopExpression* p = else_branch_;
  return p != nullptr ? *p : reinterpret_cast<const ::delivery::HyperloopExpression&>(
      ::delivery::_HyperloopExpression_default_instance_);
}
inline const ::delivery::HyperloopExpression& HyperloopConditionalExpression::else_branch() const {
  // @@protoc_insertion_point(field_get:delivery.HyperloopConditionalExpression.else_branch)
  return _internal_else_branch();
}
inline void HyperloopConditionalExpression::unsafe_arena_set_allocated_else_branch(
    ::delivery::HyperloopExpression* else_branch) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(else_branch_);
  }
  else_branch_ = else_branch;
  if (else_branch) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.HyperloopConditionalExpression.else_branch)
}
inline ::delivery::HyperloopExpression* HyperloopConditionalExpression::release_else_branch() {
  
  ::delivery::HyperloopExpression* temp = else_branch_;
  else_branch_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::delivery::HyperloopExpression* HyperloopConditionalExpression::unsafe_arena_release_else_branch() {
  // @@protoc_insertion_point(field_release:delivery.HyperloopConditionalExpression.else_branch)
  
  ::delivery::HyperloopExpression* temp = else_branch_;
  else_branch_ = nullptr;
  return temp;
}
inline ::delivery::HyperloopExpression* HyperloopConditionalExpression::_internal_mutable_else_branch() {
  
  if (else_branch_ == nullptr) {
    auto* p = CreateMaybeMessage<::delivery::HyperloopExpression>(GetArena());
    else_branch_ = p;
  }
  return else_branch_;
}
inline ::delivery::HyperloopExpression* HyperloopConditionalExpression::mutable_else_branch() {
  // @@protoc_insertion_point(field_mutable:delivery.HyperloopConditionalExpression.else_branch)
  return _internal_mutable_else_branch();
}
inline void HyperloopConditionalExpression::set_allocated_else_branch(::delivery::HyperloopExpression* else_branch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete else_branch_;
  }
  if (else_branch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(else_branch);
    if (message_arena != submessage_arena) {
      else_branch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, else_branch, submessage_arena);
    }
    
  } else {
    
  }
  else_branch_ = else_branch;
  // @@protoc_insertion_point(field_set_allocated:delivery.HyperloopConditionalExpression.else_branch)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HyperloopLog

// map<uint64, .delivery.HyperloopParameterLog> parameter_logs = 1 [json_name = "parameterLogs"];
inline int HyperloopLog::_internal_parameter_logs_size() const {
  return parameter_logs_.size();
}
inline int HyperloopLog::parameter_logs_size() const {
  return _internal_parameter_logs_size();
}
inline void HyperloopLog::clear_parameter_logs() {
  parameter_logs_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::delivery::HyperloopParameterLog >&
HyperloopLog::_internal_parameter_logs() const {
  return parameter_logs_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::delivery::HyperloopParameterLog >&
HyperloopLog::parameter_logs() const {
  // @@protoc_insertion_point(field_map:delivery.HyperloopLog.parameter_logs)
  return _internal_parameter_logs();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::delivery::HyperloopParameterLog >*
HyperloopLog::_internal_mutable_parameter_logs() {
  return parameter_logs_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint64, ::delivery::HyperloopParameterLog >*
HyperloopLog::mutable_parameter_logs() {
  // @@protoc_insertion_point(field_mutable_map:delivery.HyperloopLog.parameter_logs)
  return _internal_mutable_parameter_logs();
}

// -------------------------------------------------------------------

// HyperloopParameterLog

// int32 bucket = 1 [json_name = "bucket"];
inline void HyperloopParameterLog::clear_bucket() {
  bucket_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HyperloopParameterLog::_internal_bucket() const {
  return bucket_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HyperloopParameterLog::bucket() const {
  // @@protoc_insertion_point(field_get:delivery.HyperloopParameterLog.bucket)
  return _internal_bucket();
}
inline void HyperloopParameterLog::_internal_set_bucket(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  bucket_ = value;
}
inline void HyperloopParameterLog::set_bucket(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_bucket(value);
  // @@protoc_insertion_point(field_set:delivery.HyperloopParameterLog.bucket)
}

// float value = 2 [json_name = "value"];
inline void HyperloopParameterLog::clear_value() {
  value_ = 0;
}
inline float HyperloopParameterLog::_internal_value() const {
  return value_;
}
inline float HyperloopParameterLog::value() const {
  // @@protoc_insertion_point(field_get:delivery.HyperloopParameterLog.value)
  return _internal_value();
}
inline void HyperloopParameterLog::_internal_set_value(float value) {
  
  value_ = value;
}
inline void HyperloopParameterLog::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:delivery.HyperloopParameterLog.value)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace delivery

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::delivery::BlenderArithmeticExpression_Operator> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::delivery::BlenderArithmeticExpression_Operator>() {
  return ::delivery::BlenderArithmeticExpression_Operator_descriptor();
}
template <> struct is_proto_enum< ::delivery::BlenderConditionalExpression_Operator> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::delivery::BlenderConditionalExpression_Operator>() {
  return ::delivery::BlenderConditionalExpression_Operator_descriptor();
}
template <> struct is_proto_enum< ::delivery::HyperloopConditionalExpression_Operator> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::delivery::HyperloopConditionalExpression_Operator>() {
  return ::delivery::HyperloopConditionalExpression_Operator_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_proto_2fdelivery_2fblender_2eproto
