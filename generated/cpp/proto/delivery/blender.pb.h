// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/delivery/blender.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_2fdelivery_2fblender_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_proto_2fdelivery_2fblender_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3015000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3015003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proto_2fdelivery_2fblender_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2fdelivery_2fblender_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[17]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_proto_2fdelivery_2fblender_2eproto;
::PROTOBUF_NAMESPACE_ID::Metadata descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(int index);
namespace delivery {
class BlenderConfig;
struct BlenderConfigDefaultTypeInternal;
extern BlenderConfigDefaultTypeInternal _BlenderConfig_default_instance_;
class BlenderRule;
struct BlenderRuleDefaultTypeInternal;
extern BlenderRuleDefaultTypeInternal _BlenderRule_default_instance_;
class DiversityRule;
struct DiversityRuleDefaultTypeInternal;
extern DiversityRuleDefaultTypeInternal _DiversityRule_default_instance_;
class Equal;
struct EqualDefaultTypeInternal;
extern EqualDefaultTypeInternal _Equal_default_instance_;
class EqualV2;
struct EqualV2DefaultTypeInternal;
extern EqualV2DefaultTypeInternal _EqualV2_default_instance_;
class Flag;
struct FlagDefaultTypeInternal;
extern FlagDefaultTypeInternal _Flag_default_instance_;
class GreaterThan;
struct GreaterThanDefaultTypeInternal;
extern GreaterThanDefaultTypeInternal _GreaterThan_default_instance_;
class InsertRule;
struct InsertRuleDefaultTypeInternal;
extern InsertRuleDefaultTypeInternal _InsertRule_default_instance_;
class Interval;
struct IntervalDefaultTypeInternal;
extern IntervalDefaultTypeInternal _Interval_default_instance_;
class LessThan;
struct LessThanDefaultTypeInternal;
extern LessThanDefaultTypeInternal _LessThan_default_instance_;
class NegativeRule;
struct NegativeRuleDefaultTypeInternal;
extern NegativeRuleDefaultTypeInternal _NegativeRule_default_instance_;
class PositiveRule;
struct PositiveRuleDefaultTypeInternal;
extern PositiveRuleDefaultTypeInternal _PositiveRule_default_instance_;
class QualityScoreConfig;
struct QualityScoreConfigDefaultTypeInternal;
extern QualityScoreConfigDefaultTypeInternal _QualityScoreConfig_default_instance_;
class QualityScoreTerm;
struct QualityScoreTermDefaultTypeInternal;
extern QualityScoreTermDefaultTypeInternal _QualityScoreTerm_default_instance_;
class QualityScoreTerms;
struct QualityScoreTermsDefaultTypeInternal;
extern QualityScoreTermsDefaultTypeInternal _QualityScoreTerms_default_instance_;
class StringEquality;
struct StringEqualityDefaultTypeInternal;
extern StringEqualityDefaultTypeInternal _StringEquality_default_instance_;
class TermConditionalEvaluation;
struct TermConditionalEvaluationDefaultTypeInternal;
extern TermConditionalEvaluationDefaultTypeInternal _TermConditionalEvaluation_default_instance_;
}  // namespace delivery
PROTOBUF_NAMESPACE_OPEN
template<> ::delivery::BlenderConfig* Arena::CreateMaybeMessage<::delivery::BlenderConfig>(Arena*);
template<> ::delivery::BlenderRule* Arena::CreateMaybeMessage<::delivery::BlenderRule>(Arena*);
template<> ::delivery::DiversityRule* Arena::CreateMaybeMessage<::delivery::DiversityRule>(Arena*);
template<> ::delivery::Equal* Arena::CreateMaybeMessage<::delivery::Equal>(Arena*);
template<> ::delivery::EqualV2* Arena::CreateMaybeMessage<::delivery::EqualV2>(Arena*);
template<> ::delivery::Flag* Arena::CreateMaybeMessage<::delivery::Flag>(Arena*);
template<> ::delivery::GreaterThan* Arena::CreateMaybeMessage<::delivery::GreaterThan>(Arena*);
template<> ::delivery::InsertRule* Arena::CreateMaybeMessage<::delivery::InsertRule>(Arena*);
template<> ::delivery::Interval* Arena::CreateMaybeMessage<::delivery::Interval>(Arena*);
template<> ::delivery::LessThan* Arena::CreateMaybeMessage<::delivery::LessThan>(Arena*);
template<> ::delivery::NegativeRule* Arena::CreateMaybeMessage<::delivery::NegativeRule>(Arena*);
template<> ::delivery::PositiveRule* Arena::CreateMaybeMessage<::delivery::PositiveRule>(Arena*);
template<> ::delivery::QualityScoreConfig* Arena::CreateMaybeMessage<::delivery::QualityScoreConfig>(Arena*);
template<> ::delivery::QualityScoreTerm* Arena::CreateMaybeMessage<::delivery::QualityScoreTerm>(Arena*);
template<> ::delivery::QualityScoreTerms* Arena::CreateMaybeMessage<::delivery::QualityScoreTerms>(Arena*);
template<> ::delivery::StringEquality* Arena::CreateMaybeMessage<::delivery::StringEquality>(Arena*);
template<> ::delivery::TermConditionalEvaluation* Arena::CreateMaybeMessage<::delivery::TermConditionalEvaluation>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace delivery {

enum RankingMethod : int {
  QUALITY_SCORE = 0,
  REQUEST_ORDER = 1,
  RankingMethod_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RankingMethod_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RankingMethod_IsValid(int value);
constexpr RankingMethod RankingMethod_MIN = QUALITY_SCORE;
constexpr RankingMethod RankingMethod_MAX = REQUEST_ORDER;
constexpr int RankingMethod_ARRAYSIZE = RankingMethod_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RankingMethod_descriptor();
template<typename T>
inline const std::string& RankingMethod_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RankingMethod>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RankingMethod_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RankingMethod_descriptor(), enum_t_value);
}
inline bool RankingMethod_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RankingMethod* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RankingMethod>(
    RankingMethod_descriptor(), name, value);
}
// ===================================================================

class BlenderConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.BlenderConfig) */ {
 public:
  inline BlenderConfig() : BlenderConfig(nullptr) {}
  virtual ~BlenderConfig();
  explicit constexpr BlenderConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlenderConfig(const BlenderConfig& from);
  BlenderConfig(BlenderConfig&& from) noexcept
    : BlenderConfig() {
    *this = ::std::move(from);
  }

  inline BlenderConfig& operator=(const BlenderConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlenderConfig& operator=(BlenderConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BlenderConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlenderConfig* internal_default_instance() {
    return reinterpret_cast<const BlenderConfig*>(
               &_BlenderConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(BlenderConfig& a, BlenderConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(BlenderConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlenderConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlenderConfig* New() const final {
    return CreateMaybeMessage<BlenderConfig>(nullptr);
  }

  BlenderConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlenderConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BlenderConfig& from);
  void MergeFrom(const BlenderConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlenderConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.BlenderConfig";
  }
  protected:
  explicit BlenderConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlenderRuleFieldNumber = 1,
    kQualityScoreConfigFieldNumber = 2,
  };
  // repeated .delivery.BlenderRule blender_rule = 1 [json_name = "blenderRule"];
  int blender_rule_size() const;
  private:
  int _internal_blender_rule_size() const;
  public:
  void clear_blender_rule();
  ::delivery::BlenderRule* mutable_blender_rule(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::BlenderRule >*
      mutable_blender_rule();
  private:
  const ::delivery::BlenderRule& _internal_blender_rule(int index) const;
  ::delivery::BlenderRule* _internal_add_blender_rule();
  public:
  const ::delivery::BlenderRule& blender_rule(int index) const;
  ::delivery::BlenderRule* add_blender_rule();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::BlenderRule >&
      blender_rule() const;

  // .delivery.QualityScoreConfig quality_score_config = 2 [json_name = "qualityScoreConfig"];
  bool has_quality_score_config() const;
  private:
  bool _internal_has_quality_score_config() const;
  public:
  void clear_quality_score_config();
  const ::delivery::QualityScoreConfig& quality_score_config() const;
  ::delivery::QualityScoreConfig* release_quality_score_config();
  ::delivery::QualityScoreConfig* mutable_quality_score_config();
  void set_allocated_quality_score_config(::delivery::QualityScoreConfig* quality_score_config);
  private:
  const ::delivery::QualityScoreConfig& _internal_quality_score_config() const;
  ::delivery::QualityScoreConfig* _internal_mutable_quality_score_config();
  public:
  void unsafe_arena_set_allocated_quality_score_config(
      ::delivery::QualityScoreConfig* quality_score_config);
  ::delivery::QualityScoreConfig* unsafe_arena_release_quality_score_config();

  // @@protoc_insertion_point(class_scope:delivery.BlenderConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::BlenderRule > blender_rule_;
  ::delivery::QualityScoreConfig* quality_score_config_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// -------------------------------------------------------------------

class BlenderRule PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.BlenderRule) */ {
 public:
  inline BlenderRule() : BlenderRule(nullptr) {}
  virtual ~BlenderRule();
  explicit constexpr BlenderRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlenderRule(const BlenderRule& from);
  BlenderRule(BlenderRule&& from) noexcept
    : BlenderRule() {
    *this = ::std::move(from);
  }

  inline BlenderRule& operator=(const BlenderRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlenderRule& operator=(BlenderRule&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BlenderRule& default_instance() {
    return *internal_default_instance();
  }
  enum RuleCase {
    kPositiveRule = 6,
    kInsertRule = 7,
    kNegativeRule = 8,
    kDiversityRule = 9,
    RULE_NOT_SET = 0,
  };

  enum EvalMethodCase {
    kFlag = 11,
    kGreaterThan = 13,
    kLessThan = 14,
    kInterval = 15,
    kEqualV2 = 16,
    EVAL_METHOD_NOT_SET = 0,
  };

  static inline const BlenderRule* internal_default_instance() {
    return reinterpret_cast<const BlenderRule*>(
               &_BlenderRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BlenderRule& a, BlenderRule& b) {
    a.Swap(&b);
  }
  inline void Swap(BlenderRule* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlenderRule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlenderRule* New() const final {
    return CreateMaybeMessage<BlenderRule>(nullptr);
  }

  BlenderRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlenderRule>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BlenderRule& from);
  void MergeFrom(const BlenderRule& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlenderRule* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.BlenderRule";
  }
  protected:
  explicit BlenderRule(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributeNameFieldNumber = 1,
    kPositiveRuleFieldNumber = 6,
    kInsertRuleFieldNumber = 7,
    kNegativeRuleFieldNumber = 8,
    kDiversityRuleFieldNumber = 9,
    kFlagFieldNumber = 11,
    kGreaterThanFieldNumber = 13,
    kLessThanFieldNumber = 14,
    kIntervalFieldNumber = 15,
    kEqualV2FieldNumber = 16,
  };
  // string attribute_name = 1 [json_name = "attributeName"];
  void clear_attribute_name();
  const std::string& attribute_name() const;
  void set_attribute_name(const std::string& value);
  void set_attribute_name(std::string&& value);
  void set_attribute_name(const char* value);
  void set_attribute_name(const char* value, size_t size);
  std::string* mutable_attribute_name();
  std::string* release_attribute_name();
  void set_allocated_attribute_name(std::string* attribute_name);
  private:
  const std::string& _internal_attribute_name() const;
  void _internal_set_attribute_name(const std::string& value);
  std::string* _internal_mutable_attribute_name();
  public:

  // .delivery.PositiveRule positive_rule = 6 [json_name = "positiveRule"];
  bool has_positive_rule() const;
  private:
  bool _internal_has_positive_rule() const;
  public:
  void clear_positive_rule();
  const ::delivery::PositiveRule& positive_rule() const;
  ::delivery::PositiveRule* release_positive_rule();
  ::delivery::PositiveRule* mutable_positive_rule();
  void set_allocated_positive_rule(::delivery::PositiveRule* positive_rule);
  private:
  const ::delivery::PositiveRule& _internal_positive_rule() const;
  ::delivery::PositiveRule* _internal_mutable_positive_rule();
  public:
  void unsafe_arena_set_allocated_positive_rule(
      ::delivery::PositiveRule* positive_rule);
  ::delivery::PositiveRule* unsafe_arena_release_positive_rule();

  // .delivery.InsertRule insert_rule = 7 [json_name = "insertRule"];
  bool has_insert_rule() const;
  private:
  bool _internal_has_insert_rule() const;
  public:
  void clear_insert_rule();
  const ::delivery::InsertRule& insert_rule() const;
  ::delivery::InsertRule* release_insert_rule();
  ::delivery::InsertRule* mutable_insert_rule();
  void set_allocated_insert_rule(::delivery::InsertRule* insert_rule);
  private:
  const ::delivery::InsertRule& _internal_insert_rule() const;
  ::delivery::InsertRule* _internal_mutable_insert_rule();
  public:
  void unsafe_arena_set_allocated_insert_rule(
      ::delivery::InsertRule* insert_rule);
  ::delivery::InsertRule* unsafe_arena_release_insert_rule();

  // .delivery.NegativeRule negative_rule = 8 [json_name = "negativeRule"];
  bool has_negative_rule() const;
  private:
  bool _internal_has_negative_rule() const;
  public:
  void clear_negative_rule();
  const ::delivery::NegativeRule& negative_rule() const;
  ::delivery::NegativeRule* release_negative_rule();
  ::delivery::NegativeRule* mutable_negative_rule();
  void set_allocated_negative_rule(::delivery::NegativeRule* negative_rule);
  private:
  const ::delivery::NegativeRule& _internal_negative_rule() const;
  ::delivery::NegativeRule* _internal_mutable_negative_rule();
  public:
  void unsafe_arena_set_allocated_negative_rule(
      ::delivery::NegativeRule* negative_rule);
  ::delivery::NegativeRule* unsafe_arena_release_negative_rule();

  // .delivery.DiversityRule diversity_rule = 9 [json_name = "diversityRule"];
  bool has_diversity_rule() const;
  private:
  bool _internal_has_diversity_rule() const;
  public:
  void clear_diversity_rule();
  const ::delivery::DiversityRule& diversity_rule() const;
  ::delivery::DiversityRule* release_diversity_rule();
  ::delivery::DiversityRule* mutable_diversity_rule();
  void set_allocated_diversity_rule(::delivery::DiversityRule* diversity_rule);
  private:
  const ::delivery::DiversityRule& _internal_diversity_rule() const;
  ::delivery::DiversityRule* _internal_mutable_diversity_rule();
  public:
  void unsafe_arena_set_allocated_diversity_rule(
      ::delivery::DiversityRule* diversity_rule);
  ::delivery::DiversityRule* unsafe_arena_release_diversity_rule();

  // .delivery.Flag flag = 11 [json_name = "flag"];
  bool has_flag() const;
  private:
  bool _internal_has_flag() const;
  public:
  void clear_flag();
  const ::delivery::Flag& flag() const;
  ::delivery::Flag* release_flag();
  ::delivery::Flag* mutable_flag();
  void set_allocated_flag(::delivery::Flag* flag);
  private:
  const ::delivery::Flag& _internal_flag() const;
  ::delivery::Flag* _internal_mutable_flag();
  public:
  void unsafe_arena_set_allocated_flag(
      ::delivery::Flag* flag);
  ::delivery::Flag* unsafe_arena_release_flag();

  // .delivery.GreaterThan greater_than = 13 [json_name = "greaterThan"];
  bool has_greater_than() const;
  private:
  bool _internal_has_greater_than() const;
  public:
  void clear_greater_than();
  const ::delivery::GreaterThan& greater_than() const;
  ::delivery::GreaterThan* release_greater_than();
  ::delivery::GreaterThan* mutable_greater_than();
  void set_allocated_greater_than(::delivery::GreaterThan* greater_than);
  private:
  const ::delivery::GreaterThan& _internal_greater_than() const;
  ::delivery::GreaterThan* _internal_mutable_greater_than();
  public:
  void unsafe_arena_set_allocated_greater_than(
      ::delivery::GreaterThan* greater_than);
  ::delivery::GreaterThan* unsafe_arena_release_greater_than();

  // .delivery.LessThan less_than = 14 [json_name = "lessThan"];
  bool has_less_than() const;
  private:
  bool _internal_has_less_than() const;
  public:
  void clear_less_than();
  const ::delivery::LessThan& less_than() const;
  ::delivery::LessThan* release_less_than();
  ::delivery::LessThan* mutable_less_than();
  void set_allocated_less_than(::delivery::LessThan* less_than);
  private:
  const ::delivery::LessThan& _internal_less_than() const;
  ::delivery::LessThan* _internal_mutable_less_than();
  public:
  void unsafe_arena_set_allocated_less_than(
      ::delivery::LessThan* less_than);
  ::delivery::LessThan* unsafe_arena_release_less_than();

  // .delivery.Interval interval = 15 [json_name = "interval"];
  bool has_interval() const;
  private:
  bool _internal_has_interval() const;
  public:
  void clear_interval();
  const ::delivery::Interval& interval() const;
  ::delivery::Interval* release_interval();
  ::delivery::Interval* mutable_interval();
  void set_allocated_interval(::delivery::Interval* interval);
  private:
  const ::delivery::Interval& _internal_interval() const;
  ::delivery::Interval* _internal_mutable_interval();
  public:
  void unsafe_arena_set_allocated_interval(
      ::delivery::Interval* interval);
  ::delivery::Interval* unsafe_arena_release_interval();

  // .delivery.EqualV2 equal_v2 = 16 [json_name = "equalV2"];
  bool has_equal_v2() const;
  private:
  bool _internal_has_equal_v2() const;
  public:
  void clear_equal_v2();
  const ::delivery::EqualV2& equal_v2() const;
  ::delivery::EqualV2* release_equal_v2();
  ::delivery::EqualV2* mutable_equal_v2();
  void set_allocated_equal_v2(::delivery::EqualV2* equal_v2);
  private:
  const ::delivery::EqualV2& _internal_equal_v2() const;
  ::delivery::EqualV2* _internal_mutable_equal_v2();
  public:
  void unsafe_arena_set_allocated_equal_v2(
      ::delivery::EqualV2* equal_v2);
  ::delivery::EqualV2* unsafe_arena_release_equal_v2();

  void clear_rule();
  RuleCase rule_case() const;
  void clear_eval_method();
  EvalMethodCase eval_method_case() const;
  // @@protoc_insertion_point(class_scope:delivery.BlenderRule)
 private:
  class _Internal;
  void set_has_positive_rule();
  void set_has_insert_rule();
  void set_has_negative_rule();
  void set_has_diversity_rule();
  void set_has_flag();
  void set_has_greater_than();
  void set_has_less_than();
  void set_has_interval();
  void set_has_equal_v2();

  inline bool has_rule() const;
  inline void clear_has_rule();

  inline bool has_eval_method() const;
  inline void clear_has_eval_method();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attribute_name_;
  union RuleUnion {
    constexpr RuleUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::delivery::PositiveRule* positive_rule_;
    ::delivery::InsertRule* insert_rule_;
    ::delivery::NegativeRule* negative_rule_;
    ::delivery::DiversityRule* diversity_rule_;
  } rule_;
  union EvalMethodUnion {
    constexpr EvalMethodUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::delivery::Flag* flag_;
    ::delivery::GreaterThan* greater_than_;
    ::delivery::LessThan* less_than_;
    ::delivery::Interval* interval_;
    ::delivery::EqualV2* equal_v2_;
  } eval_method_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[2];

  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// -------------------------------------------------------------------

class Flag PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.Flag) */ {
 public:
  inline Flag() : Flag(nullptr) {}
  virtual ~Flag();
  explicit constexpr Flag(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Flag(const Flag& from);
  Flag(Flag&& from) noexcept
    : Flag() {
    *this = ::std::move(from);
  }

  inline Flag& operator=(const Flag& from) {
    CopyFrom(from);
    return *this;
  }
  inline Flag& operator=(Flag&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Flag& default_instance() {
    return *internal_default_instance();
  }
  static inline const Flag* internal_default_instance() {
    return reinterpret_cast<const Flag*>(
               &_Flag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Flag& a, Flag& b) {
    a.Swap(&b);
  }
  inline void Swap(Flag* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Flag* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Flag* New() const final {
    return CreateMaybeMessage<Flag>(nullptr);
  }

  Flag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Flag>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Flag& from);
  void MergeFrom(const Flag& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Flag* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.Flag";
  }
  protected:
  explicit Flag(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIgnoredFieldNumber = 1,
  };
  // bool ignored = 1 [json_name = "ignored", deprecated = true];
  PROTOBUF_DEPRECATED bool has_ignored() const;
  private:
  bool _internal_has_ignored() const;
  public:
  PROTOBUF_DEPRECATED void clear_ignored();
  PROTOBUF_DEPRECATED bool ignored() const;
  PROTOBUF_DEPRECATED void set_ignored(bool value);
  private:
  bool _internal_ignored() const;
  void _internal_set_ignored(bool value);
  public:

  // @@protoc_insertion_point(class_scope:delivery.Flag)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool ignored_;
  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// -------------------------------------------------------------------

class EqualV2 PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.EqualV2) */ {
 public:
  inline EqualV2() : EqualV2(nullptr) {}
  virtual ~EqualV2();
  explicit constexpr EqualV2(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EqualV2(const EqualV2& from);
  EqualV2(EqualV2&& from) noexcept
    : EqualV2() {
    *this = ::std::move(from);
  }

  inline EqualV2& operator=(const EqualV2& from) {
    CopyFrom(from);
    return *this;
  }
  inline EqualV2& operator=(EqualV2&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EqualV2& default_instance() {
    return *internal_default_instance();
  }
  enum EqualityTypeCase {
    kNumber = 1,
    kStringEquality = 2,
    EQUALITY_TYPE_NOT_SET = 0,
  };

  static inline const EqualV2* internal_default_instance() {
    return reinterpret_cast<const EqualV2*>(
               &_EqualV2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(EqualV2& a, EqualV2& b) {
    a.Swap(&b);
  }
  inline void Swap(EqualV2* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EqualV2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EqualV2* New() const final {
    return CreateMaybeMessage<EqualV2>(nullptr);
  }

  EqualV2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EqualV2>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EqualV2& from);
  void MergeFrom(const EqualV2& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EqualV2* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.EqualV2";
  }
  protected:
  explicit EqualV2(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumberFieldNumber = 1,
    kStringEqualityFieldNumber = 2,
  };
  // .delivery.Equal number = 1 [json_name = "number"];
  bool has_number() const;
  private:
  bool _internal_has_number() const;
  public:
  void clear_number();
  const ::delivery::Equal& number() const;
  ::delivery::Equal* release_number();
  ::delivery::Equal* mutable_number();
  void set_allocated_number(::delivery::Equal* number);
  private:
  const ::delivery::Equal& _internal_number() const;
  ::delivery::Equal* _internal_mutable_number();
  public:
  void unsafe_arena_set_allocated_number(
      ::delivery::Equal* number);
  ::delivery::Equal* unsafe_arena_release_number();

  // .delivery.StringEquality string_equality = 2 [json_name = "stringEquality"];
  bool has_string_equality() const;
  private:
  bool _internal_has_string_equality() const;
  public:
  void clear_string_equality();
  const ::delivery::StringEquality& string_equality() const;
  ::delivery::StringEquality* release_string_equality();
  ::delivery::StringEquality* mutable_string_equality();
  void set_allocated_string_equality(::delivery::StringEquality* string_equality);
  private:
  const ::delivery::StringEquality& _internal_string_equality() const;
  ::delivery::StringEquality* _internal_mutable_string_equality();
  public:
  void unsafe_arena_set_allocated_string_equality(
      ::delivery::StringEquality* string_equality);
  ::delivery::StringEquality* unsafe_arena_release_string_equality();

  void clear_equality_type();
  EqualityTypeCase equality_type_case() const;
  // @@protoc_insertion_point(class_scope:delivery.EqualV2)
 private:
  class _Internal;
  void set_has_number();
  void set_has_string_equality();

  inline bool has_equality_type() const;
  inline void clear_has_equality_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union EqualityTypeUnion {
    constexpr EqualityTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::delivery::Equal* number_;
    ::delivery::StringEquality* string_equality_;
  } equality_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// -------------------------------------------------------------------

class Equal PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.Equal) */ {
 public:
  inline Equal() : Equal(nullptr) {}
  virtual ~Equal();
  explicit constexpr Equal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Equal(const Equal& from);
  Equal(Equal&& from) noexcept
    : Equal() {
    *this = ::std::move(from);
  }

  inline Equal& operator=(const Equal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Equal& operator=(Equal&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Equal& default_instance() {
    return *internal_default_instance();
  }
  static inline const Equal* internal_default_instance() {
    return reinterpret_cast<const Equal*>(
               &_Equal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Equal& a, Equal& b) {
    a.Swap(&b);
  }
  inline void Swap(Equal* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Equal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Equal* New() const final {
    return CreateMaybeMessage<Equal>(nullptr);
  }

  Equal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Equal>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Equal& from);
  void MergeFrom(const Equal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Equal* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.Equal";
  }
  protected:
  explicit Equal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kComparedToFieldNumber = 1,
    kToleranceFieldNumber = 2,
  };
  // float compared_to = 1 [json_name = "comparedTo"];
  void clear_compared_to();
  float compared_to() const;
  void set_compared_to(float value);
  private:
  float _internal_compared_to() const;
  void _internal_set_compared_to(float value);
  public:

  // float tolerance = 2 [json_name = "tolerance"];
  void clear_tolerance();
  float tolerance() const;
  void set_tolerance(float value);
  private:
  float _internal_tolerance() const;
  void _internal_set_tolerance(float value);
  public:

  // @@protoc_insertion_point(class_scope:delivery.Equal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float compared_to_;
  float tolerance_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// -------------------------------------------------------------------

class StringEquality PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.StringEquality) */ {
 public:
  inline StringEquality() : StringEquality(nullptr) {}
  virtual ~StringEquality();
  explicit constexpr StringEquality(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StringEquality(const StringEquality& from);
  StringEquality(StringEquality&& from) noexcept
    : StringEquality() {
    *this = ::std::move(from);
  }

  inline StringEquality& operator=(const StringEquality& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringEquality& operator=(StringEquality&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StringEquality& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kRaw = 1,
    VALUE_NOT_SET = 0,
  };

  static inline const StringEquality* internal_default_instance() {
    return reinterpret_cast<const StringEquality*>(
               &_StringEquality_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(StringEquality& a, StringEquality& b) {
    a.Swap(&b);
  }
  inline void Swap(StringEquality* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringEquality* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StringEquality* New() const final {
    return CreateMaybeMessage<StringEquality>(nullptr);
  }

  StringEquality* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StringEquality>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StringEquality& from);
  void MergeFrom(const StringEquality& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringEquality* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.StringEquality";
  }
  protected:
  explicit StringEquality(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRawFieldNumber = 1,
  };
  // string raw = 1 [json_name = "raw"];
  bool has_raw() const;
  private:
  bool _internal_has_raw() const;
  public:
  void clear_raw();
  const std::string& raw() const;
  void set_raw(const std::string& value);
  void set_raw(std::string&& value);
  void set_raw(const char* value);
  void set_raw(const char* value, size_t size);
  std::string* mutable_raw();
  std::string* release_raw();
  void set_allocated_raw(std::string* raw);
  private:
  const std::string& _internal_raw() const;
  void _internal_set_raw(const std::string& value);
  std::string* _internal_mutable_raw();
  public:

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:delivery.StringEquality)
 private:
  class _Internal;
  void set_has_raw();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ValueUnion {
    constexpr ValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr raw_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// -------------------------------------------------------------------

class GreaterThan PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.GreaterThan) */ {
 public:
  inline GreaterThan() : GreaterThan(nullptr) {}
  virtual ~GreaterThan();
  explicit constexpr GreaterThan(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GreaterThan(const GreaterThan& from);
  GreaterThan(GreaterThan&& from) noexcept
    : GreaterThan() {
    *this = ::std::move(from);
  }

  inline GreaterThan& operator=(const GreaterThan& from) {
    CopyFrom(from);
    return *this;
  }
  inline GreaterThan& operator=(GreaterThan&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GreaterThan& default_instance() {
    return *internal_default_instance();
  }
  static inline const GreaterThan* internal_default_instance() {
    return reinterpret_cast<const GreaterThan*>(
               &_GreaterThan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GreaterThan& a, GreaterThan& b) {
    a.Swap(&b);
  }
  inline void Swap(GreaterThan* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GreaterThan* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GreaterThan* New() const final {
    return CreateMaybeMessage<GreaterThan>(nullptr);
  }

  GreaterThan* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GreaterThan>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GreaterThan& from);
  void MergeFrom(const GreaterThan& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GreaterThan* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.GreaterThan";
  }
  protected:
  explicit GreaterThan(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kComparedToFieldNumber = 1,
    kOrEqualFieldNumber = 2,
  };
  // float compared_to = 1 [json_name = "comparedTo"];
  void clear_compared_to();
  float compared_to() const;
  void set_compared_to(float value);
  private:
  float _internal_compared_to() const;
  void _internal_set_compared_to(float value);
  public:

  // bool or_equal = 2 [json_name = "orEqual"];
  void clear_or_equal();
  bool or_equal() const;
  void set_or_equal(bool value);
  private:
  bool _internal_or_equal() const;
  void _internal_set_or_equal(bool value);
  public:

  // @@protoc_insertion_point(class_scope:delivery.GreaterThan)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float compared_to_;
  bool or_equal_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// -------------------------------------------------------------------

class LessThan PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.LessThan) */ {
 public:
  inline LessThan() : LessThan(nullptr) {}
  virtual ~LessThan();
  explicit constexpr LessThan(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LessThan(const LessThan& from);
  LessThan(LessThan&& from) noexcept
    : LessThan() {
    *this = ::std::move(from);
  }

  inline LessThan& operator=(const LessThan& from) {
    CopyFrom(from);
    return *this;
  }
  inline LessThan& operator=(LessThan&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LessThan& default_instance() {
    return *internal_default_instance();
  }
  static inline const LessThan* internal_default_instance() {
    return reinterpret_cast<const LessThan*>(
               &_LessThan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LessThan& a, LessThan& b) {
    a.Swap(&b);
  }
  inline void Swap(LessThan* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LessThan* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LessThan* New() const final {
    return CreateMaybeMessage<LessThan>(nullptr);
  }

  LessThan* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LessThan>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LessThan& from);
  void MergeFrom(const LessThan& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LessThan* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.LessThan";
  }
  protected:
  explicit LessThan(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kComparedToFieldNumber = 1,
    kOrEqualFieldNumber = 2,
  };
  // float compared_to = 1 [json_name = "comparedTo"];
  void clear_compared_to();
  float compared_to() const;
  void set_compared_to(float value);
  private:
  float _internal_compared_to() const;
  void _internal_set_compared_to(float value);
  public:

  // bool or_equal = 2 [json_name = "orEqual"];
  void clear_or_equal();
  bool or_equal() const;
  void set_or_equal(bool value);
  private:
  bool _internal_or_equal() const;
  void _internal_set_or_equal(bool value);
  public:

  // @@protoc_insertion_point(class_scope:delivery.LessThan)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float compared_to_;
  bool or_equal_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// -------------------------------------------------------------------

class Interval PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.Interval) */ {
 public:
  inline Interval() : Interval(nullptr) {}
  virtual ~Interval();
  explicit constexpr Interval(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Interval(const Interval& from);
  Interval(Interval&& from) noexcept
    : Interval() {
    *this = ::std::move(from);
  }

  inline Interval& operator=(const Interval& from) {
    CopyFrom(from);
    return *this;
  }
  inline Interval& operator=(Interval&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Interval& default_instance() {
    return *internal_default_instance();
  }
  static inline const Interval* internal_default_instance() {
    return reinterpret_cast<const Interval*>(
               &_Interval_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Interval& a, Interval& b) {
    a.Swap(&b);
  }
  inline void Swap(Interval* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Interval* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Interval* New() const final {
    return CreateMaybeMessage<Interval>(nullptr);
  }

  Interval* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Interval>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Interval& from);
  void MergeFrom(const Interval& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Interval* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.Interval";
  }
  protected:
  explicit Interval(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUpperBoundFieldNumber = 1,
    kLowerBoundFieldNumber = 2,
    kLowerInclusiveFieldNumber = 3,
    kUpperInclusiveFieldNumber = 4,
  };
  // float upper_bound = 1 [json_name = "upperBound"];
  void clear_upper_bound();
  float upper_bound() const;
  void set_upper_bound(float value);
  private:
  float _internal_upper_bound() const;
  void _internal_set_upper_bound(float value);
  public:

  // float lower_bound = 2 [json_name = "lowerBound"];
  void clear_lower_bound();
  float lower_bound() const;
  void set_lower_bound(float value);
  private:
  float _internal_lower_bound() const;
  void _internal_set_lower_bound(float value);
  public:

  // bool lower_inclusive = 3 [json_name = "lowerInclusive"];
  void clear_lower_inclusive();
  bool lower_inclusive() const;
  void set_lower_inclusive(bool value);
  private:
  bool _internal_lower_inclusive() const;
  void _internal_set_lower_inclusive(bool value);
  public:

  // bool upper_inclusive = 4 [json_name = "upperInclusive"];
  void clear_upper_inclusive();
  bool upper_inclusive() const;
  void set_upper_inclusive(bool value);
  private:
  bool _internal_upper_inclusive() const;
  void _internal_set_upper_inclusive(bool value);
  public:

  // @@protoc_insertion_point(class_scope:delivery.Interval)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float upper_bound_;
  float lower_bound_;
  bool lower_inclusive_;
  bool upper_inclusive_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// -------------------------------------------------------------------

class PositiveRule PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.PositiveRule) */ {
 public:
  inline PositiveRule() : PositiveRule(nullptr) {}
  virtual ~PositiveRule();
  explicit constexpr PositiveRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PositiveRule(const PositiveRule& from);
  PositiveRule(PositiveRule&& from) noexcept
    : PositiveRule() {
    *this = ::std::move(from);
  }

  inline PositiveRule& operator=(const PositiveRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositiveRule& operator=(PositiveRule&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PositiveRule& default_instance() {
    return *internal_default_instance();
  }
  static inline const PositiveRule* internal_default_instance() {
    return reinterpret_cast<const PositiveRule*>(
               &_PositiveRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PositiveRule& a, PositiveRule& b) {
    a.Swap(&b);
  }
  inline void Swap(PositiveRule* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PositiveRule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PositiveRule* New() const final {
    return CreateMaybeMessage<PositiveRule>(nullptr);
  }

  PositiveRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PositiveRule>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PositiveRule& from);
  void MergeFrom(const PositiveRule& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PositiveRule* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.PositiveRule";
  }
  protected:
  explicit PositiveRule(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSelectPctFieldNumber = 1,
    kMinPosFieldNumber = 2,
    kMaxPosFieldNumber = 3,
  };
  // double select_pct = 1 [json_name = "selectPct"];
  bool has_select_pct() const;
  private:
  bool _internal_has_select_pct() const;
  public:
  void clear_select_pct();
  double select_pct() const;
  void set_select_pct(double value);
  private:
  double _internal_select_pct() const;
  void _internal_set_select_pct(double value);
  public:

  // uint64 min_pos = 2 [json_name = "minPos"];
  bool has_min_pos() const;
  private:
  bool _internal_has_min_pos() const;
  public:
  void clear_min_pos();
  ::PROTOBUF_NAMESPACE_ID::uint64 min_pos() const;
  void set_min_pos(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_min_pos() const;
  void _internal_set_min_pos(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 max_pos = 3 [json_name = "maxPos"];
  bool has_max_pos() const;
  private:
  bool _internal_has_max_pos() const;
  public:
  void clear_max_pos();
  ::PROTOBUF_NAMESPACE_ID::uint64 max_pos() const;
  void set_max_pos(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_max_pos() const;
  void _internal_set_max_pos(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:delivery.PositiveRule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double select_pct_;
  ::PROTOBUF_NAMESPACE_ID::uint64 min_pos_;
  ::PROTOBUF_NAMESPACE_ID::uint64 max_pos_;
  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// -------------------------------------------------------------------

class InsertRule PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.InsertRule) */ {
 public:
  inline InsertRule() : InsertRule(nullptr) {}
  virtual ~InsertRule();
  explicit constexpr InsertRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertRule(const InsertRule& from);
  InsertRule(InsertRule&& from) noexcept
    : InsertRule() {
    *this = ::std::move(from);
  }

  inline InsertRule& operator=(const InsertRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertRule& operator=(InsertRule&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InsertRule& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertRule* internal_default_instance() {
    return reinterpret_cast<const InsertRule*>(
               &_InsertRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(InsertRule& a, InsertRule& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertRule* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertRule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InsertRule* New() const final {
    return CreateMaybeMessage<InsertRule>(nullptr);
  }

  InsertRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InsertRule>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InsertRule& from);
  void MergeFrom(const InsertRule& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertRule* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.InsertRule";
  }
  protected:
  explicit InsertRule(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSelectPctFieldNumber = 1,
    kMinPosFieldNumber = 2,
    kMaxPosFieldNumber = 3,
    kAppliesToAllInsertionsFieldNumber = 5,
    kRankingMethodFieldNumber = 6,
  };
  // double select_pct = 1 [json_name = "selectPct"];
  bool has_select_pct() const;
  private:
  bool _internal_has_select_pct() const;
  public:
  void clear_select_pct();
  double select_pct() const;
  void set_select_pct(double value);
  private:
  double _internal_select_pct() const;
  void _internal_set_select_pct(double value);
  public:

  // uint64 min_pos = 2 [json_name = "minPos"];
  bool has_min_pos() const;
  private:
  bool _internal_has_min_pos() const;
  public:
  void clear_min_pos();
  ::PROTOBUF_NAMESPACE_ID::uint64 min_pos() const;
  void set_min_pos(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_min_pos() const;
  void _internal_set_min_pos(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 max_pos = 3 [json_name = "maxPos"];
  bool has_max_pos() const;
  private:
  bool _internal_has_max_pos() const;
  public:
  void clear_max_pos();
  ::PROTOBUF_NAMESPACE_ID::uint64 max_pos() const;
  void set_max_pos(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_max_pos() const;
  void _internal_set_max_pos(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // bool applies_to_all_insertions = 5 [json_name = "appliesToAllInsertions"];
  void clear_applies_to_all_insertions();
  bool applies_to_all_insertions() const;
  void set_applies_to_all_insertions(bool value);
  private:
  bool _internal_applies_to_all_insertions() const;
  void _internal_set_applies_to_all_insertions(bool value);
  public:

  // .delivery.RankingMethod ranking_method = 6 [json_name = "rankingMethod"];
  void clear_ranking_method();
  ::delivery::RankingMethod ranking_method() const;
  void set_ranking_method(::delivery::RankingMethod value);
  private:
  ::delivery::RankingMethod _internal_ranking_method() const;
  void _internal_set_ranking_method(::delivery::RankingMethod value);
  public:

  // @@protoc_insertion_point(class_scope:delivery.InsertRule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double select_pct_;
  ::PROTOBUF_NAMESPACE_ID::uint64 min_pos_;
  ::PROTOBUF_NAMESPACE_ID::uint64 max_pos_;
  bool applies_to_all_insertions_;
  int ranking_method_;
  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// -------------------------------------------------------------------

class NegativeRule PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.NegativeRule) */ {
 public:
  inline NegativeRule() : NegativeRule(nullptr) {}
  virtual ~NegativeRule();
  explicit constexpr NegativeRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NegativeRule(const NegativeRule& from);
  NegativeRule(NegativeRule&& from) noexcept
    : NegativeRule() {
    *this = ::std::move(from);
  }

  inline NegativeRule& operator=(const NegativeRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline NegativeRule& operator=(NegativeRule&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NegativeRule& default_instance() {
    return *internal_default_instance();
  }
  static inline const NegativeRule* internal_default_instance() {
    return reinterpret_cast<const NegativeRule*>(
               &_NegativeRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(NegativeRule& a, NegativeRule& b) {
    a.Swap(&b);
  }
  inline void Swap(NegativeRule* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NegativeRule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NegativeRule* New() const final {
    return CreateMaybeMessage<NegativeRule>(nullptr);
  }

  NegativeRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NegativeRule>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NegativeRule& from);
  void MergeFrom(const NegativeRule& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NegativeRule* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.NegativeRule";
  }
  protected:
  explicit NegativeRule(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPluckPctFieldNumber = 1,
    kForbidLessPosFieldNumber = 2,
    kMinSpacingFieldNumber = 3,
    kForbidGreaterPosFieldNumber = 4,
    kMaxCountFieldNumber = 5,
  };
  // double pluck_pct = 1 [json_name = "pluckPct"];
  bool has_pluck_pct() const;
  private:
  bool _internal_has_pluck_pct() const;
  public:
  void clear_pluck_pct();
  double pluck_pct() const;
  void set_pluck_pct(double value);
  private:
  double _internal_pluck_pct() const;
  void _internal_set_pluck_pct(double value);
  public:

  // uint64 forbid_less_pos = 2 [json_name = "forbidLessPos"];
  bool has_forbid_less_pos() const;
  private:
  bool _internal_has_forbid_less_pos() const;
  public:
  void clear_forbid_less_pos();
  ::PROTOBUF_NAMESPACE_ID::uint64 forbid_less_pos() const;
  void set_forbid_less_pos(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_forbid_less_pos() const;
  void _internal_set_forbid_less_pos(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 min_spacing = 3 [json_name = "minSpacing"];
  bool has_min_spacing() const;
  private:
  bool _internal_has_min_spacing() const;
  public:
  void clear_min_spacing();
  ::PROTOBUF_NAMESPACE_ID::uint64 min_spacing() const;
  void set_min_spacing(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_min_spacing() const;
  void _internal_set_min_spacing(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 forbid_greater_pos = 4 [json_name = "forbidGreaterPos"];
  bool has_forbid_greater_pos() const;
  private:
  bool _internal_has_forbid_greater_pos() const;
  public:
  void clear_forbid_greater_pos();
  ::PROTOBUF_NAMESPACE_ID::uint64 forbid_greater_pos() const;
  void set_forbid_greater_pos(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_forbid_greater_pos() const;
  void _internal_set_forbid_greater_pos(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 max_count = 5 [json_name = "maxCount"];
  bool has_max_count() const;
  private:
  bool _internal_has_max_count() const;
  public:
  void clear_max_count();
  ::PROTOBUF_NAMESPACE_ID::uint64 max_count() const;
  void set_max_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_max_count() const;
  void _internal_set_max_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:delivery.NegativeRule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double pluck_pct_;
  ::PROTOBUF_NAMESPACE_ID::uint64 forbid_less_pos_;
  ::PROTOBUF_NAMESPACE_ID::uint64 min_spacing_;
  ::PROTOBUF_NAMESPACE_ID::uint64 forbid_greater_pos_;
  ::PROTOBUF_NAMESPACE_ID::uint64 max_count_;
  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// -------------------------------------------------------------------

class DiversityRule PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.DiversityRule) */ {
 public:
  inline DiversityRule() : DiversityRule(nullptr) {}
  virtual ~DiversityRule();
  explicit constexpr DiversityRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DiversityRule(const DiversityRule& from);
  DiversityRule(DiversityRule&& from) noexcept
    : DiversityRule() {
    *this = ::std::move(from);
  }

  inline DiversityRule& operator=(const DiversityRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiversityRule& operator=(DiversityRule&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DiversityRule& default_instance() {
    return *internal_default_instance();
  }
  static inline const DiversityRule* internal_default_instance() {
    return reinterpret_cast<const DiversityRule*>(
               &_DiversityRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DiversityRule& a, DiversityRule& b) {
    a.Swap(&b);
  }
  inline void Swap(DiversityRule* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiversityRule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DiversityRule* New() const final {
    return CreateMaybeMessage<DiversityRule>(nullptr);
  }

  DiversityRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DiversityRule>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DiversityRule& from);
  void MergeFrom(const DiversityRule& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DiversityRule* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.DiversityRule";
  }
  protected:
  explicit DiversityRule(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMultiFieldNumber = 1,
  };
  // double multi = 1 [json_name = "multi"];
  bool has_multi() const;
  private:
  bool _internal_has_multi() const;
  public:
  void clear_multi();
  double multi() const;
  void set_multi(double value);
  private:
  double _internal_multi() const;
  void _internal_set_multi(double value);
  public:

  // @@protoc_insertion_point(class_scope:delivery.DiversityRule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double multi_;
  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// -------------------------------------------------------------------

class QualityScoreConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.QualityScoreConfig) */ {
 public:
  inline QualityScoreConfig() : QualityScoreConfig(nullptr) {}
  virtual ~QualityScoreConfig();
  explicit constexpr QualityScoreConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QualityScoreConfig(const QualityScoreConfig& from);
  QualityScoreConfig(QualityScoreConfig&& from) noexcept
    : QualityScoreConfig() {
    *this = ::std::move(from);
  }

  inline QualityScoreConfig& operator=(const QualityScoreConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline QualityScoreConfig& operator=(QualityScoreConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const QualityScoreConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const QualityScoreConfig* internal_default_instance() {
    return reinterpret_cast<const QualityScoreConfig*>(
               &_QualityScoreConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(QualityScoreConfig& a, QualityScoreConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(QualityScoreConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QualityScoreConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline QualityScoreConfig* New() const final {
    return CreateMaybeMessage<QualityScoreConfig>(nullptr);
  }

  QualityScoreConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QualityScoreConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const QualityScoreConfig& from);
  void MergeFrom(const QualityScoreConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QualityScoreConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.QualityScoreConfig";
  }
  protected:
  explicit QualityScoreConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWeightedSumTermFieldNumber = 1,
  };
  // repeated .delivery.QualityScoreTerm weighted_sum_term = 1 [json_name = "weightedSumTerm"];
  int weighted_sum_term_size() const;
  private:
  int _internal_weighted_sum_term_size() const;
  public:
  void clear_weighted_sum_term();
  ::delivery::QualityScoreTerm* mutable_weighted_sum_term(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::QualityScoreTerm >*
      mutable_weighted_sum_term();
  private:
  const ::delivery::QualityScoreTerm& _internal_weighted_sum_term(int index) const;
  ::delivery::QualityScoreTerm* _internal_add_weighted_sum_term();
  public:
  const ::delivery::QualityScoreTerm& weighted_sum_term(int index) const;
  ::delivery::QualityScoreTerm* add_weighted_sum_term();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::QualityScoreTerm >&
      weighted_sum_term() const;

  // @@protoc_insertion_point(class_scope:delivery.QualityScoreConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::QualityScoreTerm > weighted_sum_term_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// -------------------------------------------------------------------

class QualityScoreTerms PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.QualityScoreTerms) */ {
 public:
  inline QualityScoreTerms() : QualityScoreTerms(nullptr) {}
  virtual ~QualityScoreTerms();
  explicit constexpr QualityScoreTerms(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QualityScoreTerms(const QualityScoreTerms& from);
  QualityScoreTerms(QualityScoreTerms&& from) noexcept
    : QualityScoreTerms() {
    *this = ::std::move(from);
  }

  inline QualityScoreTerms& operator=(const QualityScoreTerms& from) {
    CopyFrom(from);
    return *this;
  }
  inline QualityScoreTerms& operator=(QualityScoreTerms&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const QualityScoreTerms& default_instance() {
    return *internal_default_instance();
  }
  static inline const QualityScoreTerms* internal_default_instance() {
    return reinterpret_cast<const QualityScoreTerms*>(
               &_QualityScoreTerms_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(QualityScoreTerms& a, QualityScoreTerms& b) {
    a.Swap(&b);
  }
  inline void Swap(QualityScoreTerms* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QualityScoreTerms* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline QualityScoreTerms* New() const final {
    return CreateMaybeMessage<QualityScoreTerms>(nullptr);
  }

  QualityScoreTerms* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QualityScoreTerms>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const QualityScoreTerms& from);
  void MergeFrom(const QualityScoreTerms& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QualityScoreTerms* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.QualityScoreTerms";
  }
  protected:
  explicit QualityScoreTerms(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQualityScoreTermsFieldNumber = 1,
  };
  // repeated .delivery.QualityScoreTerm quality_score_terms = 1 [json_name = "qualityScoreTerms"];
  int quality_score_terms_size() const;
  private:
  int _internal_quality_score_terms_size() const;
  public:
  void clear_quality_score_terms();
  ::delivery::QualityScoreTerm* mutable_quality_score_terms(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::QualityScoreTerm >*
      mutable_quality_score_terms();
  private:
  const ::delivery::QualityScoreTerm& _internal_quality_score_terms(int index) const;
  ::delivery::QualityScoreTerm* _internal_add_quality_score_terms();
  public:
  const ::delivery::QualityScoreTerm& quality_score_terms(int index) const;
  ::delivery::QualityScoreTerm* add_quality_score_terms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::QualityScoreTerm >&
      quality_score_terms() const;

  // @@protoc_insertion_point(class_scope:delivery.QualityScoreTerms)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::QualityScoreTerm > quality_score_terms_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// -------------------------------------------------------------------

class QualityScoreTerm PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.QualityScoreTerm) */ {
 public:
  inline QualityScoreTerm() : QualityScoreTerm(nullptr) {}
  virtual ~QualityScoreTerm();
  explicit constexpr QualityScoreTerm(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QualityScoreTerm(const QualityScoreTerm& from);
  QualityScoreTerm(QualityScoreTerm&& from) noexcept
    : QualityScoreTerm() {
    *this = ::std::move(from);
  }

  inline QualityScoreTerm& operator=(const QualityScoreTerm& from) {
    CopyFrom(from);
    return *this;
  }
  inline QualityScoreTerm& operator=(QualityScoreTerm&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const QualityScoreTerm& default_instance() {
    return *internal_default_instance();
  }
  enum FetchMethodCase {
    kAttributeName = 1,
    kProduct = 3,
    FETCH_METHOD_NOT_SET = 0,
  };

  static inline const QualityScoreTerm* internal_default_instance() {
    return reinterpret_cast<const QualityScoreTerm*>(
               &_QualityScoreTerm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(QualityScoreTerm& a, QualityScoreTerm& b) {
    a.Swap(&b);
  }
  inline void Swap(QualityScoreTerm* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QualityScoreTerm* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline QualityScoreTerm* New() const final {
    return CreateMaybeMessage<QualityScoreTerm>(nullptr);
  }

  QualityScoreTerm* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QualityScoreTerm>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const QualityScoreTerm& from);
  void MergeFrom(const QualityScoreTerm& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QualityScoreTerm* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.QualityScoreTerm";
  }
  protected:
  explicit QualityScoreTerm(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTermConditionalEvaluationFieldNumber = 14,
    kFetchHighFieldNumber = 10,
    kFetchLowFieldNumber = 11,
    kWeightFieldNumber = 12,
    kOffsetFieldNumber = 13,
    kAttributeNameFieldNumber = 1,
    kProductFieldNumber = 3,
  };
  // .delivery.TermConditionalEvaluation term_conditional_evaluation = 14 [json_name = "termConditionalEvaluation"];
  bool has_term_conditional_evaluation() const;
  private:
  bool _internal_has_term_conditional_evaluation() const;
  public:
  void clear_term_conditional_evaluation();
  const ::delivery::TermConditionalEvaluation& term_conditional_evaluation() const;
  ::delivery::TermConditionalEvaluation* release_term_conditional_evaluation();
  ::delivery::TermConditionalEvaluation* mutable_term_conditional_evaluation();
  void set_allocated_term_conditional_evaluation(::delivery::TermConditionalEvaluation* term_conditional_evaluation);
  private:
  const ::delivery::TermConditionalEvaluation& _internal_term_conditional_evaluation() const;
  ::delivery::TermConditionalEvaluation* _internal_mutable_term_conditional_evaluation();
  public:
  void unsafe_arena_set_allocated_term_conditional_evaluation(
      ::delivery::TermConditionalEvaluation* term_conditional_evaluation);
  ::delivery::TermConditionalEvaluation* unsafe_arena_release_term_conditional_evaluation();

  // float fetch_high = 10 [json_name = "fetchHigh"];
  bool has_fetch_high() const;
  private:
  bool _internal_has_fetch_high() const;
  public:
  void clear_fetch_high();
  float fetch_high() const;
  void set_fetch_high(float value);
  private:
  float _internal_fetch_high() const;
  void _internal_set_fetch_high(float value);
  public:

  // float fetch_low = 11 [json_name = "fetchLow"];
  bool has_fetch_low() const;
  private:
  bool _internal_has_fetch_low() const;
  public:
  void clear_fetch_low();
  float fetch_low() const;
  void set_fetch_low(float value);
  private:
  float _internal_fetch_low() const;
  void _internal_set_fetch_low(float value);
  public:

  // float weight = 12 [json_name = "weight"];
  bool has_weight() const;
  private:
  bool _internal_has_weight() const;
  public:
  void clear_weight();
  float weight() const;
  void set_weight(float value);
  private:
  float _internal_weight() const;
  void _internal_set_weight(float value);
  public:

  // float offset = 13 [json_name = "offset"];
  void clear_offset();
  float offset() const;
  void set_offset(float value);
  private:
  float _internal_offset() const;
  void _internal_set_offset(float value);
  public:

  // string attribute_name = 1 [json_name = "attributeName"];
  bool has_attribute_name() const;
  private:
  bool _internal_has_attribute_name() const;
  public:
  void clear_attribute_name();
  const std::string& attribute_name() const;
  void set_attribute_name(const std::string& value);
  void set_attribute_name(std::string&& value);
  void set_attribute_name(const char* value);
  void set_attribute_name(const char* value, size_t size);
  std::string* mutable_attribute_name();
  std::string* release_attribute_name();
  void set_allocated_attribute_name(std::string* attribute_name);
  private:
  const std::string& _internal_attribute_name() const;
  void _internal_set_attribute_name(const std::string& value);
  std::string* _internal_mutable_attribute_name();
  public:

  // .delivery.QualityScoreTerms product = 3 [json_name = "product"];
  bool has_product() const;
  private:
  bool _internal_has_product() const;
  public:
  void clear_product();
  const ::delivery::QualityScoreTerms& product() const;
  ::delivery::QualityScoreTerms* release_product();
  ::delivery::QualityScoreTerms* mutable_product();
  void set_allocated_product(::delivery::QualityScoreTerms* product);
  private:
  const ::delivery::QualityScoreTerms& _internal_product() const;
  ::delivery::QualityScoreTerms* _internal_mutable_product();
  public:
  void unsafe_arena_set_allocated_product(
      ::delivery::QualityScoreTerms* product);
  ::delivery::QualityScoreTerms* unsafe_arena_release_product();

  void clear_fetch_method();
  FetchMethodCase fetch_method_case() const;
  // @@protoc_insertion_point(class_scope:delivery.QualityScoreTerm)
 private:
  class _Internal;
  void set_has_attribute_name();
  void set_has_product();

  inline bool has_fetch_method() const;
  inline void clear_has_fetch_method();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::delivery::TermConditionalEvaluation* term_conditional_evaluation_;
  float fetch_high_;
  float fetch_low_;
  float weight_;
  float offset_;
  union FetchMethodUnion {
    constexpr FetchMethodUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attribute_name_;
    ::delivery::QualityScoreTerms* product_;
  } fetch_method_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// -------------------------------------------------------------------

class TermConditionalEvaluation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:delivery.TermConditionalEvaluation) */ {
 public:
  inline TermConditionalEvaluation() : TermConditionalEvaluation(nullptr) {}
  virtual ~TermConditionalEvaluation();
  explicit constexpr TermConditionalEvaluation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TermConditionalEvaluation(const TermConditionalEvaluation& from);
  TermConditionalEvaluation(TermConditionalEvaluation&& from) noexcept
    : TermConditionalEvaluation() {
    *this = ::std::move(from);
  }

  inline TermConditionalEvaluation& operator=(const TermConditionalEvaluation& from) {
    CopyFrom(from);
    return *this;
  }
  inline TermConditionalEvaluation& operator=(TermConditionalEvaluation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TermConditionalEvaluation& default_instance() {
    return *internal_default_instance();
  }
  enum EvalMethodCase {
    kFlag = 4,
    kGreaterThan = 6,
    kLessThan = 7,
    kInterval = 8,
    kEqualV2 = 10,
    EVAL_METHOD_NOT_SET = 0,
  };

  static inline const TermConditionalEvaluation* internal_default_instance() {
    return reinterpret_cast<const TermConditionalEvaluation*>(
               &_TermConditionalEvaluation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(TermConditionalEvaluation& a, TermConditionalEvaluation& b) {
    a.Swap(&b);
  }
  inline void Swap(TermConditionalEvaluation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TermConditionalEvaluation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TermConditionalEvaluation* New() const final {
    return CreateMaybeMessage<TermConditionalEvaluation>(nullptr);
  }

  TermConditionalEvaluation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TermConditionalEvaluation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TermConditionalEvaluation& from);
  void MergeFrom(const TermConditionalEvaluation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TermConditionalEvaluation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "delivery.TermConditionalEvaluation";
  }
  protected:
  explicit TermConditionalEvaluation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_proto_2fdelivery_2fblender_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributeNameFieldNumber = 2,
    kValueIfFalseFieldNumber = 1,
    kFlagFieldNumber = 4,
    kGreaterThanFieldNumber = 6,
    kLessThanFieldNumber = 7,
    kIntervalFieldNumber = 8,
    kEqualV2FieldNumber = 10,
  };
  // string attribute_name = 2 [json_name = "attributeName"];
  void clear_attribute_name();
  const std::string& attribute_name() const;
  void set_attribute_name(const std::string& value);
  void set_attribute_name(std::string&& value);
  void set_attribute_name(const char* value);
  void set_attribute_name(const char* value, size_t size);
  std::string* mutable_attribute_name();
  std::string* release_attribute_name();
  void set_allocated_attribute_name(std::string* attribute_name);
  private:
  const std::string& _internal_attribute_name() const;
  void _internal_set_attribute_name(const std::string& value);
  std::string* _internal_mutable_attribute_name();
  public:

  // float value_if_false = 1 [json_name = "valueIfFalse"];
  void clear_value_if_false();
  float value_if_false() const;
  void set_value_if_false(float value);
  private:
  float _internal_value_if_false() const;
  void _internal_set_value_if_false(float value);
  public:

  // .delivery.Flag flag = 4 [json_name = "flag"];
  bool has_flag() const;
  private:
  bool _internal_has_flag() const;
  public:
  void clear_flag();
  const ::delivery::Flag& flag() const;
  ::delivery::Flag* release_flag();
  ::delivery::Flag* mutable_flag();
  void set_allocated_flag(::delivery::Flag* flag);
  private:
  const ::delivery::Flag& _internal_flag() const;
  ::delivery::Flag* _internal_mutable_flag();
  public:
  void unsafe_arena_set_allocated_flag(
      ::delivery::Flag* flag);
  ::delivery::Flag* unsafe_arena_release_flag();

  // .delivery.GreaterThan greater_than = 6 [json_name = "greaterThan"];
  bool has_greater_than() const;
  private:
  bool _internal_has_greater_than() const;
  public:
  void clear_greater_than();
  const ::delivery::GreaterThan& greater_than() const;
  ::delivery::GreaterThan* release_greater_than();
  ::delivery::GreaterThan* mutable_greater_than();
  void set_allocated_greater_than(::delivery::GreaterThan* greater_than);
  private:
  const ::delivery::GreaterThan& _internal_greater_than() const;
  ::delivery::GreaterThan* _internal_mutable_greater_than();
  public:
  void unsafe_arena_set_allocated_greater_than(
      ::delivery::GreaterThan* greater_than);
  ::delivery::GreaterThan* unsafe_arena_release_greater_than();

  // .delivery.LessThan less_than = 7 [json_name = "lessThan"];
  bool has_less_than() const;
  private:
  bool _internal_has_less_than() const;
  public:
  void clear_less_than();
  const ::delivery::LessThan& less_than() const;
  ::delivery::LessThan* release_less_than();
  ::delivery::LessThan* mutable_less_than();
  void set_allocated_less_than(::delivery::LessThan* less_than);
  private:
  const ::delivery::LessThan& _internal_less_than() const;
  ::delivery::LessThan* _internal_mutable_less_than();
  public:
  void unsafe_arena_set_allocated_less_than(
      ::delivery::LessThan* less_than);
  ::delivery::LessThan* unsafe_arena_release_less_than();

  // .delivery.Interval interval = 8 [json_name = "interval"];
  bool has_interval() const;
  private:
  bool _internal_has_interval() const;
  public:
  void clear_interval();
  const ::delivery::Interval& interval() const;
  ::delivery::Interval* release_interval();
  ::delivery::Interval* mutable_interval();
  void set_allocated_interval(::delivery::Interval* interval);
  private:
  const ::delivery::Interval& _internal_interval() const;
  ::delivery::Interval* _internal_mutable_interval();
  public:
  void unsafe_arena_set_allocated_interval(
      ::delivery::Interval* interval);
  ::delivery::Interval* unsafe_arena_release_interval();

  // .delivery.EqualV2 equal_v2 = 10 [json_name = "equalV2"];
  bool has_equal_v2() const;
  private:
  bool _internal_has_equal_v2() const;
  public:
  void clear_equal_v2();
  const ::delivery::EqualV2& equal_v2() const;
  ::delivery::EqualV2* release_equal_v2();
  ::delivery::EqualV2* mutable_equal_v2();
  void set_allocated_equal_v2(::delivery::EqualV2* equal_v2);
  private:
  const ::delivery::EqualV2& _internal_equal_v2() const;
  ::delivery::EqualV2* _internal_mutable_equal_v2();
  public:
  void unsafe_arena_set_allocated_equal_v2(
      ::delivery::EqualV2* equal_v2);
  ::delivery::EqualV2* unsafe_arena_release_equal_v2();

  void clear_eval_method();
  EvalMethodCase eval_method_case() const;
  // @@protoc_insertion_point(class_scope:delivery.TermConditionalEvaluation)
 private:
  class _Internal;
  void set_has_flag();
  void set_has_greater_than();
  void set_has_less_than();
  void set_has_interval();
  void set_has_equal_v2();

  inline bool has_eval_method() const;
  inline void clear_has_eval_method();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attribute_name_;
  float value_if_false_;
  union EvalMethodUnion {
    constexpr EvalMethodUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::delivery::Flag* flag_;
    ::delivery::GreaterThan* greater_than_;
    ::delivery::LessThan* less_than_;
    ::delivery::Interval* interval_;
    ::delivery::EqualV2* equal_v2_;
  } eval_method_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_proto_2fdelivery_2fblender_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BlenderConfig

// repeated .delivery.BlenderRule blender_rule = 1 [json_name = "blenderRule"];
inline int BlenderConfig::_internal_blender_rule_size() const {
  return blender_rule_.size();
}
inline int BlenderConfig::blender_rule_size() const {
  return _internal_blender_rule_size();
}
inline void BlenderConfig::clear_blender_rule() {
  blender_rule_.Clear();
}
inline ::delivery::BlenderRule* BlenderConfig::mutable_blender_rule(int index) {
  // @@protoc_insertion_point(field_mutable:delivery.BlenderConfig.blender_rule)
  return blender_rule_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::BlenderRule >*
BlenderConfig::mutable_blender_rule() {
  // @@protoc_insertion_point(field_mutable_list:delivery.BlenderConfig.blender_rule)
  return &blender_rule_;
}
inline const ::delivery::BlenderRule& BlenderConfig::_internal_blender_rule(int index) const {
  return blender_rule_.Get(index);
}
inline const ::delivery::BlenderRule& BlenderConfig::blender_rule(int index) const {
  // @@protoc_insertion_point(field_get:delivery.BlenderConfig.blender_rule)
  return _internal_blender_rule(index);
}
inline ::delivery::BlenderRule* BlenderConfig::_internal_add_blender_rule() {
  return blender_rule_.Add();
}
inline ::delivery::BlenderRule* BlenderConfig::add_blender_rule() {
  // @@protoc_insertion_point(field_add:delivery.BlenderConfig.blender_rule)
  return _internal_add_blender_rule();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::BlenderRule >&
BlenderConfig::blender_rule() const {
  // @@protoc_insertion_point(field_list:delivery.BlenderConfig.blender_rule)
  return blender_rule_;
}

// .delivery.QualityScoreConfig quality_score_config = 2 [json_name = "qualityScoreConfig"];
inline bool BlenderConfig::_internal_has_quality_score_config() const {
  return this != internal_default_instance() && quality_score_config_ != nullptr;
}
inline bool BlenderConfig::has_quality_score_config() const {
  return _internal_has_quality_score_config();
}
inline void BlenderConfig::clear_quality_score_config() {
  if (GetArena() == nullptr && quality_score_config_ != nullptr) {
    delete quality_score_config_;
  }
  quality_score_config_ = nullptr;
}
inline const ::delivery::QualityScoreConfig& BlenderConfig::_internal_quality_score_config() const {
  const ::delivery::QualityScoreConfig* p = quality_score_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::delivery::QualityScoreConfig&>(
      ::delivery::_QualityScoreConfig_default_instance_);
}
inline const ::delivery::QualityScoreConfig& BlenderConfig::quality_score_config() const {
  // @@protoc_insertion_point(field_get:delivery.BlenderConfig.quality_score_config)
  return _internal_quality_score_config();
}
inline void BlenderConfig::unsafe_arena_set_allocated_quality_score_config(
    ::delivery::QualityScoreConfig* quality_score_config) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(quality_score_config_);
  }
  quality_score_config_ = quality_score_config;
  if (quality_score_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.BlenderConfig.quality_score_config)
}
inline ::delivery::QualityScoreConfig* BlenderConfig::release_quality_score_config() {
  
  ::delivery::QualityScoreConfig* temp = quality_score_config_;
  quality_score_config_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::delivery::QualityScoreConfig* BlenderConfig::unsafe_arena_release_quality_score_config() {
  // @@protoc_insertion_point(field_release:delivery.BlenderConfig.quality_score_config)
  
  ::delivery::QualityScoreConfig* temp = quality_score_config_;
  quality_score_config_ = nullptr;
  return temp;
}
inline ::delivery::QualityScoreConfig* BlenderConfig::_internal_mutable_quality_score_config() {
  
  if (quality_score_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::delivery::QualityScoreConfig>(GetArena());
    quality_score_config_ = p;
  }
  return quality_score_config_;
}
inline ::delivery::QualityScoreConfig* BlenderConfig::mutable_quality_score_config() {
  // @@protoc_insertion_point(field_mutable:delivery.BlenderConfig.quality_score_config)
  return _internal_mutable_quality_score_config();
}
inline void BlenderConfig::set_allocated_quality_score_config(::delivery::QualityScoreConfig* quality_score_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete quality_score_config_;
  }
  if (quality_score_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(quality_score_config);
    if (message_arena != submessage_arena) {
      quality_score_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, quality_score_config, submessage_arena);
    }
    
  } else {
    
  }
  quality_score_config_ = quality_score_config;
  // @@protoc_insertion_point(field_set_allocated:delivery.BlenderConfig.quality_score_config)
}

// -------------------------------------------------------------------

// BlenderRule

// string attribute_name = 1 [json_name = "attributeName"];
inline void BlenderRule::clear_attribute_name() {
  attribute_name_.ClearToEmpty();
}
inline const std::string& BlenderRule::attribute_name() const {
  // @@protoc_insertion_point(field_get:delivery.BlenderRule.attribute_name)
  return _internal_attribute_name();
}
inline void BlenderRule::set_attribute_name(const std::string& value) {
  _internal_set_attribute_name(value);
  // @@protoc_insertion_point(field_set:delivery.BlenderRule.attribute_name)
}
inline std::string* BlenderRule::mutable_attribute_name() {
  // @@protoc_insertion_point(field_mutable:delivery.BlenderRule.attribute_name)
  return _internal_mutable_attribute_name();
}
inline const std::string& BlenderRule::_internal_attribute_name() const {
  return attribute_name_.Get();
}
inline void BlenderRule::_internal_set_attribute_name(const std::string& value) {
  
  attribute_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void BlenderRule::set_attribute_name(std::string&& value) {
  
  attribute_name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:delivery.BlenderRule.attribute_name)
}
inline void BlenderRule::set_attribute_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  attribute_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:delivery.BlenderRule.attribute_name)
}
inline void BlenderRule::set_attribute_name(const char* value,
    size_t size) {
  
  attribute_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:delivery.BlenderRule.attribute_name)
}
inline std::string* BlenderRule::_internal_mutable_attribute_name() {
  
  return attribute_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* BlenderRule::release_attribute_name() {
  // @@protoc_insertion_point(field_release:delivery.BlenderRule.attribute_name)
  return attribute_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BlenderRule::set_allocated_attribute_name(std::string* attribute_name) {
  if (attribute_name != nullptr) {
    
  } else {
    
  }
  attribute_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), attribute_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:delivery.BlenderRule.attribute_name)
}

// .delivery.PositiveRule positive_rule = 6 [json_name = "positiveRule"];
inline bool BlenderRule::_internal_has_positive_rule() const {
  return rule_case() == kPositiveRule;
}
inline bool BlenderRule::has_positive_rule() const {
  return _internal_has_positive_rule();
}
inline void BlenderRule::set_has_positive_rule() {
  _oneof_case_[0] = kPositiveRule;
}
inline void BlenderRule::clear_positive_rule() {
  if (_internal_has_positive_rule()) {
    if (GetArena() == nullptr) {
      delete rule_.positive_rule_;
    }
    clear_has_rule();
  }
}
inline ::delivery::PositiveRule* BlenderRule::release_positive_rule() {
  // @@protoc_insertion_point(field_release:delivery.BlenderRule.positive_rule)
  if (_internal_has_positive_rule()) {
    clear_has_rule();
      ::delivery::PositiveRule* temp = rule_.positive_rule_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    rule_.positive_rule_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::delivery::PositiveRule& BlenderRule::_internal_positive_rule() const {
  return _internal_has_positive_rule()
      ? *rule_.positive_rule_
      : reinterpret_cast< ::delivery::PositiveRule&>(::delivery::_PositiveRule_default_instance_);
}
inline const ::delivery::PositiveRule& BlenderRule::positive_rule() const {
  // @@protoc_insertion_point(field_get:delivery.BlenderRule.positive_rule)
  return _internal_positive_rule();
}
inline ::delivery::PositiveRule* BlenderRule::unsafe_arena_release_positive_rule() {
  // @@protoc_insertion_point(field_unsafe_arena_release:delivery.BlenderRule.positive_rule)
  if (_internal_has_positive_rule()) {
    clear_has_rule();
    ::delivery::PositiveRule* temp = rule_.positive_rule_;
    rule_.positive_rule_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlenderRule::unsafe_arena_set_allocated_positive_rule(::delivery::PositiveRule* positive_rule) {
  clear_rule();
  if (positive_rule) {
    set_has_positive_rule();
    rule_.positive_rule_ = positive_rule;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.BlenderRule.positive_rule)
}
inline ::delivery::PositiveRule* BlenderRule::_internal_mutable_positive_rule() {
  if (!_internal_has_positive_rule()) {
    clear_rule();
    set_has_positive_rule();
    rule_.positive_rule_ = CreateMaybeMessage< ::delivery::PositiveRule >(GetArena());
  }
  return rule_.positive_rule_;
}
inline ::delivery::PositiveRule* BlenderRule::mutable_positive_rule() {
  // @@protoc_insertion_point(field_mutable:delivery.BlenderRule.positive_rule)
  return _internal_mutable_positive_rule();
}

// .delivery.InsertRule insert_rule = 7 [json_name = "insertRule"];
inline bool BlenderRule::_internal_has_insert_rule() const {
  return rule_case() == kInsertRule;
}
inline bool BlenderRule::has_insert_rule() const {
  return _internal_has_insert_rule();
}
inline void BlenderRule::set_has_insert_rule() {
  _oneof_case_[0] = kInsertRule;
}
inline void BlenderRule::clear_insert_rule() {
  if (_internal_has_insert_rule()) {
    if (GetArena() == nullptr) {
      delete rule_.insert_rule_;
    }
    clear_has_rule();
  }
}
inline ::delivery::InsertRule* BlenderRule::release_insert_rule() {
  // @@protoc_insertion_point(field_release:delivery.BlenderRule.insert_rule)
  if (_internal_has_insert_rule()) {
    clear_has_rule();
      ::delivery::InsertRule* temp = rule_.insert_rule_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    rule_.insert_rule_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::delivery::InsertRule& BlenderRule::_internal_insert_rule() const {
  return _internal_has_insert_rule()
      ? *rule_.insert_rule_
      : reinterpret_cast< ::delivery::InsertRule&>(::delivery::_InsertRule_default_instance_);
}
inline const ::delivery::InsertRule& BlenderRule::insert_rule() const {
  // @@protoc_insertion_point(field_get:delivery.BlenderRule.insert_rule)
  return _internal_insert_rule();
}
inline ::delivery::InsertRule* BlenderRule::unsafe_arena_release_insert_rule() {
  // @@protoc_insertion_point(field_unsafe_arena_release:delivery.BlenderRule.insert_rule)
  if (_internal_has_insert_rule()) {
    clear_has_rule();
    ::delivery::InsertRule* temp = rule_.insert_rule_;
    rule_.insert_rule_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlenderRule::unsafe_arena_set_allocated_insert_rule(::delivery::InsertRule* insert_rule) {
  clear_rule();
  if (insert_rule) {
    set_has_insert_rule();
    rule_.insert_rule_ = insert_rule;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.BlenderRule.insert_rule)
}
inline ::delivery::InsertRule* BlenderRule::_internal_mutable_insert_rule() {
  if (!_internal_has_insert_rule()) {
    clear_rule();
    set_has_insert_rule();
    rule_.insert_rule_ = CreateMaybeMessage< ::delivery::InsertRule >(GetArena());
  }
  return rule_.insert_rule_;
}
inline ::delivery::InsertRule* BlenderRule::mutable_insert_rule() {
  // @@protoc_insertion_point(field_mutable:delivery.BlenderRule.insert_rule)
  return _internal_mutable_insert_rule();
}

// .delivery.NegativeRule negative_rule = 8 [json_name = "negativeRule"];
inline bool BlenderRule::_internal_has_negative_rule() const {
  return rule_case() == kNegativeRule;
}
inline bool BlenderRule::has_negative_rule() const {
  return _internal_has_negative_rule();
}
inline void BlenderRule::set_has_negative_rule() {
  _oneof_case_[0] = kNegativeRule;
}
inline void BlenderRule::clear_negative_rule() {
  if (_internal_has_negative_rule()) {
    if (GetArena() == nullptr) {
      delete rule_.negative_rule_;
    }
    clear_has_rule();
  }
}
inline ::delivery::NegativeRule* BlenderRule::release_negative_rule() {
  // @@protoc_insertion_point(field_release:delivery.BlenderRule.negative_rule)
  if (_internal_has_negative_rule()) {
    clear_has_rule();
      ::delivery::NegativeRule* temp = rule_.negative_rule_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    rule_.negative_rule_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::delivery::NegativeRule& BlenderRule::_internal_negative_rule() const {
  return _internal_has_negative_rule()
      ? *rule_.negative_rule_
      : reinterpret_cast< ::delivery::NegativeRule&>(::delivery::_NegativeRule_default_instance_);
}
inline const ::delivery::NegativeRule& BlenderRule::negative_rule() const {
  // @@protoc_insertion_point(field_get:delivery.BlenderRule.negative_rule)
  return _internal_negative_rule();
}
inline ::delivery::NegativeRule* BlenderRule::unsafe_arena_release_negative_rule() {
  // @@protoc_insertion_point(field_unsafe_arena_release:delivery.BlenderRule.negative_rule)
  if (_internal_has_negative_rule()) {
    clear_has_rule();
    ::delivery::NegativeRule* temp = rule_.negative_rule_;
    rule_.negative_rule_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlenderRule::unsafe_arena_set_allocated_negative_rule(::delivery::NegativeRule* negative_rule) {
  clear_rule();
  if (negative_rule) {
    set_has_negative_rule();
    rule_.negative_rule_ = negative_rule;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.BlenderRule.negative_rule)
}
inline ::delivery::NegativeRule* BlenderRule::_internal_mutable_negative_rule() {
  if (!_internal_has_negative_rule()) {
    clear_rule();
    set_has_negative_rule();
    rule_.negative_rule_ = CreateMaybeMessage< ::delivery::NegativeRule >(GetArena());
  }
  return rule_.negative_rule_;
}
inline ::delivery::NegativeRule* BlenderRule::mutable_negative_rule() {
  // @@protoc_insertion_point(field_mutable:delivery.BlenderRule.negative_rule)
  return _internal_mutable_negative_rule();
}

// .delivery.DiversityRule diversity_rule = 9 [json_name = "diversityRule"];
inline bool BlenderRule::_internal_has_diversity_rule() const {
  return rule_case() == kDiversityRule;
}
inline bool BlenderRule::has_diversity_rule() const {
  return _internal_has_diversity_rule();
}
inline void BlenderRule::set_has_diversity_rule() {
  _oneof_case_[0] = kDiversityRule;
}
inline void BlenderRule::clear_diversity_rule() {
  if (_internal_has_diversity_rule()) {
    if (GetArena() == nullptr) {
      delete rule_.diversity_rule_;
    }
    clear_has_rule();
  }
}
inline ::delivery::DiversityRule* BlenderRule::release_diversity_rule() {
  // @@protoc_insertion_point(field_release:delivery.BlenderRule.diversity_rule)
  if (_internal_has_diversity_rule()) {
    clear_has_rule();
      ::delivery::DiversityRule* temp = rule_.diversity_rule_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    rule_.diversity_rule_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::delivery::DiversityRule& BlenderRule::_internal_diversity_rule() const {
  return _internal_has_diversity_rule()
      ? *rule_.diversity_rule_
      : reinterpret_cast< ::delivery::DiversityRule&>(::delivery::_DiversityRule_default_instance_);
}
inline const ::delivery::DiversityRule& BlenderRule::diversity_rule() const {
  // @@protoc_insertion_point(field_get:delivery.BlenderRule.diversity_rule)
  return _internal_diversity_rule();
}
inline ::delivery::DiversityRule* BlenderRule::unsafe_arena_release_diversity_rule() {
  // @@protoc_insertion_point(field_unsafe_arena_release:delivery.BlenderRule.diversity_rule)
  if (_internal_has_diversity_rule()) {
    clear_has_rule();
    ::delivery::DiversityRule* temp = rule_.diversity_rule_;
    rule_.diversity_rule_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlenderRule::unsafe_arena_set_allocated_diversity_rule(::delivery::DiversityRule* diversity_rule) {
  clear_rule();
  if (diversity_rule) {
    set_has_diversity_rule();
    rule_.diversity_rule_ = diversity_rule;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.BlenderRule.diversity_rule)
}
inline ::delivery::DiversityRule* BlenderRule::_internal_mutable_diversity_rule() {
  if (!_internal_has_diversity_rule()) {
    clear_rule();
    set_has_diversity_rule();
    rule_.diversity_rule_ = CreateMaybeMessage< ::delivery::DiversityRule >(GetArena());
  }
  return rule_.diversity_rule_;
}
inline ::delivery::DiversityRule* BlenderRule::mutable_diversity_rule() {
  // @@protoc_insertion_point(field_mutable:delivery.BlenderRule.diversity_rule)
  return _internal_mutable_diversity_rule();
}

// .delivery.Flag flag = 11 [json_name = "flag"];
inline bool BlenderRule::_internal_has_flag() const {
  return eval_method_case() == kFlag;
}
inline bool BlenderRule::has_flag() const {
  return _internal_has_flag();
}
inline void BlenderRule::set_has_flag() {
  _oneof_case_[1] = kFlag;
}
inline void BlenderRule::clear_flag() {
  if (_internal_has_flag()) {
    if (GetArena() == nullptr) {
      delete eval_method_.flag_;
    }
    clear_has_eval_method();
  }
}
inline ::delivery::Flag* BlenderRule::release_flag() {
  // @@protoc_insertion_point(field_release:delivery.BlenderRule.flag)
  if (_internal_has_flag()) {
    clear_has_eval_method();
      ::delivery::Flag* temp = eval_method_.flag_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    eval_method_.flag_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::delivery::Flag& BlenderRule::_internal_flag() const {
  return _internal_has_flag()
      ? *eval_method_.flag_
      : reinterpret_cast< ::delivery::Flag&>(::delivery::_Flag_default_instance_);
}
inline const ::delivery::Flag& BlenderRule::flag() const {
  // @@protoc_insertion_point(field_get:delivery.BlenderRule.flag)
  return _internal_flag();
}
inline ::delivery::Flag* BlenderRule::unsafe_arena_release_flag() {
  // @@protoc_insertion_point(field_unsafe_arena_release:delivery.BlenderRule.flag)
  if (_internal_has_flag()) {
    clear_has_eval_method();
    ::delivery::Flag* temp = eval_method_.flag_;
    eval_method_.flag_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlenderRule::unsafe_arena_set_allocated_flag(::delivery::Flag* flag) {
  clear_eval_method();
  if (flag) {
    set_has_flag();
    eval_method_.flag_ = flag;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.BlenderRule.flag)
}
inline ::delivery::Flag* BlenderRule::_internal_mutable_flag() {
  if (!_internal_has_flag()) {
    clear_eval_method();
    set_has_flag();
    eval_method_.flag_ = CreateMaybeMessage< ::delivery::Flag >(GetArena());
  }
  return eval_method_.flag_;
}
inline ::delivery::Flag* BlenderRule::mutable_flag() {
  // @@protoc_insertion_point(field_mutable:delivery.BlenderRule.flag)
  return _internal_mutable_flag();
}

// .delivery.GreaterThan greater_than = 13 [json_name = "greaterThan"];
inline bool BlenderRule::_internal_has_greater_than() const {
  return eval_method_case() == kGreaterThan;
}
inline bool BlenderRule::has_greater_than() const {
  return _internal_has_greater_than();
}
inline void BlenderRule::set_has_greater_than() {
  _oneof_case_[1] = kGreaterThan;
}
inline void BlenderRule::clear_greater_than() {
  if (_internal_has_greater_than()) {
    if (GetArena() == nullptr) {
      delete eval_method_.greater_than_;
    }
    clear_has_eval_method();
  }
}
inline ::delivery::GreaterThan* BlenderRule::release_greater_than() {
  // @@protoc_insertion_point(field_release:delivery.BlenderRule.greater_than)
  if (_internal_has_greater_than()) {
    clear_has_eval_method();
      ::delivery::GreaterThan* temp = eval_method_.greater_than_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    eval_method_.greater_than_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::delivery::GreaterThan& BlenderRule::_internal_greater_than() const {
  return _internal_has_greater_than()
      ? *eval_method_.greater_than_
      : reinterpret_cast< ::delivery::GreaterThan&>(::delivery::_GreaterThan_default_instance_);
}
inline const ::delivery::GreaterThan& BlenderRule::greater_than() const {
  // @@protoc_insertion_point(field_get:delivery.BlenderRule.greater_than)
  return _internal_greater_than();
}
inline ::delivery::GreaterThan* BlenderRule::unsafe_arena_release_greater_than() {
  // @@protoc_insertion_point(field_unsafe_arena_release:delivery.BlenderRule.greater_than)
  if (_internal_has_greater_than()) {
    clear_has_eval_method();
    ::delivery::GreaterThan* temp = eval_method_.greater_than_;
    eval_method_.greater_than_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlenderRule::unsafe_arena_set_allocated_greater_than(::delivery::GreaterThan* greater_than) {
  clear_eval_method();
  if (greater_than) {
    set_has_greater_than();
    eval_method_.greater_than_ = greater_than;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.BlenderRule.greater_than)
}
inline ::delivery::GreaterThan* BlenderRule::_internal_mutable_greater_than() {
  if (!_internal_has_greater_than()) {
    clear_eval_method();
    set_has_greater_than();
    eval_method_.greater_than_ = CreateMaybeMessage< ::delivery::GreaterThan >(GetArena());
  }
  return eval_method_.greater_than_;
}
inline ::delivery::GreaterThan* BlenderRule::mutable_greater_than() {
  // @@protoc_insertion_point(field_mutable:delivery.BlenderRule.greater_than)
  return _internal_mutable_greater_than();
}

// .delivery.LessThan less_than = 14 [json_name = "lessThan"];
inline bool BlenderRule::_internal_has_less_than() const {
  return eval_method_case() == kLessThan;
}
inline bool BlenderRule::has_less_than() const {
  return _internal_has_less_than();
}
inline void BlenderRule::set_has_less_than() {
  _oneof_case_[1] = kLessThan;
}
inline void BlenderRule::clear_less_than() {
  if (_internal_has_less_than()) {
    if (GetArena() == nullptr) {
      delete eval_method_.less_than_;
    }
    clear_has_eval_method();
  }
}
inline ::delivery::LessThan* BlenderRule::release_less_than() {
  // @@protoc_insertion_point(field_release:delivery.BlenderRule.less_than)
  if (_internal_has_less_than()) {
    clear_has_eval_method();
      ::delivery::LessThan* temp = eval_method_.less_than_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    eval_method_.less_than_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::delivery::LessThan& BlenderRule::_internal_less_than() const {
  return _internal_has_less_than()
      ? *eval_method_.less_than_
      : reinterpret_cast< ::delivery::LessThan&>(::delivery::_LessThan_default_instance_);
}
inline const ::delivery::LessThan& BlenderRule::less_than() const {
  // @@protoc_insertion_point(field_get:delivery.BlenderRule.less_than)
  return _internal_less_than();
}
inline ::delivery::LessThan* BlenderRule::unsafe_arena_release_less_than() {
  // @@protoc_insertion_point(field_unsafe_arena_release:delivery.BlenderRule.less_than)
  if (_internal_has_less_than()) {
    clear_has_eval_method();
    ::delivery::LessThan* temp = eval_method_.less_than_;
    eval_method_.less_than_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlenderRule::unsafe_arena_set_allocated_less_than(::delivery::LessThan* less_than) {
  clear_eval_method();
  if (less_than) {
    set_has_less_than();
    eval_method_.less_than_ = less_than;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.BlenderRule.less_than)
}
inline ::delivery::LessThan* BlenderRule::_internal_mutable_less_than() {
  if (!_internal_has_less_than()) {
    clear_eval_method();
    set_has_less_than();
    eval_method_.less_than_ = CreateMaybeMessage< ::delivery::LessThan >(GetArena());
  }
  return eval_method_.less_than_;
}
inline ::delivery::LessThan* BlenderRule::mutable_less_than() {
  // @@protoc_insertion_point(field_mutable:delivery.BlenderRule.less_than)
  return _internal_mutable_less_than();
}

// .delivery.Interval interval = 15 [json_name = "interval"];
inline bool BlenderRule::_internal_has_interval() const {
  return eval_method_case() == kInterval;
}
inline bool BlenderRule::has_interval() const {
  return _internal_has_interval();
}
inline void BlenderRule::set_has_interval() {
  _oneof_case_[1] = kInterval;
}
inline void BlenderRule::clear_interval() {
  if (_internal_has_interval()) {
    if (GetArena() == nullptr) {
      delete eval_method_.interval_;
    }
    clear_has_eval_method();
  }
}
inline ::delivery::Interval* BlenderRule::release_interval() {
  // @@protoc_insertion_point(field_release:delivery.BlenderRule.interval)
  if (_internal_has_interval()) {
    clear_has_eval_method();
      ::delivery::Interval* temp = eval_method_.interval_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    eval_method_.interval_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::delivery::Interval& BlenderRule::_internal_interval() const {
  return _internal_has_interval()
      ? *eval_method_.interval_
      : reinterpret_cast< ::delivery::Interval&>(::delivery::_Interval_default_instance_);
}
inline const ::delivery::Interval& BlenderRule::interval() const {
  // @@protoc_insertion_point(field_get:delivery.BlenderRule.interval)
  return _internal_interval();
}
inline ::delivery::Interval* BlenderRule::unsafe_arena_release_interval() {
  // @@protoc_insertion_point(field_unsafe_arena_release:delivery.BlenderRule.interval)
  if (_internal_has_interval()) {
    clear_has_eval_method();
    ::delivery::Interval* temp = eval_method_.interval_;
    eval_method_.interval_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlenderRule::unsafe_arena_set_allocated_interval(::delivery::Interval* interval) {
  clear_eval_method();
  if (interval) {
    set_has_interval();
    eval_method_.interval_ = interval;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.BlenderRule.interval)
}
inline ::delivery::Interval* BlenderRule::_internal_mutable_interval() {
  if (!_internal_has_interval()) {
    clear_eval_method();
    set_has_interval();
    eval_method_.interval_ = CreateMaybeMessage< ::delivery::Interval >(GetArena());
  }
  return eval_method_.interval_;
}
inline ::delivery::Interval* BlenderRule::mutable_interval() {
  // @@protoc_insertion_point(field_mutable:delivery.BlenderRule.interval)
  return _internal_mutable_interval();
}

// .delivery.EqualV2 equal_v2 = 16 [json_name = "equalV2"];
inline bool BlenderRule::_internal_has_equal_v2() const {
  return eval_method_case() == kEqualV2;
}
inline bool BlenderRule::has_equal_v2() const {
  return _internal_has_equal_v2();
}
inline void BlenderRule::set_has_equal_v2() {
  _oneof_case_[1] = kEqualV2;
}
inline void BlenderRule::clear_equal_v2() {
  if (_internal_has_equal_v2()) {
    if (GetArena() == nullptr) {
      delete eval_method_.equal_v2_;
    }
    clear_has_eval_method();
  }
}
inline ::delivery::EqualV2* BlenderRule::release_equal_v2() {
  // @@protoc_insertion_point(field_release:delivery.BlenderRule.equal_v2)
  if (_internal_has_equal_v2()) {
    clear_has_eval_method();
      ::delivery::EqualV2* temp = eval_method_.equal_v2_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    eval_method_.equal_v2_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::delivery::EqualV2& BlenderRule::_internal_equal_v2() const {
  return _internal_has_equal_v2()
      ? *eval_method_.equal_v2_
      : reinterpret_cast< ::delivery::EqualV2&>(::delivery::_EqualV2_default_instance_);
}
inline const ::delivery::EqualV2& BlenderRule::equal_v2() const {
  // @@protoc_insertion_point(field_get:delivery.BlenderRule.equal_v2)
  return _internal_equal_v2();
}
inline ::delivery::EqualV2* BlenderRule::unsafe_arena_release_equal_v2() {
  // @@protoc_insertion_point(field_unsafe_arena_release:delivery.BlenderRule.equal_v2)
  if (_internal_has_equal_v2()) {
    clear_has_eval_method();
    ::delivery::EqualV2* temp = eval_method_.equal_v2_;
    eval_method_.equal_v2_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BlenderRule::unsafe_arena_set_allocated_equal_v2(::delivery::EqualV2* equal_v2) {
  clear_eval_method();
  if (equal_v2) {
    set_has_equal_v2();
    eval_method_.equal_v2_ = equal_v2;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.BlenderRule.equal_v2)
}
inline ::delivery::EqualV2* BlenderRule::_internal_mutable_equal_v2() {
  if (!_internal_has_equal_v2()) {
    clear_eval_method();
    set_has_equal_v2();
    eval_method_.equal_v2_ = CreateMaybeMessage< ::delivery::EqualV2 >(GetArena());
  }
  return eval_method_.equal_v2_;
}
inline ::delivery::EqualV2* BlenderRule::mutable_equal_v2() {
  // @@protoc_insertion_point(field_mutable:delivery.BlenderRule.equal_v2)
  return _internal_mutable_equal_v2();
}

inline bool BlenderRule::has_rule() const {
  return rule_case() != RULE_NOT_SET;
}
inline void BlenderRule::clear_has_rule() {
  _oneof_case_[0] = RULE_NOT_SET;
}
inline bool BlenderRule::has_eval_method() const {
  return eval_method_case() != EVAL_METHOD_NOT_SET;
}
inline void BlenderRule::clear_has_eval_method() {
  _oneof_case_[1] = EVAL_METHOD_NOT_SET;
}
inline BlenderRule::RuleCase BlenderRule::rule_case() const {
  return BlenderRule::RuleCase(_oneof_case_[0]);
}
inline BlenderRule::EvalMethodCase BlenderRule::eval_method_case() const {
  return BlenderRule::EvalMethodCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// Flag

// bool ignored = 1 [json_name = "ignored", deprecated = true];
inline bool Flag::_internal_has_ignored() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Flag::has_ignored() const {
  return _internal_has_ignored();
}
inline void Flag::clear_ignored() {
  ignored_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool Flag::_internal_ignored() const {
  return ignored_;
}
inline bool Flag::ignored() const {
  // @@protoc_insertion_point(field_get:delivery.Flag.ignored)
  return _internal_ignored();
}
inline void Flag::_internal_set_ignored(bool value) {
  _has_bits_[0] |= 0x00000001u;
  ignored_ = value;
}
inline void Flag::set_ignored(bool value) {
  _internal_set_ignored(value);
  // @@protoc_insertion_point(field_set:delivery.Flag.ignored)
}

// -------------------------------------------------------------------

// EqualV2

// .delivery.Equal number = 1 [json_name = "number"];
inline bool EqualV2::_internal_has_number() const {
  return equality_type_case() == kNumber;
}
inline bool EqualV2::has_number() const {
  return _internal_has_number();
}
inline void EqualV2::set_has_number() {
  _oneof_case_[0] = kNumber;
}
inline void EqualV2::clear_number() {
  if (_internal_has_number()) {
    if (GetArena() == nullptr) {
      delete equality_type_.number_;
    }
    clear_has_equality_type();
  }
}
inline ::delivery::Equal* EqualV2::release_number() {
  // @@protoc_insertion_point(field_release:delivery.EqualV2.number)
  if (_internal_has_number()) {
    clear_has_equality_type();
      ::delivery::Equal* temp = equality_type_.number_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    equality_type_.number_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::delivery::Equal& EqualV2::_internal_number() const {
  return _internal_has_number()
      ? *equality_type_.number_
      : reinterpret_cast< ::delivery::Equal&>(::delivery::_Equal_default_instance_);
}
inline const ::delivery::Equal& EqualV2::number() const {
  // @@protoc_insertion_point(field_get:delivery.EqualV2.number)
  return _internal_number();
}
inline ::delivery::Equal* EqualV2::unsafe_arena_release_number() {
  // @@protoc_insertion_point(field_unsafe_arena_release:delivery.EqualV2.number)
  if (_internal_has_number()) {
    clear_has_equality_type();
    ::delivery::Equal* temp = equality_type_.number_;
    equality_type_.number_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EqualV2::unsafe_arena_set_allocated_number(::delivery::Equal* number) {
  clear_equality_type();
  if (number) {
    set_has_number();
    equality_type_.number_ = number;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.EqualV2.number)
}
inline ::delivery::Equal* EqualV2::_internal_mutable_number() {
  if (!_internal_has_number()) {
    clear_equality_type();
    set_has_number();
    equality_type_.number_ = CreateMaybeMessage< ::delivery::Equal >(GetArena());
  }
  return equality_type_.number_;
}
inline ::delivery::Equal* EqualV2::mutable_number() {
  // @@protoc_insertion_point(field_mutable:delivery.EqualV2.number)
  return _internal_mutable_number();
}

// .delivery.StringEquality string_equality = 2 [json_name = "stringEquality"];
inline bool EqualV2::_internal_has_string_equality() const {
  return equality_type_case() == kStringEquality;
}
inline bool EqualV2::has_string_equality() const {
  return _internal_has_string_equality();
}
inline void EqualV2::set_has_string_equality() {
  _oneof_case_[0] = kStringEquality;
}
inline void EqualV2::clear_string_equality() {
  if (_internal_has_string_equality()) {
    if (GetArena() == nullptr) {
      delete equality_type_.string_equality_;
    }
    clear_has_equality_type();
  }
}
inline ::delivery::StringEquality* EqualV2::release_string_equality() {
  // @@protoc_insertion_point(field_release:delivery.EqualV2.string_equality)
  if (_internal_has_string_equality()) {
    clear_has_equality_type();
      ::delivery::StringEquality* temp = equality_type_.string_equality_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    equality_type_.string_equality_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::delivery::StringEquality& EqualV2::_internal_string_equality() const {
  return _internal_has_string_equality()
      ? *equality_type_.string_equality_
      : reinterpret_cast< ::delivery::StringEquality&>(::delivery::_StringEquality_default_instance_);
}
inline const ::delivery::StringEquality& EqualV2::string_equality() const {
  // @@protoc_insertion_point(field_get:delivery.EqualV2.string_equality)
  return _internal_string_equality();
}
inline ::delivery::StringEquality* EqualV2::unsafe_arena_release_string_equality() {
  // @@protoc_insertion_point(field_unsafe_arena_release:delivery.EqualV2.string_equality)
  if (_internal_has_string_equality()) {
    clear_has_equality_type();
    ::delivery::StringEquality* temp = equality_type_.string_equality_;
    equality_type_.string_equality_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EqualV2::unsafe_arena_set_allocated_string_equality(::delivery::StringEquality* string_equality) {
  clear_equality_type();
  if (string_equality) {
    set_has_string_equality();
    equality_type_.string_equality_ = string_equality;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.EqualV2.string_equality)
}
inline ::delivery::StringEquality* EqualV2::_internal_mutable_string_equality() {
  if (!_internal_has_string_equality()) {
    clear_equality_type();
    set_has_string_equality();
    equality_type_.string_equality_ = CreateMaybeMessage< ::delivery::StringEquality >(GetArena());
  }
  return equality_type_.string_equality_;
}
inline ::delivery::StringEquality* EqualV2::mutable_string_equality() {
  // @@protoc_insertion_point(field_mutable:delivery.EqualV2.string_equality)
  return _internal_mutable_string_equality();
}

inline bool EqualV2::has_equality_type() const {
  return equality_type_case() != EQUALITY_TYPE_NOT_SET;
}
inline void EqualV2::clear_has_equality_type() {
  _oneof_case_[0] = EQUALITY_TYPE_NOT_SET;
}
inline EqualV2::EqualityTypeCase EqualV2::equality_type_case() const {
  return EqualV2::EqualityTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Equal

// float compared_to = 1 [json_name = "comparedTo"];
inline void Equal::clear_compared_to() {
  compared_to_ = 0;
}
inline float Equal::_internal_compared_to() const {
  return compared_to_;
}
inline float Equal::compared_to() const {
  // @@protoc_insertion_point(field_get:delivery.Equal.compared_to)
  return _internal_compared_to();
}
inline void Equal::_internal_set_compared_to(float value) {
  
  compared_to_ = value;
}
inline void Equal::set_compared_to(float value) {
  _internal_set_compared_to(value);
  // @@protoc_insertion_point(field_set:delivery.Equal.compared_to)
}

// float tolerance = 2 [json_name = "tolerance"];
inline void Equal::clear_tolerance() {
  tolerance_ = 0;
}
inline float Equal::_internal_tolerance() const {
  return tolerance_;
}
inline float Equal::tolerance() const {
  // @@protoc_insertion_point(field_get:delivery.Equal.tolerance)
  return _internal_tolerance();
}
inline void Equal::_internal_set_tolerance(float value) {
  
  tolerance_ = value;
}
inline void Equal::set_tolerance(float value) {
  _internal_set_tolerance(value);
  // @@protoc_insertion_point(field_set:delivery.Equal.tolerance)
}

// -------------------------------------------------------------------

// StringEquality

// string raw = 1 [json_name = "raw"];
inline bool StringEquality::_internal_has_raw() const {
  return value_case() == kRaw;
}
inline bool StringEquality::has_raw() const {
  return _internal_has_raw();
}
inline void StringEquality::set_has_raw() {
  _oneof_case_[0] = kRaw;
}
inline void StringEquality::clear_raw() {
  if (_internal_has_raw()) {
    value_.raw_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
    clear_has_value();
  }
}
inline const std::string& StringEquality::raw() const {
  // @@protoc_insertion_point(field_get:delivery.StringEquality.raw)
  return _internal_raw();
}
inline void StringEquality::set_raw(const std::string& value) {
  _internal_set_raw(value);
  // @@protoc_insertion_point(field_set:delivery.StringEquality.raw)
}
inline std::string* StringEquality::mutable_raw() {
  // @@protoc_insertion_point(field_mutable:delivery.StringEquality.raw)
  return _internal_mutable_raw();
}
inline const std::string& StringEquality::_internal_raw() const {
  if (_internal_has_raw()) {
    return value_.raw_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void StringEquality::_internal_set_raw(const std::string& value) {
  if (!_internal_has_raw()) {
    clear_value();
    set_has_raw();
    value_.raw_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.raw_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void StringEquality::set_raw(std::string&& value) {
  // @@protoc_insertion_point(field_set:delivery.StringEquality.raw)
  if (!_internal_has_raw()) {
    clear_value();
    set_has_raw();
    value_.raw_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.raw_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:delivery.StringEquality.raw)
}
inline void StringEquality::set_raw(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_raw()) {
    clear_value();
    set_has_raw();
    value_.raw_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.raw_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:delivery.StringEquality.raw)
}
inline void StringEquality::set_raw(const char* value,
                             size_t size) {
  if (!_internal_has_raw()) {
    clear_value();
    set_has_raw();
    value_.raw_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.raw_.Set(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:delivery.StringEquality.raw)
}
inline std::string* StringEquality::_internal_mutable_raw() {
  if (!_internal_has_raw()) {
    clear_value();
    set_has_raw();
    value_.raw_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return value_.raw_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* StringEquality::release_raw() {
  // @@protoc_insertion_point(field_release:delivery.StringEquality.raw)
  if (_internal_has_raw()) {
    clear_has_value();
    return value_.raw_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void StringEquality::set_allocated_raw(std::string* raw) {
  if (has_value()) {
    clear_value();
  }
  if (raw != nullptr) {
    set_has_raw();
    value_.raw_.UnsafeSetDefault(raw);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(raw);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:delivery.StringEquality.raw)
}

inline bool StringEquality::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void StringEquality::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline StringEquality::ValueCase StringEquality::value_case() const {
  return StringEquality::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GreaterThan

// float compared_to = 1 [json_name = "comparedTo"];
inline void GreaterThan::clear_compared_to() {
  compared_to_ = 0;
}
inline float GreaterThan::_internal_compared_to() const {
  return compared_to_;
}
inline float GreaterThan::compared_to() const {
  // @@protoc_insertion_point(field_get:delivery.GreaterThan.compared_to)
  return _internal_compared_to();
}
inline void GreaterThan::_internal_set_compared_to(float value) {
  
  compared_to_ = value;
}
inline void GreaterThan::set_compared_to(float value) {
  _internal_set_compared_to(value);
  // @@protoc_insertion_point(field_set:delivery.GreaterThan.compared_to)
}

// bool or_equal = 2 [json_name = "orEqual"];
inline void GreaterThan::clear_or_equal() {
  or_equal_ = false;
}
inline bool GreaterThan::_internal_or_equal() const {
  return or_equal_;
}
inline bool GreaterThan::or_equal() const {
  // @@protoc_insertion_point(field_get:delivery.GreaterThan.or_equal)
  return _internal_or_equal();
}
inline void GreaterThan::_internal_set_or_equal(bool value) {
  
  or_equal_ = value;
}
inline void GreaterThan::set_or_equal(bool value) {
  _internal_set_or_equal(value);
  // @@protoc_insertion_point(field_set:delivery.GreaterThan.or_equal)
}

// -------------------------------------------------------------------

// LessThan

// float compared_to = 1 [json_name = "comparedTo"];
inline void LessThan::clear_compared_to() {
  compared_to_ = 0;
}
inline float LessThan::_internal_compared_to() const {
  return compared_to_;
}
inline float LessThan::compared_to() const {
  // @@protoc_insertion_point(field_get:delivery.LessThan.compared_to)
  return _internal_compared_to();
}
inline void LessThan::_internal_set_compared_to(float value) {
  
  compared_to_ = value;
}
inline void LessThan::set_compared_to(float value) {
  _internal_set_compared_to(value);
  // @@protoc_insertion_point(field_set:delivery.LessThan.compared_to)
}

// bool or_equal = 2 [json_name = "orEqual"];
inline void LessThan::clear_or_equal() {
  or_equal_ = false;
}
inline bool LessThan::_internal_or_equal() const {
  return or_equal_;
}
inline bool LessThan::or_equal() const {
  // @@protoc_insertion_point(field_get:delivery.LessThan.or_equal)
  return _internal_or_equal();
}
inline void LessThan::_internal_set_or_equal(bool value) {
  
  or_equal_ = value;
}
inline void LessThan::set_or_equal(bool value) {
  _internal_set_or_equal(value);
  // @@protoc_insertion_point(field_set:delivery.LessThan.or_equal)
}

// -------------------------------------------------------------------

// Interval

// float upper_bound = 1 [json_name = "upperBound"];
inline void Interval::clear_upper_bound() {
  upper_bound_ = 0;
}
inline float Interval::_internal_upper_bound() const {
  return upper_bound_;
}
inline float Interval::upper_bound() const {
  // @@protoc_insertion_point(field_get:delivery.Interval.upper_bound)
  return _internal_upper_bound();
}
inline void Interval::_internal_set_upper_bound(float value) {
  
  upper_bound_ = value;
}
inline void Interval::set_upper_bound(float value) {
  _internal_set_upper_bound(value);
  // @@protoc_insertion_point(field_set:delivery.Interval.upper_bound)
}

// float lower_bound = 2 [json_name = "lowerBound"];
inline void Interval::clear_lower_bound() {
  lower_bound_ = 0;
}
inline float Interval::_internal_lower_bound() const {
  return lower_bound_;
}
inline float Interval::lower_bound() const {
  // @@protoc_insertion_point(field_get:delivery.Interval.lower_bound)
  return _internal_lower_bound();
}
inline void Interval::_internal_set_lower_bound(float value) {
  
  lower_bound_ = value;
}
inline void Interval::set_lower_bound(float value) {
  _internal_set_lower_bound(value);
  // @@protoc_insertion_point(field_set:delivery.Interval.lower_bound)
}

// bool lower_inclusive = 3 [json_name = "lowerInclusive"];
inline void Interval::clear_lower_inclusive() {
  lower_inclusive_ = false;
}
inline bool Interval::_internal_lower_inclusive() const {
  return lower_inclusive_;
}
inline bool Interval::lower_inclusive() const {
  // @@protoc_insertion_point(field_get:delivery.Interval.lower_inclusive)
  return _internal_lower_inclusive();
}
inline void Interval::_internal_set_lower_inclusive(bool value) {
  
  lower_inclusive_ = value;
}
inline void Interval::set_lower_inclusive(bool value) {
  _internal_set_lower_inclusive(value);
  // @@protoc_insertion_point(field_set:delivery.Interval.lower_inclusive)
}

// bool upper_inclusive = 4 [json_name = "upperInclusive"];
inline void Interval::clear_upper_inclusive() {
  upper_inclusive_ = false;
}
inline bool Interval::_internal_upper_inclusive() const {
  return upper_inclusive_;
}
inline bool Interval::upper_inclusive() const {
  // @@protoc_insertion_point(field_get:delivery.Interval.upper_inclusive)
  return _internal_upper_inclusive();
}
inline void Interval::_internal_set_upper_inclusive(bool value) {
  
  upper_inclusive_ = value;
}
inline void Interval::set_upper_inclusive(bool value) {
  _internal_set_upper_inclusive(value);
  // @@protoc_insertion_point(field_set:delivery.Interval.upper_inclusive)
}

// -------------------------------------------------------------------

// PositiveRule

// double select_pct = 1 [json_name = "selectPct"];
inline bool PositiveRule::_internal_has_select_pct() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PositiveRule::has_select_pct() const {
  return _internal_has_select_pct();
}
inline void PositiveRule::clear_select_pct() {
  select_pct_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double PositiveRule::_internal_select_pct() const {
  return select_pct_;
}
inline double PositiveRule::select_pct() const {
  // @@protoc_insertion_point(field_get:delivery.PositiveRule.select_pct)
  return _internal_select_pct();
}
inline void PositiveRule::_internal_set_select_pct(double value) {
  _has_bits_[0] |= 0x00000001u;
  select_pct_ = value;
}
inline void PositiveRule::set_select_pct(double value) {
  _internal_set_select_pct(value);
  // @@protoc_insertion_point(field_set:delivery.PositiveRule.select_pct)
}

// uint64 min_pos = 2 [json_name = "minPos"];
inline bool PositiveRule::_internal_has_min_pos() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PositiveRule::has_min_pos() const {
  return _internal_has_min_pos();
}
inline void PositiveRule::clear_min_pos() {
  min_pos_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PositiveRule::_internal_min_pos() const {
  return min_pos_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PositiveRule::min_pos() const {
  // @@protoc_insertion_point(field_get:delivery.PositiveRule.min_pos)
  return _internal_min_pos();
}
inline void PositiveRule::_internal_set_min_pos(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  min_pos_ = value;
}
inline void PositiveRule::set_min_pos(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_min_pos(value);
  // @@protoc_insertion_point(field_set:delivery.PositiveRule.min_pos)
}

// uint64 max_pos = 3 [json_name = "maxPos"];
inline bool PositiveRule::_internal_has_max_pos() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PositiveRule::has_max_pos() const {
  return _internal_has_max_pos();
}
inline void PositiveRule::clear_max_pos() {
  max_pos_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PositiveRule::_internal_max_pos() const {
  return max_pos_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 PositiveRule::max_pos() const {
  // @@protoc_insertion_point(field_get:delivery.PositiveRule.max_pos)
  return _internal_max_pos();
}
inline void PositiveRule::_internal_set_max_pos(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  max_pos_ = value;
}
inline void PositiveRule::set_max_pos(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_max_pos(value);
  // @@protoc_insertion_point(field_set:delivery.PositiveRule.max_pos)
}

// -------------------------------------------------------------------

// InsertRule

// double select_pct = 1 [json_name = "selectPct"];
inline bool InsertRule::_internal_has_select_pct() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InsertRule::has_select_pct() const {
  return _internal_has_select_pct();
}
inline void InsertRule::clear_select_pct() {
  select_pct_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double InsertRule::_internal_select_pct() const {
  return select_pct_;
}
inline double InsertRule::select_pct() const {
  // @@protoc_insertion_point(field_get:delivery.InsertRule.select_pct)
  return _internal_select_pct();
}
inline void InsertRule::_internal_set_select_pct(double value) {
  _has_bits_[0] |= 0x00000001u;
  select_pct_ = value;
}
inline void InsertRule::set_select_pct(double value) {
  _internal_set_select_pct(value);
  // @@protoc_insertion_point(field_set:delivery.InsertRule.select_pct)
}

// uint64 min_pos = 2 [json_name = "minPos"];
inline bool InsertRule::_internal_has_min_pos() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InsertRule::has_min_pos() const {
  return _internal_has_min_pos();
}
inline void InsertRule::clear_min_pos() {
  min_pos_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 InsertRule::_internal_min_pos() const {
  return min_pos_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 InsertRule::min_pos() const {
  // @@protoc_insertion_point(field_get:delivery.InsertRule.min_pos)
  return _internal_min_pos();
}
inline void InsertRule::_internal_set_min_pos(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  min_pos_ = value;
}
inline void InsertRule::set_min_pos(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_min_pos(value);
  // @@protoc_insertion_point(field_set:delivery.InsertRule.min_pos)
}

// uint64 max_pos = 3 [json_name = "maxPos"];
inline bool InsertRule::_internal_has_max_pos() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool InsertRule::has_max_pos() const {
  return _internal_has_max_pos();
}
inline void InsertRule::clear_max_pos() {
  max_pos_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 InsertRule::_internal_max_pos() const {
  return max_pos_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 InsertRule::max_pos() const {
  // @@protoc_insertion_point(field_get:delivery.InsertRule.max_pos)
  return _internal_max_pos();
}
inline void InsertRule::_internal_set_max_pos(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  max_pos_ = value;
}
inline void InsertRule::set_max_pos(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_max_pos(value);
  // @@protoc_insertion_point(field_set:delivery.InsertRule.max_pos)
}

// bool applies_to_all_insertions = 5 [json_name = "appliesToAllInsertions"];
inline void InsertRule::clear_applies_to_all_insertions() {
  applies_to_all_insertions_ = false;
}
inline bool InsertRule::_internal_applies_to_all_insertions() const {
  return applies_to_all_insertions_;
}
inline bool InsertRule::applies_to_all_insertions() const {
  // @@protoc_insertion_point(field_get:delivery.InsertRule.applies_to_all_insertions)
  return _internal_applies_to_all_insertions();
}
inline void InsertRule::_internal_set_applies_to_all_insertions(bool value) {
  
  applies_to_all_insertions_ = value;
}
inline void InsertRule::set_applies_to_all_insertions(bool value) {
  _internal_set_applies_to_all_insertions(value);
  // @@protoc_insertion_point(field_set:delivery.InsertRule.applies_to_all_insertions)
}

// .delivery.RankingMethod ranking_method = 6 [json_name = "rankingMethod"];
inline void InsertRule::clear_ranking_method() {
  ranking_method_ = 0;
}
inline ::delivery::RankingMethod InsertRule::_internal_ranking_method() const {
  return static_cast< ::delivery::RankingMethod >(ranking_method_);
}
inline ::delivery::RankingMethod InsertRule::ranking_method() const {
  // @@protoc_insertion_point(field_get:delivery.InsertRule.ranking_method)
  return _internal_ranking_method();
}
inline void InsertRule::_internal_set_ranking_method(::delivery::RankingMethod value) {
  
  ranking_method_ = value;
}
inline void InsertRule::set_ranking_method(::delivery::RankingMethod value) {
  _internal_set_ranking_method(value);
  // @@protoc_insertion_point(field_set:delivery.InsertRule.ranking_method)
}

// -------------------------------------------------------------------

// NegativeRule

// double pluck_pct = 1 [json_name = "pluckPct"];
inline bool NegativeRule::_internal_has_pluck_pct() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NegativeRule::has_pluck_pct() const {
  return _internal_has_pluck_pct();
}
inline void NegativeRule::clear_pluck_pct() {
  pluck_pct_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double NegativeRule::_internal_pluck_pct() const {
  return pluck_pct_;
}
inline double NegativeRule::pluck_pct() const {
  // @@protoc_insertion_point(field_get:delivery.NegativeRule.pluck_pct)
  return _internal_pluck_pct();
}
inline void NegativeRule::_internal_set_pluck_pct(double value) {
  _has_bits_[0] |= 0x00000001u;
  pluck_pct_ = value;
}
inline void NegativeRule::set_pluck_pct(double value) {
  _internal_set_pluck_pct(value);
  // @@protoc_insertion_point(field_set:delivery.NegativeRule.pluck_pct)
}

// uint64 forbid_less_pos = 2 [json_name = "forbidLessPos"];
inline bool NegativeRule::_internal_has_forbid_less_pos() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NegativeRule::has_forbid_less_pos() const {
  return _internal_has_forbid_less_pos();
}
inline void NegativeRule::clear_forbid_less_pos() {
  forbid_less_pos_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NegativeRule::_internal_forbid_less_pos() const {
  return forbid_less_pos_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NegativeRule::forbid_less_pos() const {
  // @@protoc_insertion_point(field_get:delivery.NegativeRule.forbid_less_pos)
  return _internal_forbid_less_pos();
}
inline void NegativeRule::_internal_set_forbid_less_pos(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  forbid_less_pos_ = value;
}
inline void NegativeRule::set_forbid_less_pos(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_forbid_less_pos(value);
  // @@protoc_insertion_point(field_set:delivery.NegativeRule.forbid_less_pos)
}

// uint64 min_spacing = 3 [json_name = "minSpacing"];
inline bool NegativeRule::_internal_has_min_spacing() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NegativeRule::has_min_spacing() const {
  return _internal_has_min_spacing();
}
inline void NegativeRule::clear_min_spacing() {
  min_spacing_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NegativeRule::_internal_min_spacing() const {
  return min_spacing_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NegativeRule::min_spacing() const {
  // @@protoc_insertion_point(field_get:delivery.NegativeRule.min_spacing)
  return _internal_min_spacing();
}
inline void NegativeRule::_internal_set_min_spacing(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  min_spacing_ = value;
}
inline void NegativeRule::set_min_spacing(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_min_spacing(value);
  // @@protoc_insertion_point(field_set:delivery.NegativeRule.min_spacing)
}

// uint64 forbid_greater_pos = 4 [json_name = "forbidGreaterPos"];
inline bool NegativeRule::_internal_has_forbid_greater_pos() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool NegativeRule::has_forbid_greater_pos() const {
  return _internal_has_forbid_greater_pos();
}
inline void NegativeRule::clear_forbid_greater_pos() {
  forbid_greater_pos_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NegativeRule::_internal_forbid_greater_pos() const {
  return forbid_greater_pos_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NegativeRule::forbid_greater_pos() const {
  // @@protoc_insertion_point(field_get:delivery.NegativeRule.forbid_greater_pos)
  return _internal_forbid_greater_pos();
}
inline void NegativeRule::_internal_set_forbid_greater_pos(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  forbid_greater_pos_ = value;
}
inline void NegativeRule::set_forbid_greater_pos(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_forbid_greater_pos(value);
  // @@protoc_insertion_point(field_set:delivery.NegativeRule.forbid_greater_pos)
}

// uint64 max_count = 5 [json_name = "maxCount"];
inline bool NegativeRule::_internal_has_max_count() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool NegativeRule::has_max_count() const {
  return _internal_has_max_count();
}
inline void NegativeRule::clear_max_count() {
  max_count_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NegativeRule::_internal_max_count() const {
  return max_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 NegativeRule::max_count() const {
  // @@protoc_insertion_point(field_get:delivery.NegativeRule.max_count)
  return _internal_max_count();
}
inline void NegativeRule::_internal_set_max_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  max_count_ = value;
}
inline void NegativeRule::set_max_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_max_count(value);
  // @@protoc_insertion_point(field_set:delivery.NegativeRule.max_count)
}

// -------------------------------------------------------------------

// DiversityRule

// double multi = 1 [json_name = "multi"];
inline bool DiversityRule::_internal_has_multi() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DiversityRule::has_multi() const {
  return _internal_has_multi();
}
inline void DiversityRule::clear_multi() {
  multi_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double DiversityRule::_internal_multi() const {
  return multi_;
}
inline double DiversityRule::multi() const {
  // @@protoc_insertion_point(field_get:delivery.DiversityRule.multi)
  return _internal_multi();
}
inline void DiversityRule::_internal_set_multi(double value) {
  _has_bits_[0] |= 0x00000001u;
  multi_ = value;
}
inline void DiversityRule::set_multi(double value) {
  _internal_set_multi(value);
  // @@protoc_insertion_point(field_set:delivery.DiversityRule.multi)
}

// -------------------------------------------------------------------

// QualityScoreConfig

// repeated .delivery.QualityScoreTerm weighted_sum_term = 1 [json_name = "weightedSumTerm"];
inline int QualityScoreConfig::_internal_weighted_sum_term_size() const {
  return weighted_sum_term_.size();
}
inline int QualityScoreConfig::weighted_sum_term_size() const {
  return _internal_weighted_sum_term_size();
}
inline void QualityScoreConfig::clear_weighted_sum_term() {
  weighted_sum_term_.Clear();
}
inline ::delivery::QualityScoreTerm* QualityScoreConfig::mutable_weighted_sum_term(int index) {
  // @@protoc_insertion_point(field_mutable:delivery.QualityScoreConfig.weighted_sum_term)
  return weighted_sum_term_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::QualityScoreTerm >*
QualityScoreConfig::mutable_weighted_sum_term() {
  // @@protoc_insertion_point(field_mutable_list:delivery.QualityScoreConfig.weighted_sum_term)
  return &weighted_sum_term_;
}
inline const ::delivery::QualityScoreTerm& QualityScoreConfig::_internal_weighted_sum_term(int index) const {
  return weighted_sum_term_.Get(index);
}
inline const ::delivery::QualityScoreTerm& QualityScoreConfig::weighted_sum_term(int index) const {
  // @@protoc_insertion_point(field_get:delivery.QualityScoreConfig.weighted_sum_term)
  return _internal_weighted_sum_term(index);
}
inline ::delivery::QualityScoreTerm* QualityScoreConfig::_internal_add_weighted_sum_term() {
  return weighted_sum_term_.Add();
}
inline ::delivery::QualityScoreTerm* QualityScoreConfig::add_weighted_sum_term() {
  // @@protoc_insertion_point(field_add:delivery.QualityScoreConfig.weighted_sum_term)
  return _internal_add_weighted_sum_term();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::QualityScoreTerm >&
QualityScoreConfig::weighted_sum_term() const {
  // @@protoc_insertion_point(field_list:delivery.QualityScoreConfig.weighted_sum_term)
  return weighted_sum_term_;
}

// -------------------------------------------------------------------

// QualityScoreTerms

// repeated .delivery.QualityScoreTerm quality_score_terms = 1 [json_name = "qualityScoreTerms"];
inline int QualityScoreTerms::_internal_quality_score_terms_size() const {
  return quality_score_terms_.size();
}
inline int QualityScoreTerms::quality_score_terms_size() const {
  return _internal_quality_score_terms_size();
}
inline void QualityScoreTerms::clear_quality_score_terms() {
  quality_score_terms_.Clear();
}
inline ::delivery::QualityScoreTerm* QualityScoreTerms::mutable_quality_score_terms(int index) {
  // @@protoc_insertion_point(field_mutable:delivery.QualityScoreTerms.quality_score_terms)
  return quality_score_terms_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::QualityScoreTerm >*
QualityScoreTerms::mutable_quality_score_terms() {
  // @@protoc_insertion_point(field_mutable_list:delivery.QualityScoreTerms.quality_score_terms)
  return &quality_score_terms_;
}
inline const ::delivery::QualityScoreTerm& QualityScoreTerms::_internal_quality_score_terms(int index) const {
  return quality_score_terms_.Get(index);
}
inline const ::delivery::QualityScoreTerm& QualityScoreTerms::quality_score_terms(int index) const {
  // @@protoc_insertion_point(field_get:delivery.QualityScoreTerms.quality_score_terms)
  return _internal_quality_score_terms(index);
}
inline ::delivery::QualityScoreTerm* QualityScoreTerms::_internal_add_quality_score_terms() {
  return quality_score_terms_.Add();
}
inline ::delivery::QualityScoreTerm* QualityScoreTerms::add_quality_score_terms() {
  // @@protoc_insertion_point(field_add:delivery.QualityScoreTerms.quality_score_terms)
  return _internal_add_quality_score_terms();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::delivery::QualityScoreTerm >&
QualityScoreTerms::quality_score_terms() const {
  // @@protoc_insertion_point(field_list:delivery.QualityScoreTerms.quality_score_terms)
  return quality_score_terms_;
}

// -------------------------------------------------------------------

// QualityScoreTerm

// string attribute_name = 1 [json_name = "attributeName"];
inline bool QualityScoreTerm::_internal_has_attribute_name() const {
  return fetch_method_case() == kAttributeName;
}
inline bool QualityScoreTerm::has_attribute_name() const {
  return _internal_has_attribute_name();
}
inline void QualityScoreTerm::set_has_attribute_name() {
  _oneof_case_[0] = kAttributeName;
}
inline void QualityScoreTerm::clear_attribute_name() {
  if (_internal_has_attribute_name()) {
    fetch_method_.attribute_name_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
    clear_has_fetch_method();
  }
}
inline const std::string& QualityScoreTerm::attribute_name() const {
  // @@protoc_insertion_point(field_get:delivery.QualityScoreTerm.attribute_name)
  return _internal_attribute_name();
}
inline void QualityScoreTerm::set_attribute_name(const std::string& value) {
  _internal_set_attribute_name(value);
  // @@protoc_insertion_point(field_set:delivery.QualityScoreTerm.attribute_name)
}
inline std::string* QualityScoreTerm::mutable_attribute_name() {
  // @@protoc_insertion_point(field_mutable:delivery.QualityScoreTerm.attribute_name)
  return _internal_mutable_attribute_name();
}
inline const std::string& QualityScoreTerm::_internal_attribute_name() const {
  if (_internal_has_attribute_name()) {
    return fetch_method_.attribute_name_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void QualityScoreTerm::_internal_set_attribute_name(const std::string& value) {
  if (!_internal_has_attribute_name()) {
    clear_fetch_method();
    set_has_attribute_name();
    fetch_method_.attribute_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  fetch_method_.attribute_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void QualityScoreTerm::set_attribute_name(std::string&& value) {
  // @@protoc_insertion_point(field_set:delivery.QualityScoreTerm.attribute_name)
  if (!_internal_has_attribute_name()) {
    clear_fetch_method();
    set_has_attribute_name();
    fetch_method_.attribute_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  fetch_method_.attribute_name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:delivery.QualityScoreTerm.attribute_name)
}
inline void QualityScoreTerm::set_attribute_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_attribute_name()) {
    clear_fetch_method();
    set_has_attribute_name();
    fetch_method_.attribute_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  fetch_method_.attribute_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
      ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:delivery.QualityScoreTerm.attribute_name)
}
inline void QualityScoreTerm::set_attribute_name(const char* value,
                             size_t size) {
  if (!_internal_has_attribute_name()) {
    clear_fetch_method();
    set_has_attribute_name();
    fetch_method_.attribute_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  fetch_method_.attribute_name_.Set(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size),
      GetArena());
  // @@protoc_insertion_point(field_set_pointer:delivery.QualityScoreTerm.attribute_name)
}
inline std::string* QualityScoreTerm::_internal_mutable_attribute_name() {
  if (!_internal_has_attribute_name()) {
    clear_fetch_method();
    set_has_attribute_name();
    fetch_method_.attribute_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return fetch_method_.attribute_name_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* QualityScoreTerm::release_attribute_name() {
  // @@protoc_insertion_point(field_release:delivery.QualityScoreTerm.attribute_name)
  if (_internal_has_attribute_name()) {
    clear_has_fetch_method();
    return fetch_method_.attribute_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  } else {
    return nullptr;
  }
}
inline void QualityScoreTerm::set_allocated_attribute_name(std::string* attribute_name) {
  if (has_fetch_method()) {
    clear_fetch_method();
  }
  if (attribute_name != nullptr) {
    set_has_attribute_name();
    fetch_method_.attribute_name_.UnsafeSetDefault(attribute_name);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena();
    if (arena != nullptr) {
      arena->Own(attribute_name);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:delivery.QualityScoreTerm.attribute_name)
}

// .delivery.QualityScoreTerms product = 3 [json_name = "product"];
inline bool QualityScoreTerm::_internal_has_product() const {
  return fetch_method_case() == kProduct;
}
inline bool QualityScoreTerm::has_product() const {
  return _internal_has_product();
}
inline void QualityScoreTerm::set_has_product() {
  _oneof_case_[0] = kProduct;
}
inline void QualityScoreTerm::clear_product() {
  if (_internal_has_product()) {
    if (GetArena() == nullptr) {
      delete fetch_method_.product_;
    }
    clear_has_fetch_method();
  }
}
inline ::delivery::QualityScoreTerms* QualityScoreTerm::release_product() {
  // @@protoc_insertion_point(field_release:delivery.QualityScoreTerm.product)
  if (_internal_has_product()) {
    clear_has_fetch_method();
      ::delivery::QualityScoreTerms* temp = fetch_method_.product_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    fetch_method_.product_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::delivery::QualityScoreTerms& QualityScoreTerm::_internal_product() const {
  return _internal_has_product()
      ? *fetch_method_.product_
      : reinterpret_cast< ::delivery::QualityScoreTerms&>(::delivery::_QualityScoreTerms_default_instance_);
}
inline const ::delivery::QualityScoreTerms& QualityScoreTerm::product() const {
  // @@protoc_insertion_point(field_get:delivery.QualityScoreTerm.product)
  return _internal_product();
}
inline ::delivery::QualityScoreTerms* QualityScoreTerm::unsafe_arena_release_product() {
  // @@protoc_insertion_point(field_unsafe_arena_release:delivery.QualityScoreTerm.product)
  if (_internal_has_product()) {
    clear_has_fetch_method();
    ::delivery::QualityScoreTerms* temp = fetch_method_.product_;
    fetch_method_.product_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void QualityScoreTerm::unsafe_arena_set_allocated_product(::delivery::QualityScoreTerms* product) {
  clear_fetch_method();
  if (product) {
    set_has_product();
    fetch_method_.product_ = product;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.QualityScoreTerm.product)
}
inline ::delivery::QualityScoreTerms* QualityScoreTerm::_internal_mutable_product() {
  if (!_internal_has_product()) {
    clear_fetch_method();
    set_has_product();
    fetch_method_.product_ = CreateMaybeMessage< ::delivery::QualityScoreTerms >(GetArena());
  }
  return fetch_method_.product_;
}
inline ::delivery::QualityScoreTerms* QualityScoreTerm::mutable_product() {
  // @@protoc_insertion_point(field_mutable:delivery.QualityScoreTerm.product)
  return _internal_mutable_product();
}

// float fetch_high = 10 [json_name = "fetchHigh"];
inline bool QualityScoreTerm::_internal_has_fetch_high() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool QualityScoreTerm::has_fetch_high() const {
  return _internal_has_fetch_high();
}
inline void QualityScoreTerm::clear_fetch_high() {
  fetch_high_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float QualityScoreTerm::_internal_fetch_high() const {
  return fetch_high_;
}
inline float QualityScoreTerm::fetch_high() const {
  // @@protoc_insertion_point(field_get:delivery.QualityScoreTerm.fetch_high)
  return _internal_fetch_high();
}
inline void QualityScoreTerm::_internal_set_fetch_high(float value) {
  _has_bits_[0] |= 0x00000002u;
  fetch_high_ = value;
}
inline void QualityScoreTerm::set_fetch_high(float value) {
  _internal_set_fetch_high(value);
  // @@protoc_insertion_point(field_set:delivery.QualityScoreTerm.fetch_high)
}

// float fetch_low = 11 [json_name = "fetchLow"];
inline bool QualityScoreTerm::_internal_has_fetch_low() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool QualityScoreTerm::has_fetch_low() const {
  return _internal_has_fetch_low();
}
inline void QualityScoreTerm::clear_fetch_low() {
  fetch_low_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float QualityScoreTerm::_internal_fetch_low() const {
  return fetch_low_;
}
inline float QualityScoreTerm::fetch_low() const {
  // @@protoc_insertion_point(field_get:delivery.QualityScoreTerm.fetch_low)
  return _internal_fetch_low();
}
inline void QualityScoreTerm::_internal_set_fetch_low(float value) {
  _has_bits_[0] |= 0x00000004u;
  fetch_low_ = value;
}
inline void QualityScoreTerm::set_fetch_low(float value) {
  _internal_set_fetch_low(value);
  // @@protoc_insertion_point(field_set:delivery.QualityScoreTerm.fetch_low)
}

// float weight = 12 [json_name = "weight"];
inline bool QualityScoreTerm::_internal_has_weight() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool QualityScoreTerm::has_weight() const {
  return _internal_has_weight();
}
inline void QualityScoreTerm::clear_weight() {
  weight_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float QualityScoreTerm::_internal_weight() const {
  return weight_;
}
inline float QualityScoreTerm::weight() const {
  // @@protoc_insertion_point(field_get:delivery.QualityScoreTerm.weight)
  return _internal_weight();
}
inline void QualityScoreTerm::_internal_set_weight(float value) {
  _has_bits_[0] |= 0x00000008u;
  weight_ = value;
}
inline void QualityScoreTerm::set_weight(float value) {
  _internal_set_weight(value);
  // @@protoc_insertion_point(field_set:delivery.QualityScoreTerm.weight)
}

// float offset = 13 [json_name = "offset"];
inline void QualityScoreTerm::clear_offset() {
  offset_ = 0;
}
inline float QualityScoreTerm::_internal_offset() const {
  return offset_;
}
inline float QualityScoreTerm::offset() const {
  // @@protoc_insertion_point(field_get:delivery.QualityScoreTerm.offset)
  return _internal_offset();
}
inline void QualityScoreTerm::_internal_set_offset(float value) {
  
  offset_ = value;
}
inline void QualityScoreTerm::set_offset(float value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:delivery.QualityScoreTerm.offset)
}

// .delivery.TermConditionalEvaluation term_conditional_evaluation = 14 [json_name = "termConditionalEvaluation"];
inline bool QualityScoreTerm::_internal_has_term_conditional_evaluation() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || term_conditional_evaluation_ != nullptr);
  return value;
}
inline bool QualityScoreTerm::has_term_conditional_evaluation() const {
  return _internal_has_term_conditional_evaluation();
}
inline void QualityScoreTerm::clear_term_conditional_evaluation() {
  if (GetArena() == nullptr && term_conditional_evaluation_ != nullptr) {
    delete term_conditional_evaluation_;
  }
  term_conditional_evaluation_ = nullptr;
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::delivery::TermConditionalEvaluation& QualityScoreTerm::_internal_term_conditional_evaluation() const {
  const ::delivery::TermConditionalEvaluation* p = term_conditional_evaluation_;
  return p != nullptr ? *p : reinterpret_cast<const ::delivery::TermConditionalEvaluation&>(
      ::delivery::_TermConditionalEvaluation_default_instance_);
}
inline const ::delivery::TermConditionalEvaluation& QualityScoreTerm::term_conditional_evaluation() const {
  // @@protoc_insertion_point(field_get:delivery.QualityScoreTerm.term_conditional_evaluation)
  return _internal_term_conditional_evaluation();
}
inline void QualityScoreTerm::unsafe_arena_set_allocated_term_conditional_evaluation(
    ::delivery::TermConditionalEvaluation* term_conditional_evaluation) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(term_conditional_evaluation_);
  }
  term_conditional_evaluation_ = term_conditional_evaluation;
  if (term_conditional_evaluation) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.QualityScoreTerm.term_conditional_evaluation)
}
inline ::delivery::TermConditionalEvaluation* QualityScoreTerm::release_term_conditional_evaluation() {
  _has_bits_[0] &= ~0x00000001u;
  ::delivery::TermConditionalEvaluation* temp = term_conditional_evaluation_;
  term_conditional_evaluation_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::delivery::TermConditionalEvaluation* QualityScoreTerm::unsafe_arena_release_term_conditional_evaluation() {
  // @@protoc_insertion_point(field_release:delivery.QualityScoreTerm.term_conditional_evaluation)
  _has_bits_[0] &= ~0x00000001u;
  ::delivery::TermConditionalEvaluation* temp = term_conditional_evaluation_;
  term_conditional_evaluation_ = nullptr;
  return temp;
}
inline ::delivery::TermConditionalEvaluation* QualityScoreTerm::_internal_mutable_term_conditional_evaluation() {
  _has_bits_[0] |= 0x00000001u;
  if (term_conditional_evaluation_ == nullptr) {
    auto* p = CreateMaybeMessage<::delivery::TermConditionalEvaluation>(GetArena());
    term_conditional_evaluation_ = p;
  }
  return term_conditional_evaluation_;
}
inline ::delivery::TermConditionalEvaluation* QualityScoreTerm::mutable_term_conditional_evaluation() {
  // @@protoc_insertion_point(field_mutable:delivery.QualityScoreTerm.term_conditional_evaluation)
  return _internal_mutable_term_conditional_evaluation();
}
inline void QualityScoreTerm::set_allocated_term_conditional_evaluation(::delivery::TermConditionalEvaluation* term_conditional_evaluation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete term_conditional_evaluation_;
  }
  if (term_conditional_evaluation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(term_conditional_evaluation);
    if (message_arena != submessage_arena) {
      term_conditional_evaluation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, term_conditional_evaluation, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  term_conditional_evaluation_ = term_conditional_evaluation;
  // @@protoc_insertion_point(field_set_allocated:delivery.QualityScoreTerm.term_conditional_evaluation)
}

inline bool QualityScoreTerm::has_fetch_method() const {
  return fetch_method_case() != FETCH_METHOD_NOT_SET;
}
inline void QualityScoreTerm::clear_has_fetch_method() {
  _oneof_case_[0] = FETCH_METHOD_NOT_SET;
}
inline QualityScoreTerm::FetchMethodCase QualityScoreTerm::fetch_method_case() const {
  return QualityScoreTerm::FetchMethodCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TermConditionalEvaluation

// float value_if_false = 1 [json_name = "valueIfFalse"];
inline void TermConditionalEvaluation::clear_value_if_false() {
  value_if_false_ = 0;
}
inline float TermConditionalEvaluation::_internal_value_if_false() const {
  return value_if_false_;
}
inline float TermConditionalEvaluation::value_if_false() const {
  // @@protoc_insertion_point(field_get:delivery.TermConditionalEvaluation.value_if_false)
  return _internal_value_if_false();
}
inline void TermConditionalEvaluation::_internal_set_value_if_false(float value) {
  
  value_if_false_ = value;
}
inline void TermConditionalEvaluation::set_value_if_false(float value) {
  _internal_set_value_if_false(value);
  // @@protoc_insertion_point(field_set:delivery.TermConditionalEvaluation.value_if_false)
}

// string attribute_name = 2 [json_name = "attributeName"];
inline void TermConditionalEvaluation::clear_attribute_name() {
  attribute_name_.ClearToEmpty();
}
inline const std::string& TermConditionalEvaluation::attribute_name() const {
  // @@protoc_insertion_point(field_get:delivery.TermConditionalEvaluation.attribute_name)
  return _internal_attribute_name();
}
inline void TermConditionalEvaluation::set_attribute_name(const std::string& value) {
  _internal_set_attribute_name(value);
  // @@protoc_insertion_point(field_set:delivery.TermConditionalEvaluation.attribute_name)
}
inline std::string* TermConditionalEvaluation::mutable_attribute_name() {
  // @@protoc_insertion_point(field_mutable:delivery.TermConditionalEvaluation.attribute_name)
  return _internal_mutable_attribute_name();
}
inline const std::string& TermConditionalEvaluation::_internal_attribute_name() const {
  return attribute_name_.Get();
}
inline void TermConditionalEvaluation::_internal_set_attribute_name(const std::string& value) {
  
  attribute_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void TermConditionalEvaluation::set_attribute_name(std::string&& value) {
  
  attribute_name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:delivery.TermConditionalEvaluation.attribute_name)
}
inline void TermConditionalEvaluation::set_attribute_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  attribute_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:delivery.TermConditionalEvaluation.attribute_name)
}
inline void TermConditionalEvaluation::set_attribute_name(const char* value,
    size_t size) {
  
  attribute_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:delivery.TermConditionalEvaluation.attribute_name)
}
inline std::string* TermConditionalEvaluation::_internal_mutable_attribute_name() {
  
  return attribute_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* TermConditionalEvaluation::release_attribute_name() {
  // @@protoc_insertion_point(field_release:delivery.TermConditionalEvaluation.attribute_name)
  return attribute_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TermConditionalEvaluation::set_allocated_attribute_name(std::string* attribute_name) {
  if (attribute_name != nullptr) {
    
  } else {
    
  }
  attribute_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), attribute_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:delivery.TermConditionalEvaluation.attribute_name)
}

// .delivery.Flag flag = 4 [json_name = "flag"];
inline bool TermConditionalEvaluation::_internal_has_flag() const {
  return eval_method_case() == kFlag;
}
inline bool TermConditionalEvaluation::has_flag() const {
  return _internal_has_flag();
}
inline void TermConditionalEvaluation::set_has_flag() {
  _oneof_case_[0] = kFlag;
}
inline void TermConditionalEvaluation::clear_flag() {
  if (_internal_has_flag()) {
    if (GetArena() == nullptr) {
      delete eval_method_.flag_;
    }
    clear_has_eval_method();
  }
}
inline ::delivery::Flag* TermConditionalEvaluation::release_flag() {
  // @@protoc_insertion_point(field_release:delivery.TermConditionalEvaluation.flag)
  if (_internal_has_flag()) {
    clear_has_eval_method();
      ::delivery::Flag* temp = eval_method_.flag_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    eval_method_.flag_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::delivery::Flag& TermConditionalEvaluation::_internal_flag() const {
  return _internal_has_flag()
      ? *eval_method_.flag_
      : reinterpret_cast< ::delivery::Flag&>(::delivery::_Flag_default_instance_);
}
inline const ::delivery::Flag& TermConditionalEvaluation::flag() const {
  // @@protoc_insertion_point(field_get:delivery.TermConditionalEvaluation.flag)
  return _internal_flag();
}
inline ::delivery::Flag* TermConditionalEvaluation::unsafe_arena_release_flag() {
  // @@protoc_insertion_point(field_unsafe_arena_release:delivery.TermConditionalEvaluation.flag)
  if (_internal_has_flag()) {
    clear_has_eval_method();
    ::delivery::Flag* temp = eval_method_.flag_;
    eval_method_.flag_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TermConditionalEvaluation::unsafe_arena_set_allocated_flag(::delivery::Flag* flag) {
  clear_eval_method();
  if (flag) {
    set_has_flag();
    eval_method_.flag_ = flag;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.TermConditionalEvaluation.flag)
}
inline ::delivery::Flag* TermConditionalEvaluation::_internal_mutable_flag() {
  if (!_internal_has_flag()) {
    clear_eval_method();
    set_has_flag();
    eval_method_.flag_ = CreateMaybeMessage< ::delivery::Flag >(GetArena());
  }
  return eval_method_.flag_;
}
inline ::delivery::Flag* TermConditionalEvaluation::mutable_flag() {
  // @@protoc_insertion_point(field_mutable:delivery.TermConditionalEvaluation.flag)
  return _internal_mutable_flag();
}

// .delivery.GreaterThan greater_than = 6 [json_name = "greaterThan"];
inline bool TermConditionalEvaluation::_internal_has_greater_than() const {
  return eval_method_case() == kGreaterThan;
}
inline bool TermConditionalEvaluation::has_greater_than() const {
  return _internal_has_greater_than();
}
inline void TermConditionalEvaluation::set_has_greater_than() {
  _oneof_case_[0] = kGreaterThan;
}
inline void TermConditionalEvaluation::clear_greater_than() {
  if (_internal_has_greater_than()) {
    if (GetArena() == nullptr) {
      delete eval_method_.greater_than_;
    }
    clear_has_eval_method();
  }
}
inline ::delivery::GreaterThan* TermConditionalEvaluation::release_greater_than() {
  // @@protoc_insertion_point(field_release:delivery.TermConditionalEvaluation.greater_than)
  if (_internal_has_greater_than()) {
    clear_has_eval_method();
      ::delivery::GreaterThan* temp = eval_method_.greater_than_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    eval_method_.greater_than_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::delivery::GreaterThan& TermConditionalEvaluation::_internal_greater_than() const {
  return _internal_has_greater_than()
      ? *eval_method_.greater_than_
      : reinterpret_cast< ::delivery::GreaterThan&>(::delivery::_GreaterThan_default_instance_);
}
inline const ::delivery::GreaterThan& TermConditionalEvaluation::greater_than() const {
  // @@protoc_insertion_point(field_get:delivery.TermConditionalEvaluation.greater_than)
  return _internal_greater_than();
}
inline ::delivery::GreaterThan* TermConditionalEvaluation::unsafe_arena_release_greater_than() {
  // @@protoc_insertion_point(field_unsafe_arena_release:delivery.TermConditionalEvaluation.greater_than)
  if (_internal_has_greater_than()) {
    clear_has_eval_method();
    ::delivery::GreaterThan* temp = eval_method_.greater_than_;
    eval_method_.greater_than_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TermConditionalEvaluation::unsafe_arena_set_allocated_greater_than(::delivery::GreaterThan* greater_than) {
  clear_eval_method();
  if (greater_than) {
    set_has_greater_than();
    eval_method_.greater_than_ = greater_than;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.TermConditionalEvaluation.greater_than)
}
inline ::delivery::GreaterThan* TermConditionalEvaluation::_internal_mutable_greater_than() {
  if (!_internal_has_greater_than()) {
    clear_eval_method();
    set_has_greater_than();
    eval_method_.greater_than_ = CreateMaybeMessage< ::delivery::GreaterThan >(GetArena());
  }
  return eval_method_.greater_than_;
}
inline ::delivery::GreaterThan* TermConditionalEvaluation::mutable_greater_than() {
  // @@protoc_insertion_point(field_mutable:delivery.TermConditionalEvaluation.greater_than)
  return _internal_mutable_greater_than();
}

// .delivery.LessThan less_than = 7 [json_name = "lessThan"];
inline bool TermConditionalEvaluation::_internal_has_less_than() const {
  return eval_method_case() == kLessThan;
}
inline bool TermConditionalEvaluation::has_less_than() const {
  return _internal_has_less_than();
}
inline void TermConditionalEvaluation::set_has_less_than() {
  _oneof_case_[0] = kLessThan;
}
inline void TermConditionalEvaluation::clear_less_than() {
  if (_internal_has_less_than()) {
    if (GetArena() == nullptr) {
      delete eval_method_.less_than_;
    }
    clear_has_eval_method();
  }
}
inline ::delivery::LessThan* TermConditionalEvaluation::release_less_than() {
  // @@protoc_insertion_point(field_release:delivery.TermConditionalEvaluation.less_than)
  if (_internal_has_less_than()) {
    clear_has_eval_method();
      ::delivery::LessThan* temp = eval_method_.less_than_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    eval_method_.less_than_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::delivery::LessThan& TermConditionalEvaluation::_internal_less_than() const {
  return _internal_has_less_than()
      ? *eval_method_.less_than_
      : reinterpret_cast< ::delivery::LessThan&>(::delivery::_LessThan_default_instance_);
}
inline const ::delivery::LessThan& TermConditionalEvaluation::less_than() const {
  // @@protoc_insertion_point(field_get:delivery.TermConditionalEvaluation.less_than)
  return _internal_less_than();
}
inline ::delivery::LessThan* TermConditionalEvaluation::unsafe_arena_release_less_than() {
  // @@protoc_insertion_point(field_unsafe_arena_release:delivery.TermConditionalEvaluation.less_than)
  if (_internal_has_less_than()) {
    clear_has_eval_method();
    ::delivery::LessThan* temp = eval_method_.less_than_;
    eval_method_.less_than_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TermConditionalEvaluation::unsafe_arena_set_allocated_less_than(::delivery::LessThan* less_than) {
  clear_eval_method();
  if (less_than) {
    set_has_less_than();
    eval_method_.less_than_ = less_than;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.TermConditionalEvaluation.less_than)
}
inline ::delivery::LessThan* TermConditionalEvaluation::_internal_mutable_less_than() {
  if (!_internal_has_less_than()) {
    clear_eval_method();
    set_has_less_than();
    eval_method_.less_than_ = CreateMaybeMessage< ::delivery::LessThan >(GetArena());
  }
  return eval_method_.less_than_;
}
inline ::delivery::LessThan* TermConditionalEvaluation::mutable_less_than() {
  // @@protoc_insertion_point(field_mutable:delivery.TermConditionalEvaluation.less_than)
  return _internal_mutable_less_than();
}

// .delivery.Interval interval = 8 [json_name = "interval"];
inline bool TermConditionalEvaluation::_internal_has_interval() const {
  return eval_method_case() == kInterval;
}
inline bool TermConditionalEvaluation::has_interval() const {
  return _internal_has_interval();
}
inline void TermConditionalEvaluation::set_has_interval() {
  _oneof_case_[0] = kInterval;
}
inline void TermConditionalEvaluation::clear_interval() {
  if (_internal_has_interval()) {
    if (GetArena() == nullptr) {
      delete eval_method_.interval_;
    }
    clear_has_eval_method();
  }
}
inline ::delivery::Interval* TermConditionalEvaluation::release_interval() {
  // @@protoc_insertion_point(field_release:delivery.TermConditionalEvaluation.interval)
  if (_internal_has_interval()) {
    clear_has_eval_method();
      ::delivery::Interval* temp = eval_method_.interval_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    eval_method_.interval_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::delivery::Interval& TermConditionalEvaluation::_internal_interval() const {
  return _internal_has_interval()
      ? *eval_method_.interval_
      : reinterpret_cast< ::delivery::Interval&>(::delivery::_Interval_default_instance_);
}
inline const ::delivery::Interval& TermConditionalEvaluation::interval() const {
  // @@protoc_insertion_point(field_get:delivery.TermConditionalEvaluation.interval)
  return _internal_interval();
}
inline ::delivery::Interval* TermConditionalEvaluation::unsafe_arena_release_interval() {
  // @@protoc_insertion_point(field_unsafe_arena_release:delivery.TermConditionalEvaluation.interval)
  if (_internal_has_interval()) {
    clear_has_eval_method();
    ::delivery::Interval* temp = eval_method_.interval_;
    eval_method_.interval_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TermConditionalEvaluation::unsafe_arena_set_allocated_interval(::delivery::Interval* interval) {
  clear_eval_method();
  if (interval) {
    set_has_interval();
    eval_method_.interval_ = interval;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.TermConditionalEvaluation.interval)
}
inline ::delivery::Interval* TermConditionalEvaluation::_internal_mutable_interval() {
  if (!_internal_has_interval()) {
    clear_eval_method();
    set_has_interval();
    eval_method_.interval_ = CreateMaybeMessage< ::delivery::Interval >(GetArena());
  }
  return eval_method_.interval_;
}
inline ::delivery::Interval* TermConditionalEvaluation::mutable_interval() {
  // @@protoc_insertion_point(field_mutable:delivery.TermConditionalEvaluation.interval)
  return _internal_mutable_interval();
}

// .delivery.EqualV2 equal_v2 = 10 [json_name = "equalV2"];
inline bool TermConditionalEvaluation::_internal_has_equal_v2() const {
  return eval_method_case() == kEqualV2;
}
inline bool TermConditionalEvaluation::has_equal_v2() const {
  return _internal_has_equal_v2();
}
inline void TermConditionalEvaluation::set_has_equal_v2() {
  _oneof_case_[0] = kEqualV2;
}
inline void TermConditionalEvaluation::clear_equal_v2() {
  if (_internal_has_equal_v2()) {
    if (GetArena() == nullptr) {
      delete eval_method_.equal_v2_;
    }
    clear_has_eval_method();
  }
}
inline ::delivery::EqualV2* TermConditionalEvaluation::release_equal_v2() {
  // @@protoc_insertion_point(field_release:delivery.TermConditionalEvaluation.equal_v2)
  if (_internal_has_equal_v2()) {
    clear_has_eval_method();
      ::delivery::EqualV2* temp = eval_method_.equal_v2_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    eval_method_.equal_v2_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::delivery::EqualV2& TermConditionalEvaluation::_internal_equal_v2() const {
  return _internal_has_equal_v2()
      ? *eval_method_.equal_v2_
      : reinterpret_cast< ::delivery::EqualV2&>(::delivery::_EqualV2_default_instance_);
}
inline const ::delivery::EqualV2& TermConditionalEvaluation::equal_v2() const {
  // @@protoc_insertion_point(field_get:delivery.TermConditionalEvaluation.equal_v2)
  return _internal_equal_v2();
}
inline ::delivery::EqualV2* TermConditionalEvaluation::unsafe_arena_release_equal_v2() {
  // @@protoc_insertion_point(field_unsafe_arena_release:delivery.TermConditionalEvaluation.equal_v2)
  if (_internal_has_equal_v2()) {
    clear_has_eval_method();
    ::delivery::EqualV2* temp = eval_method_.equal_v2_;
    eval_method_.equal_v2_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TermConditionalEvaluation::unsafe_arena_set_allocated_equal_v2(::delivery::EqualV2* equal_v2) {
  clear_eval_method();
  if (equal_v2) {
    set_has_equal_v2();
    eval_method_.equal_v2_ = equal_v2;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:delivery.TermConditionalEvaluation.equal_v2)
}
inline ::delivery::EqualV2* TermConditionalEvaluation::_internal_mutable_equal_v2() {
  if (!_internal_has_equal_v2()) {
    clear_eval_method();
    set_has_equal_v2();
    eval_method_.equal_v2_ = CreateMaybeMessage< ::delivery::EqualV2 >(GetArena());
  }
  return eval_method_.equal_v2_;
}
inline ::delivery::EqualV2* TermConditionalEvaluation::mutable_equal_v2() {
  // @@protoc_insertion_point(field_mutable:delivery.TermConditionalEvaluation.equal_v2)
  return _internal_mutable_equal_v2();
}

inline bool TermConditionalEvaluation::has_eval_method() const {
  return eval_method_case() != EVAL_METHOD_NOT_SET;
}
inline void TermConditionalEvaluation::clear_has_eval_method() {
  _oneof_case_[0] = EVAL_METHOD_NOT_SET;
}
inline TermConditionalEvaluation::EvalMethodCase TermConditionalEvaluation::eval_method_case() const {
  return TermConditionalEvaluation::EvalMethodCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace delivery

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::delivery::RankingMethod> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::delivery::RankingMethod>() {
  return ::delivery::RankingMethod_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_proto_2fdelivery_2fblender_2eproto
